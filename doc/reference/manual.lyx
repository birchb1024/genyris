#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Genyris User Manual
\end_layout

\begin_layout Standard
\align center
Version @GENYRIS-SPECIFICATION-VERSION@
\end_layout

\begin_layout Standard
\align center
Build @GENYRIS-IMPLEMENTATION-VERSION@
\end_layout

\begin_layout Standard
\align center
Peter William Birch
\end_layout

\begin_layout Standard
\noindent
\align center
birchb@genyris.org
\end_layout

\begin_layout Abstract
This document is the user manual for the Genyris scripting language, that
 combines influences from the Semantic Web, Scheme, Smalltalk and Python.
 
\end_layout

\begin_layout Abstract
Incomplete sections marked 
\emph on
'TODO'.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Subsubsection*
Conventions used in this document:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\emph on
italicized
\emph default
Snippets of Genyris programs
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
fixed-font
\family default
 Larger programs are in a fixed font.
 Interactive sessions are show with the
\family typewriter
>
\family default
 prompt of the command-line interpreter and the results printed underneath.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Quick Start
\end_layout

\begin_layout Subsection*
Getting Genyris
\end_layout

\begin_layout Standard
The Genyris project is hosted on Google Code here:
\emph on
 http://code.google.com/p/genyris/.
 
\emph default
In the 
\emph on
Downloads
\emph default
 tab, look for the latest binary file which has the form
\emph on
 genyris-binary-NNN-XXXXXXXXXXXX.BB.zip.
 
\emph default
The release number is the 
\emph on
NNN
\emph default
, choose the file with the largest release number.
 
\end_layout

\begin_layout Subsection*
Installation
\end_layout

\begin_layout Standard
Genyris is available as a
\emph on
 ZIP
\emph default
 file.
 This file needs to be unpacked into an empty directory such as 
\begin_inset Quotes eld
\end_inset

genyris
\begin_inset Quotes erd
\end_inset

.
 This becomes the home directory for Genyris.
\end_layout

\begin_layout Standard
Genyris is developed in Java hence needs a Java runtime.
 You don't need to understand Java to use Genyris.
 However you will need the Java 1.6 JRE
\begin_inset Index
status open

\begin_layout Plain Layout
JRE
\end_layout

\end_inset

 or later to run the Genyris interpreter.
 Java can be downloaded from Sun Microsystems.
 Check your JRE version with this command:
\end_layout

\begin_layout LyX-Code
$
\series bold
java -version
\end_layout

\begin_layout Standard
First change directory to the genyris home, then you can start the Genyris
 command-line interpreter with this command:
\end_layout

\begin_layout LyX-Code
$
\series bold
java -jar dist/genyris-bin-nnn-xxxxxxxxx.bbbb.jar
\end_layout

\begin_layout Standard
Where
\emph on
nnn-xxxxxxxxx.bbbb
\emph default
 is the version number.
 You will see a prompt indicating the interpreter is ready for your input:
\end_layout

\begin_layout LyX-Code
*** Genyris is listening...
\end_layout

\begin_layout LyX-Code
>
\end_layout

\begin_layout Standard
Refer to section
\begin_inset CommandInset ref
LatexCommand eqref
reference "sec:Running-Genyris"

\end_inset

 for details on how to simplify running Genyris using PATH settings.
\end_layout

\begin_layout Subsection*
Executing Expressions
\end_layout

\begin_layout Standard
Genyris commands can now be typed at the prompt, use two carriage returns
 (
\begin_inset Formula $\hookleftarrow$
\end_inset

) to terminate a statement.
 For example to add two numbers type:
\end_layout

\begin_layout LyX-Code
>
\series bold
+ 42 37
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout Standard
Genyris responds with the answer and a comment about the result:
\end_layout

\begin_layout LyX-Code
~ 79 # Bignum
\end_layout

\begin_layout Subsection*
Verifying the Install
\end_layout

\begin_layout Standard
To test the installation run the self test suite with the following command:
\end_layout

\begin_layout LyX-Code
>
\series bold
sys:self-test
\begin_inset Index
status open

\begin_layout Plain Layout

\series bold
sys:self-test
\end_layout

\end_inset


\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout Standard
All being well, it will print
\begin_inset Quotes eld
\end_inset

OK
\begin_inset Quotes erd
\end_inset

 and the number of tests passed.
\end_layout

\begin_layout Subsection*
Running Examples
\end_layout

\begin_layout Standard
The release binary file includes some examples in the
\emph on
examples
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
examples
\end_layout

\end_inset

folder.
 The files can be edited with your favourite text editor and run with the
\emph on
include
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
include
\end_layout

\end_inset

 function.
 For example, to load an run the
\begin_inset Quotes eld
\end_inset

Eight Queens
\begin_inset Quotes erd
\end_inset

 example do:
\end_layout

\begin_layout LyX-Code
>
\series bold
include 'examples/queens.g'
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 'file:/home/birchb/workspace/Genyris/examples/queens.g' # String
\end_layout

\begin_layout LyX-Code
>
\series bold
run-queens 8
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout Part
Language Manual
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Syntax
\end_layout

\begin_layout Standard
The syntax of Genyris uses indentation to convey program structure.
 This is in common with other languages such as Python.
 However Genyris preserves the
\begin_inset Quotes eld
\end_inset

prefix
\begin_inset Quotes erd
\end_inset

 notation of Lisp and Scheme.
 Here is an example of some code defining a function:
\end_layout

\begin_layout LyX-Code
def threat (i j a b)
\end_layout

\begin_layout LyX-Code
   or
\end_layout

\begin_layout LyX-Code
      equal? i a
\end_layout

\begin_layout LyX-Code
      equal? j b
\end_layout

\begin_layout LyX-Code
      equal? (- i j) (- a b)
\end_layout

\begin_layout LyX-Code
      equal? (+ i j) (+ a b)
\end_layout

\begin_layout Standard
Instead of curly braces or
\emph on
 begin
\emph default
 and
\emph on
 end
\emph default
 tokens, the indentation defines the blocks of code.
 Genyris reads lines one-by-one until it reaches the end of an expression.
 An expression ends when there are no more indented lines.
 The interactive command-line ends an expression whenever two blank lines
 are read.
 Within a line, tokens are separated by white-space.
 Genyris recognizes the following syntactic elements:
\end_layout

\begin_layout Itemize
Comments
\end_layout

\begin_layout Itemize
Numbers
\end_layout

\begin_layout Itemize
Strings
\end_layout

\begin_layout Itemize
Symbols
\end_layout

\begin_layout Itemize
Sub-expressions
\end_layout

\begin_layout Itemize
Lists
\end_layout

\begin_layout Itemize
Parser macros and directives
\end_layout

\begin_layout Subsubsection
Comments
\end_layout

\begin_layout Standard
All characters following a hash
\begin_inset Index
status open

\begin_layout Plain Layout
hash
\end_layout

\end_inset

 (pound) until the end of the line are ignored by the parser.
 For example:
\end_layout

\begin_layout LyX-Code

\series bold
# This whole line is a comment
\end_layout

\begin_layout LyX-Code
- 4 3 
\series bold
# this comment goes to the end
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsubsection
Numbers
\end_layout

\begin_layout Standard
Numbers can be either integers or floating point with any number of leading
 or trailing digits.
 Examples:
\end_layout

\begin_layout LyX-Code
-3 23.78 -100.0089  34.45e7
\end_layout

\begin_layout Subsubsection
Strings
\end_layout

\begin_layout Standard
Strings are delimited by either double quote characters " or single quotes
 '.
 Within a string quotes and special characters are escaped with backslash
 
\backslash
.
 For example
\family typewriter
\emph on
 "She said
\backslash
"sea shells
\backslash
"
\family default
\emph default
 "yields the string:
\end_layout

\begin_layout LyX-Code
She said "sea shells"
\end_layout

\begin_layout Standard
Other escape sequences are encoded as follows:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="bottom" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold

\backslash
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
newline
\begin_inset Index
status open

\begin_layout Plain Layout
New Line
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold

\backslash
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
carriage return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold

\backslash
f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
form feed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold

\backslash

\backslash

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
backslash
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold

\backslash
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tab
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold

\backslash

\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
quote
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold

\backslash
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
bell
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
single quote
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The two styles of string are internally identical, which allows you to avoid
 escaping.
 For example this string contains double quotes:
\end_layout

\begin_layout LyX-Code
'"After all," said the young man, "golf
\begin_inset Index
status open

\begin_layout Plain Layout
golf
\end_layout

\end_inset

 is only a game."'
\end_layout

\begin_layout Subsubsection
Symbols
\end_layout

\begin_layout Standard
Symbols are a group of any printable characters with the following exceptions:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
,
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
comma
\begin_inset Index
status open

\begin_layout Plain Layout
comma
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
^
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
carat
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
period
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
single quote
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
"
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
double quote
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
`
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
backquote
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
@
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
at sign
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
square
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
brackets
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
curly
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
brackets
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal sign
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
exclamation
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The following are all examples of valid symbols:
\end_layout

\begin_layout LyX-Code
Wednesday-12
\end_layout

\begin_layout LyX-Code
_age
\end_layout

\begin_layout LyX-Code
*global*
\end_layout

\begin_layout LyX-Code
+$
\end_layout

\begin_layout LyX-Code
<variable-name>
\end_layout

\begin_layout Standard
In Genyris symbols are 
\begin_inset Quotes eld
\end_inset

interned
\begin_inset Quotes erd
\end_inset

 by the parser so that there is only ever one instance of a particular symbol.
 Symbols are case sensitive so for example
\emph on
 Kookaburra
\emph default
 and
\emph on
 kookaburra
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
kookaburra
\end_layout

\end_inset


\emph default
 are different symbols.
\end_layout

\begin_layout Subsubsection
Denoting dynamic variables with periods.
\end_layout

\begin_layout Standard
If a symbol is preceded by a period it tells the evaluator that the symbol
 is referring to a dynamic symbol binding.
 
\end_layout

\begin_layout Subsubsection
Expressions and Sub-expressions
\end_layout

\begin_layout Standard
All Genyris expressions
\begin_inset Index
status open

\begin_layout Plain Layout
expressions
\end_layout

\end_inset

 are parsed and stored as linked-lists.
 A single line is converted into a single list.
 Sub-expressions are denoted in two ways, either within parentheses on a
 single line, or by an indented line.
 For example the following line contains two sub-expressions:
\end_layout

\begin_layout LyX-Code
Alpha (Beta Charlie) (Delta)
\end_layout

\begin_layout Standard
Sub-expressions made using parentheses must remain within a single line,
 they are not permitted to wrap.
 Indented lines are deemed to be sub-expressions of the superior, less indented,
 lines above.
 The above expression can be written in indented form as follows:
\end_layout

\begin_layout LyX-Code
Alpha
\end_layout

\begin_layout LyX-Code
   Beta Charlie
\end_layout

\begin_layout LyX-Code
   Delta
\end_layout

\begin_layout Standard
Indentations must line up with previous indentations
\begin_inset Index
status open

\begin_layout Plain Layout
indentation
\end_layout

\end_inset

 of the same level as follows (spaces indicated with periods):
\end_layout

\begin_layout LyX-Code
Alpha
\end_layout

\begin_layout LyX-Code
...Beta Charlie
\end_layout

\begin_layout LyX-Code
......Delta
\end_layout

\begin_layout LyX-Code
..
\series bold
.Echo
\series default
              # correct indentation
\end_layout

\begin_layout Standard
The parser is unable to cope with random indentation levels since it does
 not know what depth is required.
 The following example will generate an error:
\end_layout

\begin_layout LyX-Code
Alpha
\end_layout

\begin_layout LyX-Code
...Beta Charlie
\end_layout

\begin_layout LyX-Code
......Delta
\end_layout

\begin_layout LyX-Code
....
\series bold
Echo
\series default
              # *** ERROR
\end_layout

\begin_layout Subsubsection
Pairs
\begin_inset Index
status open

\begin_layout Plain Layout
Pairs
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Within Genyris lists are composed of pairs of references to objects
\begin_inset Foot
status open

\begin_layout Plain Layout
Lisp Cons
\begin_inset Index
status open

\begin_layout Plain Layout
Cons
\end_layout

\end_inset

 cells
\end_layout

\end_inset

.
 Pairs have two elements, the left
\begin_inset Index
status open

\begin_layout Plain Layout
left
\end_layout

\end_inset

 and right
\begin_inset Index
status open

\begin_layout Plain Layout
right
\end_layout

\end_inset

, which are references to other Genyris objects.
 The left and right halves of a
\emph on
Pair
\emph default
 can be delimited with the equals = character, an infix operator.
 For example:
\end_layout

\begin_layout LyX-Code
(1 =
\begin_inset Index
status open

\begin_layout Plain Layout
=
\end_layout

\end_inset

 2)
\end_layout

\begin_layout Standard
denotes a
\emph on
 Pair
\emph default
 referring to the numbers 1 and 2.
 Genyris expressions are also composed of linked lists of
\emph on
 Pairs
\emph default
, hence the expression:
\end_layout

\begin_layout LyX-Code
(A B C D)
\end_layout

\begin_layout Standard
is shorthand for :
\end_layout

\begin_layout LyX-Code
(A = (B = (C = (D = nil))))
\end_layout

\begin_layout Standard
Lists
\begin_inset Index
status open

\begin_layout Plain Layout
Lists
\end_layout

\end_inset

 are terminated with the special symbol 
\emph on
nil
\emph default
.
 An indented expression can be expressed in terms of 
\emph on
Pairs
\emph default
.
 Consider:
\end_layout

\begin_layout LyX-Code
Alpha
\end_layout

\begin_layout LyX-Code
   Beta
\end_layout

\begin_layout Standard
This is the same as
\end_layout

\begin_layout LyX-Code
(Alpha = ((Beta = nil) = nil))
\end_layout

\begin_layout Standard
Lists do not always have to be terminated with
\emph on
 nil
\emph default
 , the equal sign = operator can be used to squeeze one more object reference
 into the end of the list.
 For example the following list has
\emph on
 C
\emph default
 instead of
\emph on
 nil
\emph default
:
\end_layout

\begin_layout LyX-Code
(A B = C)
\end_layout

\begin_layout Standard
New pairs can be created explicitly with the cons function which takes two
 parameters - the left and right parts of a new pair.:
\end_layout

\begin_layout LyX-Code
> cons
\begin_inset Index
status open

\begin_layout Plain Layout
cons
\end_layout

\end_inset

 123 456
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
123 = 456 # Pair
\end_layout

\begin_layout Subsubsection
Quoting and Special Parser Characters
\end_layout

\begin_layout Standard
Lists and atoms can be quoted in Genyris.
 Quoting is used to prevent execution of expressions.
 A single atom can be quoted within an expression
\begin_inset Foot
status open

\begin_layout Plain Layout

\emph on
list
\emph default
 is a function we will cover later.
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
      list
\begin_inset Index
status open

\begin_layout Plain Layout
list
\end_layout

\end_inset

 1 2 ^a 3 4    # evaluates to: (1 2 a 3 4)
\end_layout

\begin_layout Standard
Carat characters are a shorthand notation to save typing.
 When the parser sees a carat, it collects the expression following and
 wraps it within a
\emph on
 quote
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
quote
\end_layout

\end_inset


\emph default
 expression.
 So
\emph on
 ^<exp>
\emph default
 becomes
\emph on
 (quote <exp>).
\emph default
When the
\emph on
 quote
\emph default
 function is evaluated it does not evaluate its argument.
 So the above expression is actually:
\end_layout

\begin_layout LyX-Code
      list  1 2 (quote a) 3 4
\end_layout

\begin_layout Standard
Embedded lists can be quoted, in which case the embedded list is not evaluated:
\end_layout

\begin_layout LyX-Code
      func 1 2 ^(x y z) 3 4
\end_layout

\begin_layout Standard
If the quote falls at the beginning of the line, only the first element
 is quoted, not the entire line.
 So:
\end_layout

\begin_layout LyX-Code
list 1 2
\end_layout

\begin_layout LyX-Code
   ^x y z
\end_layout

\begin_layout Standard
is the same as:
\end_layout

\begin_layout LyX-Code
      list 1 2 ((quote x) y z)
\end_layout

\begin_layout Standard
To allow entire sub-trees to be quoted, the quote function needs to be used
 as in this example:
\end_layout

\begin_layout LyX-Code
      list 1 2
\begin_inset Newline newline
\end_inset

         quote
\begin_inset Newline newline
\end_inset

           x y z
\end_layout

\begin_layout Standard
which is the same as:
\end_layout

\begin_layout LyX-Code
      list 1 2 (quote (x y z))
\end_layout

\begin_layout Subsubsection
Line Continuation
\begin_inset Index
status open

\begin_layout Plain Layout
Line Continuation
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sometimes long expressions become unwieldy and must be continued on following
 lines.
 There are two mechanisms for this.
 This first is to use the equal operator and an indented line as follows:
\end_layout

\begin_layout LyX-Code
list 1 2 3 4 5 =
\begin_inset Index
status open

\begin_layout Plain Layout
=
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
   
\series default
6 7 8
\end_layout

\begin_layout Standard
This is equivalent to:
\end_layout

\begin_layout LyX-Code
list 1 2 3 4 5 = (6 7 8)
\end_layout

\begin_layout Standard
which is the same as:
\end_layout

\begin_layout LyX-Code
list 1 2 3 4 5 6 7 8
\end_layout

\begin_layout Standard
The second and preferred method is the special line continuation character
 (the tilde
\begin_inset Index
status open

\begin_layout Plain Layout
tilde
\end_layout

\end_inset

 ~
\begin_inset Index
status open

\begin_layout Plain Layout
~
\end_layout

\end_inset

) which continues the previous line indentation
\begin_inset Index
status open

\begin_layout Plain Layout
indentation
\end_layout

\end_inset

 level at the start of the line under which it is placed.
 This allows arbitrary continuations such as:
\end_layout

\begin_layout LyX-Code
^
\end_layout

\begin_layout LyX-Code
  1 2
\end_layout

\begin_layout LyX-Code
      3
\end_layout

\begin_layout LyX-Code
      ~ 22
\end_layout

\begin_layout LyX-Code
      99
\end_layout

\begin_layout Standard
which is the same as:
\end_layout

\begin_layout LyX-Code
^ (1 2 (3) 22 (99))
\end_layout

\begin_layout Standard
if the tilde was not there the expression would become:
\end_layout

\begin_layout LyX-Code
^ (1 2 (3) (22) (99))
\end_layout

\begin_layout Subsubsection
More Quote Characters
\end_layout

\begin_layout Standard
Genyris also supports three other special syntactic quotes similar to the
 carat.
 They are all used to simplify writing macros with the
\emph on
 template
\emph default
 function, but can be used for anything else.
 These are converted by the parser into expressions as follows:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input Quote Sequence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Translated Expression
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
,
\begin_inset Index
status open

\begin_layout Plain Layout
,
\end_layout

\end_inset

<exp>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(comma
\begin_inset Index
status open

\begin_layout Plain Layout
comma
\end_layout

\end_inset

 <exp>)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
,@
\begin_inset Index
status open

\begin_layout Plain Layout
,@
\end_layout

\end_inset

<exp>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(comma-at
\begin_inset Index
status open

\begin_layout Plain Layout
comma-at
\end_layout

\end_inset

 <exp>)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
`
\begin_inset Index
status open

\begin_layout Plain Layout
`
\end_layout

\end_inset

<exp>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(template
\begin_inset Index
status open

\begin_layout Plain Layout
template
\end_layout

\end_inset

 <exp>)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Square and Curly Brackets
\begin_inset Index
status open

\begin_layout Plain Layout
Brackets
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The square []
\begin_inset Index
status open

\begin_layout Plain Layout
[]
\end_layout

\end_inset

 and curly {}
\begin_inset Index
status open

\begin_layout Plain Layout
{}
\end_layout

\end_inset

 brackets are parsed specially so they can be used by the user in the expression
s.
 In both cases they are converted to a list with a symbol as follows:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input Sequence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Translated Expression
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[<list>]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(squareBracket <list>)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{<list>}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(curlyBracket <list>)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 [1 2 3]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(squareBracket 1 2 3)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 {a b c}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(curlyBracket a b c)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Variables
\begin_inset Index
status open

\begin_layout Plain Layout
Variables
\end_layout

\end_inset


\end_layout

\begin_layout Standard
New variables are created with the
\emph on
 define
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
define
\end_layout

\end_inset


\emph default
 function.
 This function also take an initial value for the variable:
\end_layout

\begin_layout LyX-Code
define name 'William'
\end_layout

\begin_layout Standard
In the example, the symbol
\emph on
 name
\emph default
 is bound to the value
\emph on
 
\begin_inset Quotes eld
\end_inset

William
\begin_inset Quotes erd
\end_inset


\emph default
 in the current environment.
 After the variable has been bound, its value can be used in any expression
 in the scope.
 
\end_layout

\begin_layout Standard
When the interpreter sees a symbol in an argument list it looks for a binding
 in the current environment and all parent environments right up to the
 global execution environment.
 If you define a variable at the command line, it is bound in the global
 execution environment and hence is available everywhere.
 If you try to access a variable when there is no binding, an "unbound variable"
 error will be reported.
\end_layout

\begin_layout Standard
Variable values can be updated with the or
\emph on
 setq
\emph default
 function, for example:
\end_layout

\begin_layout LyX-Code
setq name 'William Pitt'
\end_layout

\begin_layout Standard
A predicate function
\emph on
 bound?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
bound?
\end_layout

\end_inset


\emph default
 is provided to test whether a symbol has a binding in the current environments.
 It returns the symbol
\emph on
 true
\emph default
 if the variable is defined otherwise
\emph on
 nil
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
nil
\end_layout

\end_inset


\emph default
.
\end_layout

\begin_layout Subsection
Functions
\end_layout

\begin_layout Standard
As we have seen, Genyris can execute statements immediately at the command
 line.
 The expression:
\end_layout

\begin_layout LyX-Code
+ 42 37
\end_layout

\begin_layout Standard
Yields the addition of the two numbers (79).
 Let's explore how this works.
 The interpreter looks for list expressions and assumes the first token
 (or sub-expression) is a procedure.
 The rest of the list constitute the arguments to the procedure.
 In this case
\emph on
+
\emph default
 is a symbol which yields a procedure object.
 The arguments are also evaluated and the results are passed to the procedure
 to be evaluated.
 Lets have a look at
\emph on
+
\emph default
 by getting its value:
\end_layout

\begin_layout LyX-Code
> the +
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ <org.genyris.math.PlusFunction> # EagerProcedure
\end_layout

\begin_layout Standard
The function
\emph on
 the
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
the
\end_layout

\end_inset


\emph default
 is the identity function - it simply returns the value of its argument.
 Since the symbol + is an argument to
\emph on
 the,
\emph default
 its value is the underlying procedure.
 A procedure, is an object which keeps a reference to the environment in
 which it was originally defined and the executable code to be run when
 called.
 In addition it knows how its arguments are to be handled before the executable
 code is run.
\end_layout

\begin_layout Subsubsection
Eager Functions
\end_layout

\begin_layout Standard
Eager
\begin_inset Index
status open

\begin_layout Plain Layout
Eager
\end_layout

\end_inset

 functions are the default in most programming languages.
 These evaluate their arguments prior to applying the underlying procedure.
 Mathematical functions such as
\emph on
+
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
+
\end_layout

\end_inset

 -
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
-
\end_layout

\end_inset

 *
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
*
\end_layout

\end_inset


\emph default
 and /
\begin_inset Index
status open

\begin_layout Plain Layout
/
\end_layout

\end_inset

 are eager functions.
 Let's experiment with some simple math function calls.
 All the following expressions evaluate to 12:
\end_layout

\begin_layout LyX-Code
+ 6 6
\end_layout

\begin_layout LyX-Code
+ (* 2 3) (+ 2 4)
\end_layout

\begin_layout LyX-Code
+ 2 2 2 2 2 2
\end_layout

\begin_layout Standard
Notice that the + function can have many arguments.
 Another function that takes multiple arguments is
\emph on
 list
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
list
\end_layout

\end_inset

.
 This function constructs a list from its arguments.
 Here's an example:
\end_layout

\begin_layout LyX-Code
> list (* 34 8) 'pears' (/ 34 5) 'kilos'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
272 'pears' 6.8 'kilos' # Pair
\end_layout

\begin_layout Standard
Note that the interpreter always prints a comment after the result.
 This comment is the list of classes the result belongs to.
 Since
\emph on
 list
\emph default
 returns a list, which is composed of Pairs,
\emph on
 
\begin_inset Quotes eld
\end_inset

Pair
\emph default

\begin_inset Quotes eld
\end_inset

 is printed.
\end_layout

\begin_layout Subsubsection
Lazy
\begin_inset Index
status open

\begin_layout Plain Layout
Lazy
\end_layout

\end_inset

 Functions
\end_layout

\begin_layout Standard
In contrast to Eager functions, Lazy functions do not evaluate their arguments.
 In other words, the interpreter passes the
\series bold
 source code
\series default
 of their arguments to the function.
 This allows the function to defer evalution or even exclude evaluation
 altogether, as is the case in conditional (flow control) constructs.
 The
\emph on
 quote
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
quote
\end_layout

\end_inset


\emph default
 function is a lazy procedure which returns its single argument un-evaluated.
 Example:
\end_layout

\begin_layout LyX-Code
> quote (* 5 6 7 8)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(* 5 6 7 8) # Pair
\end_layout

\begin_layout Standard
Notice that no multiplication has been performed here and the first parameter
 expression is returned.
\end_layout

\begin_layout Subsubsection
Defining Your Own Functions
\end_layout

\begin_layout Standard
Functions in Genyris are defined in the usual way for functional programming
 languages.
 The
\emph on
 def
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
def
\end_layout

\end_inset


\emph default
 function binds a name to a lexical closure
\begin_inset Index
status open

\begin_layout Plain Layout
lexical closure
\end_layout

\end_inset

 containing the current environment and the code to be applied in future
 calls.
 The body of the function is a sequence of expressions to be executed in
 the lexical environment, the last expression's value is returned.
 Here's a definition of the identity function:
\end_layout

\begin_layout LyX-Code
def identity (arg) arg
\end_layout

\begin_layout Standard
Genyris has two kinds of user-defined functions 'eager
\begin_inset Index
status open

\begin_layout Plain Layout
eager
\end_layout

\end_inset

' and 'lazy
\begin_inset Index
status open

\begin_layout Plain Layout
lazy
\end_layout

\end_inset

'.
 An eager function evaluates its arguments before it applies them, whereas
 a lazy function does not.
 Traditional functions such as '+' and
\emph on
 the
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
the
\end_layout

\end_inset


\emph default
 are eager.

\emph on
 list
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
list
\end_layout

\end_inset


\emph default
 is an eager function which returns all its arguments in a list.
\end_layout

\begin_layout Standard
Here is a more complex function definition:
\end_layout

\begin_layout LyX-Code
def factorial
\begin_inset Index
status open

\begin_layout Plain Layout
factorial
\end_layout

\end_inset

 (n)
\end_layout

\begin_layout LyX-Code
   if (< n 2) 1
\end_layout

\begin_layout LyX-Code
      * n
\end_layout

\begin_layout LyX-Code
        factorial (- n 1)
\end_layout

\begin_layout Standard
The
\emph on
 if
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
if
\end_layout

\end_inset


\emph default
 function is lazy, since, depending on the value of the first argument,
 it executes only one of its other two arguments .
 In fact,
\emph on
 if
\emph default
 is a macro
\begin_inset Index
status open

\begin_layout Plain Layout
macro
\end_layout

\end_inset

 - a special kind of lazy function which we introduce later.
\end_layout

\begin_layout Section
Bindings and Variables
\end_layout

\begin_layout Subsubsection
Definition of Variables
\end_layout

\begin_layout Standard
New variables are created with the
\emph on
 defvar
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
defvar
\end_layout

\end_inset


\emph default
 or
\emph on
 define
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
define
\end_layout

\end_inset


\emph default
 functions.
 These functions also take an initial value for the variable:
\end_layout

\begin_layout LyX-Code
define name 'William'
\end_layout

\begin_layout LyX-Code
defvar ^name 'William'
\end_layout

\begin_layout Standard
In both examples, the symbol
\emph on
 name
\emph default
 is bound to the value
\emph on
 
\begin_inset Quotes eld
\end_inset

William
\begin_inset Quotes erd
\end_inset


\emph default
 in the current environment.
 After the variable has been bound, its value can be used in any expression
 in the scope.
 The
\emph on
 define
\emph default
 function has an alias
\emph on
 var
\emph default
 which is quicker to type:
\end_layout

\begin_layout LyX-Code

\series bold
var
\series default
 name 'William'
\end_layout

\begin_layout Standard
When the interpreter sees a symbol in an argument list it looks for a binding
 in the current environment and all parent environments right up to the
 global execution environment.
 If you define a variable at the command line, it is bound in the global
 execution environment and hence is available everywhere.
 If you try to access a variable when there is no binding, an "unbound variable"
 error will be reported.
\end_layout

\begin_layout Standard
Variable values can be updated with the
\emph on
 set
\emph default
 or
\emph on
 setq
\emph default
 functions, for example:
\end_layout

\begin_layout LyX-Code
set ^name 'William Pitt
\begin_inset Index
status open

\begin_layout Plain Layout
William Pitt
\end_layout

\end_inset

'
\end_layout

\begin_layout LyX-Code
setq name 'William Pitt'
\end_layout

\begin_layout Paragraph

\emph on
var
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
var
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This macro creates a lexical bining between the 
\emph on
symbol
\emph default
 and the result of the 
\emph on
value expression
\emph default
.
 A alias for 
\emph on
define
\emph default
.
\end_layout

\begin_layout Standard
Syntax
\end_layout

\begin_layout LyX-Code
var <symbol> <value expression>
\end_layout

\begin_layout Standard
Example
\end_layout

\begin_layout Paragraph

\emph on
defvar
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
defvar
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This eager function creates a binding between the supplied symbol and the
 value.
 Symbols can be generated or obtained at run-time.
 The return value is the 
\emph on
<value
\emph default
>.
\end_layout

\begin_layout Standard
Syntax
\end_layout

\begin_layout LyX-Code
defvar <symbol> <value>
\end_layout

\begin_layout Standard
Examples
\end_layout

\begin_layout LyX-Code
assertEqual
\end_layout

\begin_layout LyX-Code
   'Foosball'
\end_layout

\begin_layout LyX-Code
   defvar (intern 'new-var') 'Foosball'
\end_layout

\begin_layout Paragraph

\emph on
define
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
define
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This lazy function creates a binding between the supplied symbol and the
 value.
 Symbols are not evaluated, hence are 'hard-coded' in the expression.
 The return value is the 
\emph on
<value
\emph default
>.
\end_layout

\begin_layout Standard
Syntax
\end_layout

\begin_layout LyX-Code
defvar <symbol> <value>
\end_layout

\begin_layout Standard
Examples
\end_layout

\begin_layout LyX-Code
assertEqual 20 (define twenty 20)
\end_layout

\begin_layout LyX-Code
assertEqual twenty 20
\end_layout

\begin_layout Paragraph

\emph on
bound?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
bound?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An eager predicate function 
\emph on
bound?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
bound?
\end_layout

\end_inset


\emph default
 tests whether a symbol has a binding in the current environments.
 Bindings can be created by:
\end_layout

\begin_layout Itemize
argument declaration in a closure, such as in a 
\emph on
def, defmacro, function
\emph default
, etc
\end_layout

\begin_layout Itemize
with 
\emph on
defvar
\emph default
 or 
\emph on
define
\end_layout

\begin_layout Itemize
with a Dymanic Symbol bound to an object
\end_layout

\begin_layout Standard
It returns the symbol
\emph on
 true
\emph default
 if the variable is defined otherwise
\emph on
 nil
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
nil
\end_layout

\end_inset


\emph default
.
\end_layout

\begin_layout Standard
Syntax
\end_layout

\begin_layout LyX-Code
bound? <symbol>
\end_layout

\begin_layout Standard
Examples
\end_layout

\begin_layout LyX-Code
> define s 12
\end_layout

\begin_layout LyX-Code
> bound? ^s
\end_layout

\begin_layout LyX-Code
true  # SimpleSymbol
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> (dict)
\end_layout

\begin_layout LyX-Code
   define .x 33
\end_layout

\begin_layout LyX-Code
   bound? ^.x
\end_layout

\begin_layout LyX-Code
true # SimpleSymbol
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
assert
\end_layout

\begin_layout LyX-Code
   ^(2)(bound? ^.left)
\end_layout

\begin_layout Subsubsection
Assignment
\end_layout

\begin_layout Paragraph

\emph on
setq
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
setq
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This lazy function is identical to 
\emph on
define
\emph default
, however the binding must have been previously declared.
 Example:use 
\end_layout

\begin_layout LyX-Code
> setq tweny 200
\end_layout

\begin_layout LyX-Code
*** Error - 'unbound: tweny'
\end_layout

\begin_layout LyX-Code
assertEqual 20 (define twenty 20)
\end_layout

\begin_layout LyX-Code
assertEqual 200 (setq twenty 200)
\end_layout

\begin_layout Paragraph

\emph on
set
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
set
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This lazy funtion is identical to 
\emph on
def
\emph default
 var, however the binding must have been previously declared.
 Example:
\end_layout

\begin_layout LyX-Code
def func (another-var)
\end_layout

\begin_layout LyX-Code
   set (left (list ^another-var)) 'Tennis'
\end_layout

\begin_layout LyX-Code
assertEqual 'Tennis' (func 123)
\end_layout

\begin_layout Subsubsection
Definition of Functions
\end_layout

\begin_layout Paragraph

\emph on
def
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
def
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
def
\emph default
 macro declares new eager functions.
 Refer to 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Functions-and-Macros"

\end_inset

 for details.
\end_layout

\begin_layout Subparagraph*
Syntax
\end_layout

\begin_layout LyX-Code
def <name> <argument list> <body>
\end_layout

\begin_layout Standard
Where 
\emph on
<name> 
\emph default
is a symbol, 
\emph on
<argument list>
\emph default
 is a list of simple symbols and type declarators and 
\emph on
<body>
\emph default
 is a sequence of expressions.
 The 
\emph on
def
\emph default
 macro is equivalent to 
\emph on
define
\emph default
 and 
\emph on
function, 
\emph default
and has the effect of:
\end_layout

\begin_layout LyX-Code
define <name> 
\end_layout

\begin_layout LyX-Code
   function <argument list> <body>
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
def square(x)
\end_layout

\begin_layout LyX-Code
   * x x
\end_layout

\begin_layout LyX-Code
assertEqual 64 (square 8)
\end_layout

\begin_layout Paragraph

\emph on
df
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
df
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
def
\emph default
 macro declares new lazy functions.
 Refer to 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Functions-and-Macros"

\end_inset

 for details.
\end_layout

\begin_layout Subparagraph*
Syntax
\end_layout

\begin_layout LyX-Code
df <name> <argument list> <body>
\end_layout

\begin_layout Standard
Where 
\emph on
<name> 
\emph default
is a symbol, 
\emph on
<argument list>
\emph default
 is a list of simple symbols and type declarators and 
\emph on
<body>
\emph default
 is a sequence of expressions.
 The 
\emph on
df
\emph default
 macro is equivalent to 
\emph on
define
\emph default
 and 
\emph on
lamdaq, 
\emph default
and has the effect of:
\end_layout

\begin_layout LyX-Code
define <name> 
\end_layout

\begin_layout LyX-Code
   lambdaq <argument list> <body>
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
df rev-quote (x)
\end_layout

\begin_layout LyX-Code
    reverse x
\end_layout

\begin_layout LyX-Code
assertEqual
\end_layout

\begin_layout LyX-Code
   ^(3.4 's' 2 w +)
\end_layout

\begin_layout LyX-Code
   rev-quote 
\end_layout

\begin_layout LyX-Code
       + w 2 's' 3.4
\end_layout

\begin_layout Paragraph

\emph on
defmacro
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
defmacro
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
defmacro
\emph default
 macro declares new lazy functions which evaluate twice, once in the lexical
 scope of the function, the return value of which is evaluated in the environmen
t of the caller.
 Refer to 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Functions-and-Macros"

\end_inset

 for details.
\end_layout

\begin_layout Subparagraph*
Syntax
\end_layout

\begin_layout LyX-Code
defmacro <name> <argument list> <body>
\end_layout

\begin_layout Standard
Where 
\emph on
<name> 
\emph default
is a symbol, 
\emph on
<argument list>
\emph default
 is a list of simple symbols and type declarators and 
\emph on
<body>
\emph default
 is a sequence of expressions.
 The 
\emph on
defmacro
\emph default
 macro is equivalent to 
\emph on
define
\emph default
 and 
\emph on
lamdam, 
\emph default
and has the effect of:
\end_layout

\begin_layout LyX-Code
define <name> 
\end_layout

\begin_layout LyX-Code
   lambdam <argument list> <body>
\end_layout

\begin_layout Standard
Example.
 Here we define a macro, 
\emph on
@
\emph default
, which is equivalent to 
\emph on
define
\emph default
:
\end_layout

\begin_layout LyX-Code
defmacro @ (variable valu)
\end_layout

\begin_layout LyX-Code
   template
\end_layout

\begin_layout LyX-Code
      defvar ^,variable ,valu
\end_layout

\begin_layout LyX-Code
assertEqual
\end_layout

\begin_layout LyX-Code
   @ w 123
\end_layout

\begin_layout LyX-Code
   123
\end_layout

\begin_layout LyX-Code
assertEqual w 123
\end_layout

\begin_layout Subsubsection

\emph on
symbol-value
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
symbol-value
\end_layout

\end_inset


\emph default
 <symbol>
\end_layout

\begin_layout Standard
Returns the value of the binding of it's argument in the current lexical
 or dynamic scope.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
> (dict (.a = 1)(.b = 2))
\end_layout

\begin_layout LyX-Code
    (symbol-value ^.b)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
2 # Bignum
\end_layout

\begin_layout Standard
More complex example:
\end_layout

\begin_layout LyX-Code
> var D (dict (.a=1)(.b=2))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> for v in D
\end_layout

\begin_layout LyX-Code
   u:format "%s = %s
\backslash
n" v (D (symbol-value v))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
.b = 2
\end_layout

\begin_layout LyX-Code
.a = 1
\end_layout

\begin_layout LyX-Code
.self = (dict (.a = 1) (.b = 2))
\end_layout

\begin_layout LyX-Code
.vars = (.b .a .self .vars .classes)
\end_layout

\begin_layout LyX-Code
.classes = (<class Dictionary (Builtin)>)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsubsection

\emph on
dynamic-symbol-value
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
dynamic-symbol-value
\end_layout

\end_inset


\emph default
 <symbol>
\end_layout

\begin_layout Standard
This function returns a dynamic symbol reference given a simple symbol.
 
\end_layout

\begin_layout Subparagraph*
Syntax:
\end_layout

\begin_layout LyX-Code
dynamic-symbol-value <symbol>
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
> dynamic-symbol-value ^left
\end_layout

\begin_layout LyX-Code
.left # DynamicSymbolRef
\end_layout

\begin_layout Standard
Example, here the dynamic symbol reference is dynamically created from the
 string 
\emph on
'right'
\emph default
 via 
\emph on
intern
\emph default
:
\end_layout

\begin_layout LyX-Code
assertEqual
\end_layout

\begin_layout LyX-Code
   45
\end_layout

\begin_layout LyX-Code
   ^(78 = 45)
\end_layout

\begin_layout LyX-Code
       eval 
\end_layout

\begin_layout LyX-Code
          dynamic-symbol-value (intern 'right')
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Control Flow
\end_layout

\begin_layout Subsection
Predicates
\end_layout

\begin_layout Standard
Predicates are a general class of functions which either return
\emph on
 nil
\emph default
 to signify falsehood, or a non
\emph on
-nil
\emph default
 value for truth.
\end_layout

\begin_layout Subsubsection

\emph on
nil
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
nil
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This symbol is used to denote an empty list, the end of a list.
 It is used by the conditional macro
\emph on
 cond
\emph default
 amongst others to denote falsehood.

\emph on
 nil
\emph default
 is bound to itself in the global environment.
 The empty list
\emph on
 ()
\emph default
 is a synonym for nil.
\end_layout

\begin_layout Subsubsection
true
\begin_inset Index
status open

\begin_layout Plain Layout
true
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A convenient symbol used to explicitly signal the opposite of
\emph on
 nil
\emph default
,
\emph on
 true
\emph default
 is bound to itself in the global environment.
\end_layout

\begin_layout Subsubsection
Comparisons
\end_layout

\begin_layout Paragraph
eq? <a> <b>
\end_layout

\begin_layout Standard
The
\emph on
 eq?
\emph default
 function compares two expressions to see if they are the same physical
 object in the interpreter memory.
 In other words it returns
\emph on
 true if
\emph default
 the by-value references passed in as parameters are the same, otherwise
\emph on
 nil
\emph default
 is returned.
 Examples:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expression
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
eq?
\emph default
 return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
eq? ^a ^a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
eq? 1 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nil
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
eq? 'c' 'c'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nil
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
equal?
\end_layout

\begin_layout Standard
The
\emph on
 equal?
\emph default
 function compares the contents of two expressions and returns
\emph on
 true
\emph default
 if they have the same value, otherwise
\emph on
 nil.

\emph default
 If two expressions are
\emph on
 eq?
\emph default
 they are also
\emph on
 equal?
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expression
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
equal?
\emph default
 return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal? ^a ^a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal? 1 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal? 'c' 'c'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal? ^(1 2) ^(1 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal? (dict (.a=2))(dict(.a=2))
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
>
\end_layout

\begin_layout Standard
The greater-than function returns
\emph on
 true
\emph default
 if its first argument is numerically greater than its second argument.
\end_layout

\begin_layout Paragraph
<
\end_layout

\begin_layout Standard
The less-than function returns
\emph on
 true
\emph default
 if its first argument is numerically less than its second argument.
\end_layout

\begin_layout Subsubsection
Logical Functions
\end_layout

\begin_layout Standard
Genyris has a set of boolean functions which expect arguments which are
 either
\emph on
 nil
\emph default
 to signify falsehood or non-
\emph on
nil
\emph default
 for truth.
\end_layout

\begin_layout Paragraph
not
\begin_inset Index
status open

\begin_layout Plain Layout
not
\end_layout

\end_inset

 <x>, null?
\end_layout

\begin_layout Standard
If the argument is
\emph on
 nil
\emph default
 these functions return
\emph on
 true
\emph default
 otherwise
\emph on
 nil
\emph default
 is returned
\emph on
.
\end_layout

\begin_layout Paragraph
and
\begin_inset Index
status open

\begin_layout Plain Layout
and
\end_layout

\end_inset

 <a1> <a2> ...
\end_layout

\begin_layout Standard
This macro executes its arguments in turn, if an argument evaluates to a
\emph on
 nil
\emph default
 value execution stops and it returns
\emph on
 nil.
\emph default
Otherwise execution continues to the last argument whose value is returned.
 Examples:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expression
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Result
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and 1 2 3 4 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and 1 2 3 nil 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nil
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and (print 1) (print 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Both 1 and 2 are printed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and (not (print 1)) (print 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nil
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 is printed
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
or
\begin_inset Index
status open

\begin_layout Plain Layout
or
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This macro executes its arguments in turn, if an argument evaluates to a
 non-
\emph on
nil
\emph default
 value execution stops and it returns
\emph on
 true.

\emph default
 Examples:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expression
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Result
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
or 1 2 3 4 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
or nil 2 3 nil 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
or (print 1) (print 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 is printed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
or (not (print 1)) (print 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 and 2 are printed
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Conditional Execution
\end_layout

\begin_layout Subsubsection
cond
\end_layout

\begin_layout Standard
The
\emph on
 cond
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
cond
\end_layout

\end_inset


\emph default
 function is a lazy function that allows program flow to change depending
 on the outcome of conditional expressions.
 Here's the syntax of
\emph on
 cond
\emph default
:
\end_layout

\begin_layout LyX-Code
   cond
\end_layout

\begin_layout LyX-Code
      (<condition 1>)
\end_layout

\begin_layout LyX-Code
         <sequence 1>
\end_layout

\begin_layout LyX-Code
      (<condition 2>)
\end_layout

\begin_layout LyX-Code
         <sequence 2>
\end_layout

\begin_layout LyX-Code
      ...
\end_layout

\begin_layout LyX-Code
      (<condition N>)
\end_layout

\begin_layout LyX-Code
         <sequence N>
\end_layout

\begin_layout Standard
Each condition is evaluated in turn until one returns which is not
\emph on
 nil
\emph default
.
 The associated sequence is evaluated and the value of the last expression
 in the sequence is returned.
 If there is no sequence, the value of the condition is returned.
 Typically the last condition is a non-nil constant and its sequence is
 the default.
 The symbol
\emph on
 else
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
else
\end_layout

\end_inset


\emph default
 is provided for this purpose.
 Here's an example:
\end_layout

\begin_layout LyX-Code
   cond
\end_layout

\begin_layout LyX-Code
      (equal? foo 1)
\end_layout

\begin_layout LyX-Code
         'One'
\end_layout

\begin_layout LyX-Code
      (equal? foo 2)
\end_layout

\begin_layout LyX-Code
         'Two'
\end_layout

\begin_layout LyX-Code
      else
\end_layout

\begin_layout LyX-Code
         'Other'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
The function
\emph on
 equal?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
equal?
\end_layout

\end_inset


\emph default
 returns
\emph on
 true
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
true
\end_layout

\end_inset


\emph default
 if the two arguments are the same otherwise
\emph on
 nil
\emph default
.
 So if the symbol
\emph on
 foo
\emph default
 is bound to the value 2 this expression will return
\emph on
 'Two'
\emph default
.
\end_layout

\begin_layout Subsubsection

\emph on
if
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
if
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The
\emph on
 if
\emph default
 statement is a shortened form of the
\emph on
 cond
\emph default
 function, it only allows a single condition with the following syntax:
\end_layout

\begin_layout LyX-Code
if <condition>
\end_layout

\begin_layout LyX-Code
   <evaluated if condition is not nil>
\end_layout

\begin_layout LyX-Code
   <evaluated if is nil>
\end_layout

\begin_layout Standard
It could be called the 'if-not-nil' statement because it's action depends
 on whether the condition expression is
\emph on
 nil
\emph default
 or not.
 Example:
\end_layout

\begin_layout LyX-Code
if (< n 2) 1
\end_layout

\begin_layout LyX-Code
      * n
\end_layout

\begin_layout LyX-Code
        factorial (- n 1)
\end_layout

\begin_layout Subsection
Looping and Iterators
\end_layout

\begin_layout Subsubsection
Simple looping with
\emph on
 while
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
while
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Syntax:
\end_layout

\begin_layout LyX-Code
while <expression>
\end_layout

\begin_layout LyX-Code
    <body>
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
define names ^(Church McCarthy Russell)
\end_layout

\begin_layout LyX-Code
while names
\end_layout

\begin_layout LyX-Code
   print names
\end_layout

\begin_layout LyX-Code
   setq names (right names)
\end_layout

\begin_layout Standard
outputs:
\end_layout

\begin_layout LyX-Code
Church McCarthy Russell
\end_layout

\begin_layout LyX-Code
McCarthy Russell
\end_layout

\begin_layout LyX-Code
Russell
\end_layout

\begin_layout Subsubsection
Creating Iterators with .mkIterator
\begin_inset Index
status open

\begin_layout Plain Layout
.mkIterator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Syntax:
\end_layout

\begin_layout LyX-Code
<expression>(.mkIterator)
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
define L ^(1 2)
\end_layout

\begin_layout LyX-Code
define iter (L(.mkIterator))
\end_layout

\begin_layout LyX-Code
assert
\end_layout

\begin_layout LyX-Code
   equal?
\end_layout

\begin_layout LyX-Code
      list (iter) (iter) (iter)
\end_layout

\begin_layout LyX-Code
      ^(1 2 sys:StopIteration)
\end_layout

\begin_layout Subsubsection
Traversing with
\emph on
 for
\end_layout

\begin_layout Standard
Syntax:
\end_layout

\begin_layout LyX-Code
for <var> in <expression-with-.mkIterator>
\end_layout

\begin_layout LyX-Code
    <body>
\end_layout

\begin_layout Standard
List example:
\end_layout

\begin_layout LyX-Code
define n ^(1 2)
\end_layout

\begin_layout LyX-Code
define z ^(A B)
\end_layout

\begin_layout LyX-Code
for v1 in n
\end_layout

\begin_layout LyX-Code
   for v2 in z
\end_layout

\begin_layout LyX-Code
        u:format "%s %s
\backslash
n" v1 v2
\end_layout

\begin_layout Standard
prints:
\end_layout

\begin_layout LyX-Code
1 A
\end_layout

\begin_layout LyX-Code
1 B
\end_layout

\begin_layout LyX-Code
2 A
\end_layout

\begin_layout LyX-Code
2 B
\end_layout

\begin_layout Standard
A dictionary example:
\end_layout

\begin_layout LyX-Code
var D (dict (.a=1)(.b=2))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
for v in D
\end_layout

\begin_layout LyX-Code
   u:format "%s = %s
\backslash
n" v (D (symbol-value v))
\end_layout

\begin_layout Standard
prints:
\end_layout

\begin_layout LyX-Code
.a = 1
\end_layout

\begin_layout LyX-Code
.b = 2
\end_layout

\begin_layout LyX-Code
.self = (dict (.a = 1) (.b = 2))
\end_layout

\begin_layout LyX-Code
.vars = (.a .b .self .vars .classes)
\end_layout

\begin_layout LyX-Code
.classes = (<class Dictionary (Builtin)>)
\end_layout

\begin_layout Subsubsection
Ranges
\end_layout

\begin_layout Standard
Syntax:
\end_layout

\begin_layout LyX-Code
range <low> <high>
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
> var R (range 1 3)
\end_layout

\begin_layout LyX-Code
(1 3) # Range Pair
\end_layout

\begin_layout LyX-Code
> var iter (R(.mkIterator))
\end_layout

\begin_layout LyX-Code
<EagerProc: <anonymous lambda>> # RangeIterator EagerProcedure
\end_layout

\begin_layout LyX-Code
> iter
\end_layout

\begin_layout LyX-Code
1 # Bignum
\end_layout

\begin_layout LyX-Code
> iter
\end_layout

\begin_layout LyX-Code
2 # Bignum
\end_layout

\begin_layout Standard
An example with
\emph on
for:
\end_layout

\begin_layout LyX-Code
> var array ^(A B C D E F)
\end_layout

\begin_layout LyX-Code
> for i in (range 3 5)
\end_layout

\begin_layout LyX-Code
     print (nth i array)
\end_layout

\begin_layout LyX-Code
~ D
\end_layout

\begin_layout LyX-Code
~ E
\end_layout

\begin_layout LyX-Code
~ F
\end_layout

\begin_layout Subsection
Exceptions
\end_layout

\begin_layout Standard
The Genyris interpreter signals errors via exceptions.
 Exceptions are 'raised' by the code that detected the error.
 When the interpreter is told to raise an exception it unrolls the execution
 stack until either the exeption is caught by a
\emph on
 catch
\emph default
 statement, ot the program halts.
 In some cases (perhaps due to a bug in the interpreter, or terminal conditions
 such as out of memory, the program prints the internal java stack and halts.)
 Sinec the interpreter has to do a lot of work to pop the stack, exceptions
 are not an efficient mechanism and are designed for handling exceptional
 circumstances.
\end_layout

\begin_layout Subsubsection
Popping the execution stack with
\emph on
 raise
\end_layout

\begin_layout Standard
To signal an error in a Genyris program, and to ask the interpreter to unroll
 the stack, use the
\emph on
 raise
\emph default
 function.
 This takes an object as its single argument which is passed up to the stack
 and is given to any
\emph on
 catch
\emph default
 functions which are above it in the stack.
 This way, details of the state of the system can be passed to error handling
 routines.
\end_layout

\begin_layout Standard
Syntax:
\end_layout

\begin_layout LyX-Code
raise <exception object>
\end_layout

\begin_layout Standard
For example, here we raise an exception in a base class if an abstract method
 is used:
\end_layout

\begin_layout LyX-Code
def .toMeters()
\end_layout

\begin_layout LyX-Code
   raise "Oops - you invoked an abstract method."
\end_layout

\begin_layout Subsubsection
Catching exceptions with
\emph on
 catch
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
catch
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The
\emph on
 catch
\emph default
 function executes a sequence of expressions, if no exception is raised
 it returns the value of the last expression.
 If an exception is raised during evaluation of the expressions, the exception
 object is assigned to a nominated variable.
 Without this function all errors would cause program execution to halt.
\end_layout

\begin_layout Standard
Syntax:
\end_layout

\begin_layout LyX-Code
catch <variable name>
\end_layout

\begin_layout LyX-Code
   <expression>
\end_layout

\begin_layout LyX-Code
   <expression>
\end_layout

\begin_layout LyX-Code
   ...
\end_layout

\begin_layout Standard
Here is a simplified top-level command line interpreter loop by way of example.
 Expressions are read from the keyboard and executed.
 If any exceptions are raised by the system or by the
\emph on
 raise
\emph default
 function they are caught and printed.
 Execution resumes.
 If the
\emph on
 catch
\emph default
 function was not used, the interpreter would stop execution of the loop
 at the first exception:
\end_layout

\begin_layout LyX-Code
while true
\end_layout

\begin_layout LyX-Code
   display '
\backslash
n>> '
\end_layout

\begin_layout LyX-Code
   catch errors
\end_layout

\begin_layout LyX-Code
       define expression (read)
\end_layout

\begin_layout LyX-Code
       define result (eval expression)
\end_layout

\begin_layout LyX-Code
   cond
\end_layout

\begin_layout LyX-Code
       errors
\end_layout

\begin_layout LyX-Code
          print errors
\end_layout

\begin_layout LyX-Code
       else
\end_layout

\begin_layout LyX-Code
          print result
\end_layout

\begin_layout Subsubsection
Inserting program checks with
\emph on
 assert
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
assert
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Often it is useful to insert checks in programs for invariant conditions
 that must be met.
 The
\emph on
 assert
\emph default
 macro provides a handy way to insert checks.
 If the expression passed to assert for evaluation is not
\emph on
 nil
\emph default
, an exception is automatically raised including the source code of the
 expression.
 Syntax:
\end_layout

\begin_layout LyX-Code
 assert <expression>
\end_layout

\begin_layout Standard
Example execution:
\end_layout

\begin_layout LyX-Code
> assert (equal? 1 2)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
*** Error - ("assert failed on expression: " (equal? 1 2))
\end_layout

\begin_layout LyX-Code
~ '<LazyProcedure: cond>'
\end_layout

\begin_layout LyX-Code
~ '<LazyProcedure: <assert>>'
\end_layout

\begin_layout LyX-Code
~ '<EagerProc: eval>'
\end_layout

\begin_layout LyX-Code
~ '<LazyProcedure: <define>>'
\end_layout

\begin_layout LyX-Code
~ '<LazyProcedure: catch>'
\end_layout

\begin_layout LyX-Code
~ '<LazyProcedure: while>'
\end_layout

\begin_layout LyX-Code
~ '<EagerProc: <|http://www.genyris.org/lang/system#read-eval-print-loop|>>'
\end_layout

\begin_layout Section
Functions and Macros
\begin_inset CommandInset label
LatexCommand label
name "sec:Functions-and-Macros"

\end_inset


\end_layout

\begin_layout Subsection
Anonymous Functions
\end_layout

\begin_layout Standard
Actually the
\emph on
 def
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
def
\end_layout

\end_inset


\emph default
 and
\emph on
 defmacro
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
defmacro
\end_layout

\end_inset


\emph default
 functions are lazy functions.
 They bind a variable name to procedure compiled from the function body.
 But what if we want a function without the binding? Genyris provides three
 kinds of in-built procedure-building functions.
 The function
\emph on
 function
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
function
\end_layout

\end_inset


\emph default
 (aka
\emph on
 lambda
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
lambda
\end_layout

\end_inset


\emph default
) creates a user-defined eager procedure object which is a closure at the
 point of definition.
 For example we can create an anonymous function at the command-line:
\end_layout

\begin_layout LyX-Code
> function (x) (* x x)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ <org.genyris.interp.ClassicFunction> # EagerProcedure
\end_layout

\begin_layout Standard
To actually call it we place it wherever a function is expected, such as
 a parameter to a function, or at the beginning of a list:
\end_layout

\begin_layout LyX-Code
> (function (x) (* x x)) 3
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 9 # Bignum
\end_layout

\begin_layout Standard
Notice the parentheses are required around the expression to trigger the
 execution.
 The argument 3 is passed to the resulting closure.
 Functions are 'first class' and can be assigned to variables, which is
 how
\emph on
 def
\emph default
 works.
 The following two expressions are equivalent:
\end_layout

\begin_layout LyX-Code
define square
\end_layout

\begin_layout LyX-Code
   function (x) (* x x)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def square (x)
\end_layout

\begin_layout LyX-Code
   * x x
\end_layout

\begin_layout Subsection
Closures
\end_layout

\begin_layout Standard
Closures are executable objects which retain the environment in which they
 were created for use during execution at a later time.
 
\end_layout

\begin_layout Subsubsection

\emph on
lambda
\emph default
 or
\emph on
 function
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
lambda
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
[function|lambda] ([arg1]...
 [&rest restargs] [= return-validator]) [body]
\end_layout

\begin_layout Standard
The
\emph on
 function
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
function
\end_layout

\end_inset


\emph default
 macro creates a lexical closure at the point of definition and returns
 an anonymous 'eager' procedure object.

\emph on
 lambda
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
lambda
\end_layout

\end_inset


\emph default
 is an alias for
\emph on
 function
\emph default
 and is kept for historical reasons.
 The procedure object can be invoked as a function.
 When the procedure is called its real arguments must match the formal arguments
 specified in the function definition.
 The formal arguments may have one of the following forms:
\end_layout

\begin_layout LyX-Code
()                     - no arguments
\end_layout

\begin_layout LyX-Code
(arg1 arg2 ...
 argn)   - a list of required arguments
\end_layout

\begin_layout LyX-Code
(...
 &rest <argsvar>)    - variable arguments
\end_layout

\begin_layout Standard
If the argument list includes &rest, all the remaining real arguments are
 collected into a list and passed to the function in a single argument,
 the name of which is specified after the &rest
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
&rest
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The function body - a list of expressions - is executed each expression
 in turn, the last evaluation is returned by the function.
 Formal arguments may be specified in two forms, either as a symbol or as
 a type specification.
 If a symbol is used, the real arguments are bound to the symbol in the
 execution environment of the function when it is called.
 The type of the formal argument may be supplied as the right hand side
 of a cons pair:
\end_layout

\begin_layout LyX-Code
(arg-name = validator)
\end_layout

\begin_layout Standard
The validator must be a symbol bound to a dictionary or class which has
 a validator function (
\emph on
.valid?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.valid?
\end_layout

\end_inset


\emph default
).
 When the procedure is called, the interpreter executes the 
\emph on
.valid?
\emph default
 function with the real argument as its single parameter.
 If the validator returns false, a type miss-match error is raised.
\end_layout

\begin_layout Standard
The expected type of the return value can be specified after a trailing
 = in the argument list.
\end_layout

\begin_layout Paragraph*
Examples:
\end_layout

\begin_layout LyX-Code
function ()
\end_layout

\begin_layout Standard
returns a procedure which returns nil
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
function (x y) (cons x y)
\end_layout

\begin_layout Standard
returns a procedure with two mandatory arguments
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
function (x &rest y) (list x y)
\end_layout

\begin_layout Standard
returns a procedure with one mandatory and one rest argument
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
function ((i = Bignum) (j = Bignum) = Bignum) (+ i j)
\end_layout

\begin_layout Standard
returns a procedure with two mandatory arguments with expected types and
 a return value with expected type.
\end_layout

\begin_layout Subsubsection
Closures Capture Environments
\end_layout

\begin_layout Standard
Genyris is "lexically scoped" - when a function is created it remembers
 the environment in which it was defined and re-uses that environment when
 it executes.
 This provides a way of hiding data and giving functions stateful side effects.
 The following example
\begin_inset Foot
status open

\begin_layout Plain Layout
refer to Abelson and Sussmans' book
\begin_inset Quotes eld
\end_inset

Structure and Interpretation of Computer Programs
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 creates a function which captures the
\emph on
 balance
\emph default
 variable:
\end_layout

\begin_layout LyX-Code
def make-withdraw (balance)
\end_layout

\begin_layout LyX-Code
   function (amount)
\end_layout

\begin_layout LyX-Code
      setq balance (- balance amount)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
define W1 (make-withdraw 100)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> W1 25
\end_layout

\begin_layout LyX-Code
W1 25
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 75 # Bignum
\end_layout

\begin_layout LyX-Code
~ 50 # Bignum
\end_layout

\begin_layout Standard
Repeated execution of the function
\emph on
 W1
\emph default
 reduces the value of the balance each time.
 The sequence of evaluation is as follows:
\end_layout

\begin_layout Enumerate
the lazy
\emph on
 def
\emph default
 expression is executed which results in a procedure object bound to the
 symbol
\emph on
 make-withdraw
\end_layout

\begin_layout Enumerate
the
\emph on
 balance
\emph default
 argument (
\emph on
100
\emph default
) to the eager
\emph on
 define
\emph default
 expression is evaluated and
\emph on
 make-withdraw
\emph default
 is called
\emph on
.
\end_layout

\begin_layout Enumerate
the eager
\emph on
 make-withdraw
\emph default
 creates a new environment in which it binds
\emph on
 balance
\emph default
 to
\emph on
100
\end_layout

\begin_layout Enumerate
the body of
\emph on
 make-withdraw
\emph default
 is evaluated resulting in another procedure object which captures a reference
 to
\emph on
 balance
\emph default
 and contains the executable code starting with
\emph on
 setq
\end_layout

\begin_layout Enumerate
the procedure object is bound to W1
\end_layout

\begin_layout Enumerate

\emph on
W1
\emph default
 is called with the argument 25
\end_layout

\begin_layout Enumerate
the procedure
\emph on
W1
\emph default
 subtracts 25 from the
\emph on
 balance
\emph default
 binding in theenvironment created in step 3
\end_layout

\begin_layout Standard
Note that there is no way to directly access the
\emph on
 balance
\emph default
 variable.
\end_layout

\begin_layout Subsection
Explicit Evaluation
\end_layout

\begin_layout Subsubsection
eval
\begin_inset Index
status open

\begin_layout Plain Layout
eval
\end_layout

\end_inset

 <expression>
\end_layout

\begin_layout Standard
The 
\emph on
eval
\emph default
 function returns the result of evaluating the expression in the environment
 of the caller.
 Since eval is an eager function, the expression is evaluated twice, once
 as a parameter and once by 
\emph on
eval
\emph default
 itself.

\emph on
 
\end_layout

\begin_layout Paragraph*
Syntax:
\end_layout

\begin_layout LyX-Code
eval <expression>
\end_layout

\begin_layout Paragraph*
Examples:
\end_layout

\begin_layout LyX-Code
assertEqual ^alpha
\end_layout

\begin_layout LyX-Code
   eval ^(left ^(alpha beta gamma))
\end_layout

\begin_layout LyX-Code
do
\end_layout

\begin_layout LyX-Code
   define alpha 1
\end_layout

\begin_layout LyX-Code
   assertEqual 1
\end_layout

\begin_layout LyX-Code
      eval (left ^(alpha beta gamma))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsubsection
apply
\begin_inset Index
status open

\begin_layout Plain Layout
apply
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The apply function returns the result of executing the closure with the
 argument list.
\end_layout

\begin_layout Paragraph*
Syntax:
\end_layout

\begin_layout LyX-Code
apply <closure> <argument list>
\end_layout

\begin_layout Paragraph*
Examples:
\end_layout

\begin_layout LyX-Code
assertEqual 6
\end_layout

\begin_layout LyX-Code
   apply + ^(1 2 3)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
assertEqual ^(23 = 23)
\end_layout

\begin_layout LyX-Code
   apply
\end_layout

\begin_layout LyX-Code
      function(x) (cons x x)
\end_layout

\begin_layout LyX-Code
      ^(23)
\end_layout

\begin_layout Subsection
Anonymous Lazy Functions
\end_layout

\begin_layout Standard
To defer evaluation, a lazy function can be defined using the
\emph on
 lambdaq
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
lambdaq
\end_layout

\end_inset


\emph default
 or
\emph on
 lambdam
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
lambdam
\end_layout

\end_inset


\emph default
 macros.

\emph on
 lambdaq
\emph default
 is just like
\emph on
 function
\emph default
 except it builds a lazy procedure,
\emph on
 lambdam
\emph default
 builds anonymous macros.
 The next example creates an anonymous function which prepends its argument
 (without evaluation) to a list:
\end_layout

\begin_layout LyX-Code
> (
\series bold
lambdaq
\series default
 (x) (list x 'World')) (+ 'Hello')
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(+ 'Hello') 'World' # Pair
\end_layout

\begin_layout Subsubsection

\emph on
lambadq
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
lambadq
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This macro is identical in syntax to
\emph on
 function
\emph default
 but it creates an anonymous lazy procedure (which does not execute it's
 arguments when called).
\end_layout

\begin_layout Subsubsection

\emph on
lambdam
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
lambdam
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This macro is identical in syntax to
\emph on
 function
\emph default
 but it creates a lazy procedure which re-executes it's return value in
 the environment of the caller - in other an anonymous macro.
\end_layout

\begin_layout Subsection
Defining Macros
\end_layout

\begin_layout Standard
Macros
\begin_inset Index
status open

\begin_layout Plain Layout
Macros
\end_layout

\end_inset

 are lazy functions which are very handy for extending the syntax of the
 language or creating Domain-Specific Languages
\begin_inset Index
status open

\begin_layout Plain Layout
Domain-Specific Languages
\end_layout

\end_inset

 (DSL
\begin_inset Index
status open

\begin_layout Plain Layout
DSL
\end_layout

\end_inset

s).
 Macros re-evaluate the returned value in the environment of the caller.
 Here's an example:
\end_layout

\begin_layout LyX-Code
defmacro trace(&rest body)
\end_layout

\begin_layout LyX-Code
  print body
\end_layout

\begin_layout LyX-Code
  body
\end_layout

\begin_layout Standard
This macro prints an expression which is then evaluated.
 The keyword
\emph on
 &rest
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
&rest
\end_layout

\end_inset


\emph default
 tells the interpreter to collate the values of all remaining arguments
 into the single variable
\emph on
 body
\emph default
.
 So when called with:
\end_layout

\begin_layout LyX-Code
> trace (+ 1 2)
\end_layout

\begin_layout Standard
It prints the expression and the result is calculated:
\end_layout

\begin_layout LyX-Code
(+ 1 2)
\end_layout

\begin_layout LyX-Code
~ 3 # Bignum
\end_layout

\begin_layout Standard
Here is a more complex example - definition of a control flow function:
\end_layout

\begin_layout LyX-Code
defmacro my-if (test success-result failure-result)
\end_layout

\begin_layout LyX-Code
   template
\end_layout

\begin_layout LyX-Code
      cond
\end_layout

\begin_layout LyX-Code
         ,test ,success-result
\end_layout

\begin_layout LyX-Code
         else ,failure-result
\end_layout

\begin_layout Standard
This macro uses the
\emph on
 template
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
template
\end_layout

\end_inset


\emph default
 function and
\emph on
 comma
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
comma
\end_layout

\end_inset


\emph default
 to splice the arguments into a formulaic expression.
 Here's an example if its use:
\end_layout

\begin_layout LyX-Code
define test 3    # binding in the caller's environment
\end_layout

\begin_layout LyX-Code
my-if (equal? test 3) 1 2
\end_layout

\begin_layout Standard
This returns 1.
 Notice how the variable
\emph on
 test
\emph default
 is defined in the caller's environment used in the condition, not the binding
 of the same name within
\emph on
 my-if
\emph default
.
\end_layout

\begin_layout Subsubsection
An Example: Executable Comments
\end_layout

\begin_layout Standard
Sometimes it's necessary to temporarily 'comment
\begin_inset Index
status open

\begin_layout Plain Layout
comment
\end_layout

\end_inset

 out' functions or provide in-line text.
 This is done via the function
\emph on
 '//
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
//
\end_layout

\end_inset

'
\emph default
 which is a lazy function that ignores it's arguments and return
\emph on
 nil
\emph default
.
 It is defined as:
\end_layout

\begin_layout LyX-Code
df // (&rest body)
\end_layout

\begin_layout Standard
and can be used as follows:
\end_layout

\begin_layout LyX-Code
// def allcommentedout(arg) # to comment out an entire function
\end_layout

\begin_layout LyX-Code
  function (x)
\end_layout

\begin_layout LyX-Code
    cond
\end_layout

\begin_layout LyX-Code
      (eq? nil (cdr x))
\end_layout

\begin_layout LyX-Code
         car x
\end_layout

\begin_layout LyX-Code
      else
\end_layout

\begin_layout LyX-Code
         last (cdr x)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def myfun()
\end_layout

\begin_layout LyX-Code
   // 'in-line  documentation'
\end_layout

\begin_layout LyX-Code
   +
\end_layout

\begin_layout LyX-Code
      // + 1   # however this causes an error because // returns nil.
\end_layout

\begin_layout LyX-Code
          + 34
\end_layout

\begin_layout LyX-Code
          + 45
\end_layout

\begin_layout LyX-Code
      99
\end_layout

\begin_layout Subsection

\emph on
template
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
template
\end_layout

\end_inset


\emph default
 <expression>
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection
Catching Missing Functions
\end_layout

\begin_layout Standard
When the interpreter executes an expression, such as 
\emph on
(proc arg1 arg2 ...)
\emph default
 but the 
\emph on
func
\emph default
 results in an 
\emph on
Unbound
\emph default
 exception
\begin_inset Foot
status open

\begin_layout Plain Layout
The current implementation uses Java exceptions to trap missing functions.
\end_layout

\end_inset

, the interpreter attempts to call the function 
\emph on
sys:procedure-missing.
 
\emph default
It passes the original arguments and the missing procedure expression to
 sys:procedure-missing.
 This provides the programmer with a facility to create dynamic (virtual)
 procedures.
 
\end_layout

\begin_layout Paragraph
Syntax
\end_layout

\begin_layout LyX-Code
sys:procedure-missing
\begin_inset Index
status open

\begin_layout Plain Layout
sys:procedure-missing
\end_layout

\end_inset

 <arguments>
\end_layout

\begin_layout Paragraph
Examples
\end_layout

\begin_layout Standard
In the first example, a generic function is defined which switches calls
 to dynamic functions: 
\end_layout

\begin_layout LyX-Code
def sys:procedure-missing(&rest args)
\end_layout

\begin_layout LyX-Code
  cond
\end_layout

\begin_layout LyX-Code
     (is-instance? (left args) DynamicSymbolRef)
\end_layout

\begin_layout LyX-Code
          .procedure-missing args
\end_layout

\begin_layout LyX-Code
     else
\end_layout

\begin_layout LyX-Code
          raise ("procedure missing: %s"(.format args))
\end_layout

\begin_layout Standard
Then a class is defined which catches calls to undefined methods:
\end_layout

\begin_layout LyX-Code
class MyClass()
\end_layout

\begin_layout LyX-Code
   def .method_missing(args)
\end_layout

\begin_layout LyX-Code
        list 'meta-method' args
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
var myObject
\end_layout

\begin_layout LyX-Code
    tag MyClass (dict)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
assertEqual        
\end_layout

\begin_layout LyX-Code
   myObject(.setName 'fred')
\end_layout

\begin_layout LyX-Code
   ^('meta-method' (.setName 'fred'))  
\end_layout

\begin_layout Standard
The second example is a very simple windows shell.
 When an unbound function is called, the 
\emph on
sys:procedure-missing 
\emph default
executes the call as a windows batch command.
 
\end_layout

\begin_layout LyX-Code
def sys:procedure-missing(&rest args)
\end_layout

\begin_layout LyX-Code
   left
\end_layout

\begin_layout LyX-Code
      apply os!exec (append ^(cmd /c) args)
\end_layout

\begin_layout Standard
Usage:      
\end_layout

\begin_layout LyX-Code
define my-dir 'test
\backslash

\backslash
fixtures
\backslash

\backslash
gunit'
\end_layout

\begin_layout LyX-Code
assertEqual
\end_layout

\begin_layout LyX-Code
  dir ^/b my-dir
\end_layout

\begin_layout LyX-Code
  ^('test-file-one.g' 'test-file-three.g''test-file-two.g')
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Everything is Callable
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Standard
The Genyris evaluator expects the first element of a list to be some kind
 of procedure
\begin_inset Index
status open

\begin_layout Plain Layout
procedure
\end_layout

\end_inset

 object - something that can compute its arguments and apply them.
 This is the role of traditional functions such as
\emph on
+
\emph default
 or user-defined functions.
 In Genyris,
\bar under
 all
\bar default
 objects are callable, even atomic types.
 For example an integer can be called as a function thus:
\end_layout

\begin_layout LyX-Code
>
\series bold
12
\series default
 (+ 33 44) (- 4 3)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 1 # Bignum
\end_layout

\begin_layout Standard
Lets analyse what happens.
 The integer
\emph on
 12
\emph default
 was called with two argument
\emph on
 (+ 33 44)
\emph default
 and
\emph on
 (- 4 3)
\emph default
.

\emph on
 12
\emph default
 is a lazy function and does not evaluate its arguments.
 It treats its arguments as a sequence of expressions to be evaluated in
 a new environment.
 So it calculated 333 + 44 = 77, and then 4 -3 = 1.
 When it reached this last expression it returned the value 1.
 This expression can be written in indented form with the same result as
 follows:
\end_layout

\begin_layout LyX-Code

\series bold
12
\end_layout

\begin_layout LyX-Code
   + 33 44
\end_layout

\begin_layout LyX-Code
   - 4 3
\end_layout

\begin_layout Standard
If an atom is called with no arguments, it simply returns itself.
 So at the command line typing a number alone returns the number:
\end_layout

\begin_layout LyX-Code
> 1024
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 1024 # Bignum
\end_layout

\begin_layout Standard
As well as executing the sequence of expressions, an execution environment
 was created in which the number 12 is a bound to the dynamic variable
\begin_inset Index
status open

\begin_layout Plain Layout
dynamic variable
\end_layout

\end_inset


\emph on
.self
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.self
\end_layout

\end_inset


\emph default
.
 The variable can be used as follows:
\end_layout

\begin_layout LyX-Code
> 12 (+
\series bold
.self .self
\series default
)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 24 # Bignum
\end_layout

\begin_layout Standard
Here the number is added to itself.
 The environment can also be used to create local bindings with the
\emph on
 define
\emph default
 functions:
\end_layout

\begin_layout LyX-Code
12
\end_layout

\begin_layout LyX-Code

\series bold
define foo 987
\end_layout

\begin_layout LyX-Code
  + foo .self
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 999 # Bignum
\end_layout

\begin_layout Standard
If a symbol is called as a function it is by default evaluated to locate
 the binding in the current evironment.
 If we make the value an atom, we can use the symbol as a a keyword.
 For example, the symbol
\emph on
 my-do
\emph default
 could be defined like this:
\end_layout

\begin_layout LyX-Code
define my-do ^my-do
\end_layout

\begin_layout Standard
Now whenever we call
\emph on
 my-do
\emph default
 as a function, it acts as a code block which can be used in a function:
\end_layout

\begin_layout LyX-Code

\series bold
def my-function()
\end_layout

\begin_layout LyX-Code

\series bold
   my-do
\end_layout

\begin_layout LyX-Code
      some-function 'Hi!'
\end_layout

\begin_layout LyX-Code
      define a-variable 42
\end_layout

\begin_layout LyX-Code
      print .self
\end_layout

\begin_layout Standard
However there is a catch - within the context the do block of
\emph on
 .self
\emph default
 is bound to
\emph on
 my-do
\emph default
.
 Hence the above function prints 
\begin_inset Quotes eld
\end_inset

my-do
\begin_inset Quotes erd
\end_inset

.
 A better way to add new syntax is to create a macro, since
\emph on
 .self
\emph default
 is not affected.
\end_layout

\begin_layout Subsection
Dynamic Variables
\begin_inset Index
status open

\begin_layout Plain Layout
Dynamic Variables
\end_layout

\end_inset


\end_layout

\begin_layout Standard
'Dynamic' variables are those which are bound in the environment of the
 caller and hence depend on who is evaluating the expression.
 In Genyris dynamic variables are limited to being properties of the currently
 called object, and called objects are part of their environment.
 In other words when an object is used as a procedure, the environment created
 to make the call is a merge of the object itself and a lexical environment.
 When prefixed with the period .
 character, the binding for the symbol is looked up in the dynamic context.
 An example will make this clearer:
\end_layout

\begin_layout Standard
The number 12 above has two dynamic variables,
\emph on
 .self
\emph default
 and
\emph on
 .classes
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.classes
\end_layout

\end_inset


\emph default
.
 They can be accessed as follows:
\end_layout

\begin_layout LyX-Code
12
\end_layout

\begin_layout LyX-Code
  print .self .classes
\end_layout

\begin_layout Standard
Here we see that the
\emph on
 .classes
\emph default
 variable is referring to the class list of
\emph on
 12.

\emph default
 It has a single class,
\emph on
 Bignum,
\emph default
 which is printed.
 This behaviour is the same for the other atomic types: Bignums, Pairs and
 Strings.
 Consider the following examples:
\end_layout

\begin_layout LyX-Code
> 'What am I?'.classes
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
<class String (Builtin)> # Pair
\end_layout

\begin_layout Standard
However where symbols are concerned, the evaluator always looks up the value
 binding.
 So to work with a symbol we must first quote it:
\end_layout

\begin_layout LyX-Code
> ^a-symbol .classes
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(<class SimpleSymbol (Symbol)>) # Pair
\end_layout

\begin_layout Standard
Likewise the interpreter assumes a list is a normal function call so a quote
 is needed to see this behaviour:
\end_layout

\begin_layout LyX-Code
> ^(3) .classes
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
<class Pair (Builtin)> # Pair
\end_layout

\begin_layout Standard
Most atomic types have only a single dynamic variable, richer examples lie
 in the compound object types.
\end_layout

\begin_layout Subsection
Synactic Sugar - Using the exclamation mark
\begin_inset Foot
status open

\begin_layout Plain Layout
The choice of this syntax is a tribute to Martin Richards
\begin_inset Index
status open

\begin_layout Plain Layout
Martin Richards and BCPL
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The exclamation mark
\begin_inset Index
status open

\begin_layout Plain Layout
exclamation mark
\end_layout

\end_inset

, ! (aka pling
\begin_inset Index
status open

\begin_layout Plain Layout
pling
\end_layout

\end_inset

) provides a shorthand way of accessing the properties of an object.
 This is implemented in the parser like quotes.
 Here are some examples:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Input Quote Sequence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Translated Expression
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a!left
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(a .left)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a!b!c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
((a .b) .c)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(f).a!b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(f)(.a .b)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(dict)!self
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
((dict) .self)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a!b(var .x 23)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(a .b)(var .x 23)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.x!y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(.x .y)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The expression 
\end_layout

\begin_layout LyX-Code
(file.copy) filename '/tmp/foo'
\end_layout

\begin_layout Standard
can be written succinctly as:
\end_layout

\begin_layout LyX-Code
   file!copy filename '/tmp/foo'
\end_layout

\begin_layout Subsection
use <expression>
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Section
Data Structures
\end_layout

\begin_layout Subsection
Bignum
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Maths Functions
\end_layout

\begin_layout Standard
Genyris includes basic arithmetic operations on Bignum obects.
\end_layout

\begin_layout Paragraph

\emph on
+
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
+
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function computes the sum of its arguments, which may be many.
\end_layout

\begin_layout Paragraph

\emph on
-
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
-
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function computes the accumulated difference of its arguments, which
 may be many.
 Example:
\end_layout

\begin_layout LyX-Code
(- 1 2 3) => -4
\end_layout

\begin_layout Paragraph
*
\begin_inset Index
status open

\begin_layout Plain Layout
*
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function computes the product of its arguments, which must number two
 or more.
\end_layout

\begin_layout Paragraph
/
\begin_inset Index
status open

\begin_layout Plain Layout
/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function computes the quotient of its arguments, which must number
 at two or more.
\end_layout

\begin_layout Paragraph
%
\end_layout

\begin_layout Standard
This function computes the remainder of its first argument divided by the
 second.
\end_layout

\begin_layout Paragraph
power
\begin_inset Index
status open

\begin_layout Plain Layout
power
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function calculates the first argument raised to the power of the second.
 Example:
\emph on
(power 2 8) => 256
\end_layout

\begin_layout Subsection
Lists and Pairs
\end_layout

\begin_layout Standard
Like its forbears Lisp and Scheme, Genyris is a list-processing
\begin_inset Index
status open

\begin_layout Plain Layout
list-processing
\end_layout

\end_inset

 language - its source code is expressed as lists and it has inbuilt functions
 for parsing and manipulating list data.
 Since programs and data are stored in the same form, Genyris is an ideal
 platform for developing DSLs or even new programming languages.
 Happily, manipulating lists is easy.
 Lists are a kind of binary tree.
 Trees are constructed with the
\emph on
 cons
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
cons
\end_layout

\end_inset


\emph default
 function which accepts two arguments for the left and right halves of the
\emph on
 Pair
\emph default
:
\end_layout

\begin_layout LyX-Code
> cons 'A' 'B'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
('A' = 'B') # Pair
\end_layout

\begin_layout Standard
The interpreter prints an equal sign between the left and right halves of
 the Pair.
 The individual elements of a Pair can be accessed with the
\emph on
 left
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
left
\end_layout

\end_inset


\emph default
 and
\emph on
 right
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
right
\end_layout

\end_inset


\emph default
 functions:
\end_layout

\begin_layout LyX-Code
> left (cons 'A' 'B')
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
'A' # String
\end_layout

\begin_layout Standard
Alternatively the dynamic variables
\emph on
 .left
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.left
\end_layout

\end_inset


\emph default
 and
\emph on
 .right
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.right
\end_layout

\end_inset


\emph default
 can be used when the list is called:
\end_layout

\begin_layout LyX-Code
> var my-pair (cons 'A' 'B')
\end_layout

\begin_layout LyX-Code
my-pair .right
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
'B' # String
\end_layout

\begin_layout LyX-Code
> my-pair
\end_layout

\begin_layout LyX-Code
   setq .left 33
\end_layout

\begin_layout LyX-Code
   .self
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
33 = 'B' # Pair
\end_layout

\begin_layout Standard
To construct a proper List, the final right hand element will be
\emph on
 nil
\emph default
:
\end_layout

\begin_layout LyX-Code
> cons 'A'
\end_layout

\begin_layout LyX-Code
    cons 'B'
\end_layout

\begin_layout LyX-Code
       cons 'C' nil
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
'A' 'B' 'C' # Pair
\end_layout

\begin_layout Standard
The printing of trees (by default) assumes that the tree is a kind of list,
 hence you don't see the parentheses in this case.
 The interpreter identified the list as a
\emph on
 Pair
\emph default
, since it only has a reference to the first
\emph on
 Pair
\emph default
.
\end_layout

\begin_layout Standard
To help view
\emph on
 Pairs
\emph default
 explicitly, a list is tagged with the PRINTWITHEQ
\begin_inset Index
status open

\begin_layout Plain Layout
PRINTWITHEQ
\end_layout

\end_inset

 class, which forces the printer to display the full tree structure.
 The parser does this automatically, so Pairs which the user types with
 an equal sign are printed the same way.
 For example:
\end_layout

\begin_layout LyX-Code
> ^('A' = ('B' = ('C' )))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
('A' = ('B' = ('C'))) # Pair
\end_layout

\begin_layout Subsubsection
Class Pair
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Standard
Refer to section 
\begin_inset CommandInset ref
LatexCommand eqref
reference "sub:Pair"

\end_inset


\end_layout

\begin_layout Subsection
String
\end_layout

\begin_layout Subsubsection

\emph on
.match
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.match
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
.length
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.length
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This method returns the number of characters in a string.
\end_layout

\begin_layout LyX-Code
> "wqweqweq"(.length)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
8 # Bignum 
\end_layout

\begin_layout Subsubsection

\emph on
.split
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.split
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
.replace
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.replace
\end_layout

\end_inset


\emph default
 <searchstring> <replacement>
\end_layout

\begin_layout Standard
Returns a new string with every occurence of
\emph on
 <searchstring>
\emph default
 replaced with
\emph on
 <replacement>
\end_layout

\begin_layout Subsubsection

\emph on
.+
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.+
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
.toBase64
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.toBase64
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Returns the string converted into a Base64
\begin_inset Index
status open

\begin_layout Plain Layout
Base64
\end_layout

\end_inset

 encoded string.
 The returned string is tagged with the class string
\emph on
Base64EncodedString
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
Base64EncodedString
\end_layout

\end_inset

.
 For example:
\end_layout

\begin_layout LyX-Code
> 'foo:bar'(.toBase64)
\end_layout

\begin_layout LyX-Code
'Zm9vOmJhcg==' # Base64EncodedString String
\end_layout

\begin_layout Subsubsection

\emph on
.fromBase64
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.fromBase64
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Decodes a Base 64 encoded string into the binary original.
 This is also available in the
\emph on
Base64EncodedString
\emph default
 classas the
\emph on
.decode
\emph default
 method.
 Example:
\end_layout

\begin_layout LyX-Code
> 'Zm9vOmJhcg=='(.fromBase64)
\end_layout

\begin_layout LyX-Code
'foo:bar' # String
\end_layout

\begin_layout Subsection
Dictionaries
\end_layout

\begin_layout Standard
Genyris provides 
\begin_inset Quotes eld
\end_inset

dictionary
\begin_inset Index
status open

\begin_layout Plain Layout
dictionary
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 objects which are associative arrays found in some programming languages.
 Each dictionary provides a un-ordered set of dynamic symbols and bindings
 - called 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Index
status open

\begin_layout Plain Layout
properties
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 A dictionary is created with the
\emph on
 dict
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
dict
\end_layout

\end_inset


\emph default
 function call, e.g.:
\end_layout

\begin_layout LyX-Code
define pitt
\end_layout

\begin_layout LyX-Code

\series bold
   dict
\end_layout

\begin_layout LyX-Code

\series bold
      .name  = 'Willam Pitt
\begin_inset Index
status open

\begin_layout Plain Layout

\series bold
Willam Pitt
\end_layout

\end_inset

'
\end_layout

\begin_layout LyX-Code

\series bold
      .title = 'Prime Minister'
\end_layout

\begin_layout LyX-Code

\series bold
      .date-of-birth   = '28 May 1759'
\end_layout

\begin_layout Standard
Here we have created a
\emph on
 dictionary
\emph default
 with three properties.
 The
\emph on
 dict
\emph default
 function takes a variable number of property definitions in Pairs, more
 formally:
\end_layout

\begin_layout LyX-Code
  dict
\end_layout

\begin_layout LyX-Code
     <dynamic symbol1> = <initial value1>
\end_layout

\begin_layout LyX-Code
     <dynamic symbol2> = <initial value2>
\end_layout

\begin_layout LyX-Code
     etc...
\end_layout

\begin_layout Standard
If there are no initial values given , the symbol
\emph on
 nil
\emph default
 is used as the value, as in this example:
\end_layout

\begin_layout LyX-Code
>
\series bold
 dict
\end_layout

\begin_layout LyX-Code

\series bold
   .foo
\end_layout

\begin_layout LyX-Code

\series bold
   .bar
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
dict
\end_layout

\begin_layout LyX-Code
      .bar = nil
\end_layout

\begin_layout LyX-Code
      .foo = nil # Dictionary
\end_layout

\begin_layout Standard
Having properties is all very well, but we need a way to access them.
 As we have seen all objects are callable - including dictionaries.
 So to access the above
\emph on
 dict
\emph default
 object we call it and use the dynamic variables as follows:
\end_layout

\begin_layout LyX-Code
> pitt .name
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 'Willam Pitt' # String
\end_layout

\begin_layout Standard
Here the
\emph on
 .name
\emph default
 dynamic variable is bound to the
\emph on
 .name
\emph default
 property in the dict.
 To set the property value we use the
\emph on
 setq
\emph default
 function:
\end_layout

\begin_layout LyX-Code
pitt
\end_layout

\begin_layout LyX-Code

\series bold
setq
\begin_inset Index
status open

\begin_layout Plain Layout

\series bold
\emph on
setq
\end_layout

\end_inset


\series default
.name 'William Pitt The Younger'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
New properties can be created with
\emph on
 define
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
define
\end_layout

\end_inset


\emph default
 since the object acts as an environment in its own right.
 e.g.:
\end_layout

\begin_layout LyX-Code
pitt
\end_layout

\begin_layout LyX-Code

\series bold
   define
\series default
 .father 'William Pitt the Elder'
\end_layout

\begin_layout Standard
Dictionaries also have a 
\begin_inset Quotes eld
\end_inset

magic
\begin_inset Quotes erd
\end_inset

 variable
\emph on
 .vars
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.vars
\end_layout

\end_inset


\emph default
 which lists all the variables defined in the dictionary.
 This is handy for debugging.
 For example:
\end_layout

\begin_layout LyX-Code
> pitt
\series bold
.vars
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
.date-of-birth .father .name .title .vars # Pair
\end_layout

\begin_layout Subsubsection
Adding Behaviour to Dictionaries
\end_layout

\begin_layout Standard
Since functions in Genyris are bound to variables, and dictionaries have
 variables, behaviour can be added to dictionaries.
 It suffices to define a function with a dynamic name in the scope of a
 dictionary:
\end_layout

\begin_layout LyX-Code
define jeb
\end_layout

\begin_layout LyX-Code

\series bold
   dict
\end_layout

\begin_layout LyX-Code

\series bold
      .firstName = 'Joe'
\end_layout

\begin_layout LyX-Code

\series bold
      .middleName = 'E.'
\end_layout

\begin_layout LyX-Code

\series bold
      .lastName = 'Brown'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
jeb
\end_layout

\begin_layout LyX-Code

\series bold
   def .displayName()
\end_layout

\begin_layout LyX-Code

\series bold
       list .firstName .middleName .lastName
\end_layout

\begin_layout Standard
Once defined, the function is callable in the context of the
\emph on
 jeb
\emph default
 dict:
\end_layout

\begin_layout LyX-Code
> jeb
\series bold
(.displayName)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
'Joe' 'E.' 'Brown' # Pair
\end_layout

\begin_layout Standard
A dict can be used a mechanism for organisation.
 Consider the following fictional example - a set of functions organised
 in a dictionary called
\emph on
 file
\emph default
:
\end_layout

\begin_layout LyX-Code
## File Handling code
\end_layout

\begin_layout LyX-Code
define file
\end_layout

\begin_layout LyX-Code
  dict
\end_layout

\begin_layout LyX-Code
    .name  = 'File Handling Functions'
\end_layout

\begin_layout LyX-Code
    .version = '1.2'
\end_layout

\begin_layout LyX-Code
file
\end_layout

\begin_layout LyX-Code
   def .copy(from to) etc
\end_layout

\begin_layout LyX-Code
   def .delete(filename) etc
\end_layout

\begin_layout LyX-Code
   def .zip(file) etc
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
## Use of the file module
\end_layout

\begin_layout LyX-Code
def archive(filename)
\end_layout

\begin_layout LyX-Code
    file!copy filename '/tmp/foo'
\end_layout

\begin_layout LyX-Code
    file!zip '/tmp/foo'
\end_layout

\begin_layout LyX-Code
    file!delete filename
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Here we define three functions bound to a single dict object.
 The functions can only be called by referencing the
\emph on
 file
\emph default
 object.
\end_layout

\begin_layout Subsection
Classes
\end_layout

\begin_layout Standard
All Genyris objects, be they atomic (like numbers) or composite (like dictionari
es) can belong to one or more classes.
 As such Genyris can be used as an 
\begin_inset Quotes eld
\end_inset

Object-Oriented
\begin_inset Index
status open

\begin_layout Plain Layout
Object-Oriented
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 language.
 The interpreter looks at the classes for functions to execute if the function
 name is dynamic (starts with a .).
 This way you can add behaviour to many objects in a single place.
 Classes are dictionaries with special variables which hold the relationships
 between classes.
 The standard classes all have the following variables:
\end_layout

\begin_layout Description

\emph on
.classes
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.classes
\end_layout

\end_inset

 The list of meta-classes to which the class belongs.
\end_layout

\begin_layout Description

\emph on
.vars
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.vars
\end_layout

\end_inset

 List of property names.
\end_layout

\begin_layout Description

\emph on
.classname
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.classname
\end_layout

\end_inset

 The String name of the class.
\end_layout

\begin_layout Description

\emph on
.superclasses
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.superclasses
\end_layout

\end_inset

 The list of classes from which the class inherits.
\end_layout

\begin_layout Description

\emph on
.subclasses
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.subclasses
\end_layout

\end_inset

 The list of classes which inherit from this class.
\end_layout

\begin_layout Standard
Genyris has a number of built-in classes beginning with
\emph on
 Thing
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Thing
\end_layout

\end_inset


\emph default
, root of the class hierarchy.
 
\end_layout

\begin_layout Standard
To add behaviour to a class, we need to add a dynamic variable bound to
 a closure object - in other words we need to define a method
\begin_inset Index
status open

\begin_layout Plain Layout
method
\end_layout

\end_inset

.
 For example a method to compute the square of a number is added to the
\emph on
 Bignum
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset

 class thus:
\end_layout

\begin_layout LyX-Code
Bignum
\end_layout

\begin_layout LyX-Code
   def .square() (*
\series bold
.self .self
\series default
)
\end_layout

\begin_layout Standard
Notice that the method uses the
\emph on
 .self
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
.self
\end_layout

\end_inset

 variable which will be automatically bound to an object.
 Now all Bignums can compute their own square e.g.:
\end_layout

\begin_layout LyX-Code
> 4234389 (.square)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 17930050203321 # Bignum
\end_layout

\begin_layout Standard
We need to call methods in the correct way to ensure they refer to the right
 object since they are dynamic, not lexical variables.
 So if we tried to say:
\end_layout

\begin_layout LyX-Code
> (4234389.square)
\end_layout

\begin_layout Standard
We would get an error.
 There is a big difference between
\emph on
 4234389 (.square)
\emph default
 and
\emph on
 (4234389.square)
\emph default
.
 In the first case we are creating an environment around the 
\emph on
Bignum 4234389
\emph default
, then we execute the function bound to the dynamic variable
\emph on
 .square
\emph default
 from 
\emph on
Bignum
\emph default
.
 In the second however, we are getting the 
\emph on
Bignum
\emph default
's
\emph on
 .square
\emph default
 function but then applying it in the context of the caller.
 This is most likely not what was intended.
 In general, methods should almost always be called in the first way as
 in:
\end_layout

\begin_layout LyX-Code
<object> (<method> <arg1> <arg2> ...
 <argn>)
\end_layout

\begin_layout Standard
Or if there are multiple method calls to be made:
\end_layout

\begin_layout LyX-Code
<object>
\end_layout

\begin_layout LyX-Code
     <method> <arg1> <arg2> ...
 <argn>
\end_layout

\begin_layout LyX-Code
     <method> <arg1> <arg2> ...
 <argn>
\end_layout

\begin_layout LyX-Code
     etc...
\end_layout

\begin_layout Subsubsection
Defining Your Own Classes
\end_layout

\begin_layout Standard
Classes are relatively complex objects so the language provides a built-in
 macro for creating new classes and binding them.
 The syntax is straight forward - let's define a class for length units:
\end_layout

\begin_layout LyX-Code
>
\series bold
class
\begin_inset Index
status open

\begin_layout Plain Layout

\series bold
class
\end_layout

\end_inset


\series default
 Inches()
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
<class Inches (Thing)> # StandardClass Dictionary
\end_layout

\begin_layout Standard
This simply creates a class which is a subclass of
\emph on
 Thing
\emph default
.
 By convention class names begin with an upper-case character.
 We can use this class to annotate existing objects.
 For example:
\end_layout

\begin_layout LyX-Code
>
\series bold
tag
\series default
 Inches 12
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 12 # Inches Bignum
\end_layout

\begin_layout Standard
The
\emph on
 tag
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
tag
\end_layout

\end_inset


\emph default
 function adds a class to an object's list of classes and returns it.
 Notice the interpreter prints out the list of classes 12 belongs to, now
 including
\emph on
 Inches
\emph default
.
\end_layout

\begin_layout Standard
So far so good, now let's add a method to convert to meters.
 Lets assume an
\emph on
 Inches
\emph default
 object is a kind of
\emph on
 Bignum
\emph default
, and add a method to it:
\end_layout

\begin_layout LyX-Code
class Inches(
\series bold
Bignum
\series default
)
\end_layout

\begin_layout LyX-Code
   def .toMeters()
\end_layout

\begin_layout LyX-Code
      * .self 0.0254
\end_layout

\begin_layout Standard
The second parameter to
\emph on
 class
\emph default
 a list of superclasses, in this example, just
\emph on
 Bignum
\emph default
.
 We can now define a foot and convert it as follows:
\end_layout

\begin_layout LyX-Code
define a-foot
\end_layout

\begin_layout LyX-Code
   tag Inches 12
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> a-foot (
\series bold
.toMeters
\series default
)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 0.3048 # Bignum
\end_layout

\begin_layout Standard
This is fine, but we are still returning a
\emph on
 Bignum
\emph default
.
 Let's refactor to add a
\emph on
 Meters
\emph default
 class and tag the return appropriately:
\end_layout

\begin_layout LyX-Code

\series bold
class Length()
\end_layout

\begin_layout LyX-Code

\series bold
   def .toMeters()
\end_layout

\begin_layout LyX-Code

\series bold
      raise 'Oops - you invoked an abstract class!'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
class Inches(
\series bold
Length
\series default
)
\end_layout

\begin_layout LyX-Code
   def .toMeters()
\end_layout

\begin_layout LyX-Code
      tag Meters (* .self 0.0254)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code

\series bold
class Meters(Length)
\end_layout

\begin_layout LyX-Code

\series bold
   def .toMeters() .self
\end_layout

\begin_layout Standard
Here we have defined an abstract base class and two derived classes which
 both have the .
\emph on
toMeters
\emph default
 method.
 The
\emph on
 raise
\emph default
 function catches invalid use of the
\emph on
 Length
\emph default
 class.
 Lets try the conversion again:
\end_layout

\begin_layout LyX-Code
>
\series bold
(tag Inches 12)
\series default
 (.toMeters)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 0.3048 #
\series bold
Meters
\series default
 Bignum
\end_layout

\begin_layout Standard
Here we are using a sub-expression which returns
\emph on
 12 Inches
\emph default
 and this object is the focus of the call to
\emph on
 .toMeters
\emph default
.
 Note the result is now in
\emph on
 Meters
\emph default
.
 With this new class structure in place we can now add a method to add two
 lengths in any units:
\end_layout

\begin_layout LyX-Code
Length
\end_layout

\begin_layout LyX-Code

\series bold
   def .add(other)
\end_layout

\begin_layout LyX-Code

\series bold
      tag Meters
\end_layout

\begin_layout LyX-Code

\series bold
         + (.toMeters)
\end_layout

\begin_layout LyX-Code

\series bold
            other (.toMeters)
\end_layout

\begin_layout Standard
This method converts both the current object and the argument to
\emph on
 Meters,
\emph default
 performs the addition and returns the result in
\emph on
 Meters
\emph default
.
 Here's how it runs:
\end_layout

\begin_layout LyX-Code
define a-meter
\end_layout

\begin_layout LyX-Code
   tag Meters 1
\end_layout

\begin_layout LyX-Code
define a-foot (tag Inches 12)
\end_layout

\begin_layout LyX-Code
> a-foot (.add a-meter)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 1.3048 #
\series bold
Meters
\series default
 Bignum
\end_layout

\begin_layout Standard
This is useful however in the above example a user of our classes could
 get errors by tagging objects which cannot be added together.
 For example a string will fail:
\end_layout

\begin_layout LyX-Code
(tag
\series bold
Inches '12'
\series default
) (.add (tag Meters 1))          # Error
\end_layout

\begin_layout Standard
To provide protection and we can use type checking features and class validators.
\end_layout

\begin_layout Subsubsection
Type-Checked Function Arguments
\end_layout

\begin_layout Standard
Genyris supports type annotations
\begin_inset Index
status open

\begin_layout Plain Layout
type annotations
\end_layout

\end_inset

 found in most statically typed languages.
 These type checks are purely optional.
 When a function is defined, the arguments and return value may be annotated
 with a class.
 The actual arguments are checked with a validator (if present).
 Here's an example of a sensitive function protected by type checks:
\end_layout

\begin_layout LyX-Code
def safe-call ((a =
\begin_inset Index
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 Bignum) (b = Bignum) = Bignum)
\end_layout

\begin_layout LyX-Code
    fragile-function a b
\end_layout

\begin_layout Standard
This function only allows Bignums to be passed in or returned.
 The last element of the arguments list specifies the return type.
 If a type check fails an exception is raised.
\end_layout

\begin_layout Subsubsection
In-Line Type Checks
\end_layout

\begin_layout Standard
Genyris provides another mechanism for checking type constraints.
 The
\emph on
 is?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
is?
\end_layout

\end_inset


\emph default
 function will check if the result of the expression is
\emph on
 .valid
\emph default
?
\emph on

\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.valid?
\end_layout

\end_inset


\emph default
, or if it is an instance of the class.
 For example this function will always raise an error because
\emph on
 3
\emph default
 is not a subclass of
\emph on
 String
\emph default
:
\end_layout

\begin_layout LyX-Code
def fails()
\end_layout

\begin_layout LyX-Code
    define x 3
\end_layout

\begin_layout LyX-Code
    is? x String
\end_layout

\begin_layout Standard
If a class validator is provided, this will be used otherwise a simple 
\begin_inset Quotes eld
\end_inset

nominative
\begin_inset Quotes erd
\end_inset

 type check of class membership based on the object's tagged classes is
 used.
 The
\emph on
 .valid?
\emph default
 method is a stronger check, however nominative checking is sometimes preferred
\begin_inset Foot
status open

\begin_layout Plain Layout
Genyris supports both
\begin_inset Quotes eld
\end_inset

nominative
\begin_inset Quotes erd
\end_inset

 and
\begin_inset Quotes eld
\end_inset

structural
\begin_inset Quotes erd
\end_inset

 subtyping
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Inheritance and Class Properties
\end_layout

\begin_layout Standard
The inheritance
\begin_inset Index
status open

\begin_layout Plain Layout
inheritance
\end_layout

\end_inset

 mechanism in Genyris works by searching on object's classes list for classes
 which have the dynamic symbol required, it also recursively searches the
 superclasses of all the classes it finds in the classes list.
 The classes are ordered with those classes deepest in the hierarchy first.
\begin_inset Foot
status open

\begin_layout Plain Layout
This order is listed when the classes are printed by the interpreter.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inheritance of properties is the same regardless of the type of property
 (function or data).
 Hence an object can access information stored in its classes and superclasses.
 Here's an example where a base class supplies a boolean value to an object:
\end_layout

\begin_layout LyX-Code
class Orange()
\end_layout

\begin_layout LyX-Code
   define .pips ^true
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> (tag Orange 'my lunch').pips
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ true # Symbol
\end_layout

\begin_layout Subsubsection
Class Validators
\end_layout

\begin_layout Standard
To help define membership of a class, the class can provide a
\emph on
 .valid?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.valid?
\end_layout

\end_inset


\emph default
 predicate method.
 This can assess an object and return
\emph on
 true
\emph default
 if it is a valid member of the class.
 The
\emph on
 tag
\emph default
 function calls
\emph on
 .valid?
\emph default
 if provided and fails when
\emph on
 .valid?
\emph default
 returns
\emph on
 nil
\emph default
.
 We can add a validator to our example base class:
\end_layout

\begin_layout LyX-Code
Length
\end_layout

\begin_layout LyX-Code

\series bold
   def .valid?(obj)
\end_layout

\begin_layout LyX-Code

\series bold
      is-instance? obj Bignum
\end_layout

\begin_layout Standard
The
\emph on
 is-instance?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
is-instance?
\end_layout

\end_inset


\emph default
 function only returns true if the object is an instance of
\emph on
 Bignum
\emph default
 or its subclasses.
 This prevents anything except numbers being tagged.
\end_layout

\begin_layout Subsubsection
Traditional Constructors and Factories
\end_layout

\begin_layout Standard
While the philosophy of Genyris is to classify objects after construction,
 it does not inhibit using traditional constructors
\begin_inset Index
status open

\begin_layout Plain Layout
constructors
\end_layout

\end_inset

 in classes.
 'Factory' functions for object construction are preferred even in traditional
 languages.
 Factory functions are simply functions which construct the appropriate
 kind of object based on the inputs given.
 A factory/constructor can be as simple as this:
\end_layout

\begin_layout LyX-Code
class Person ()
\end_layout

\begin_layout LyX-Code
   def .new (name date-of-birth)
\end_layout

\begin_layout LyX-Code
      dict
\end_layout

\begin_layout LyX-Code
         .name = name
\end_layout

\begin_layout LyX-Code
         .dob = date-of-birth
\end_layout

\begin_layout LyX-Code
         .classes = (list Person)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
Person!new 'Jo' 23
\end_layout

\begin_layout Standard
A more general approach is to provide a 
\begin_inset Quotes eld
\end_inset


\emph on
new
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
new
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 function which calls a class-specific 
\begin_inset Quotes eld
\end_inset


\emph on
init
\emph default

\begin_inset Quotes erd
\end_inset

 function.
 For example here is a class with an
\emph on
 .init
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.init
\end_layout

\end_inset


\emph default
 member which creates properties in a dict created by
\emph on
 .new
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.new
\end_layout

\end_inset


\emph default
:
\end_layout

\begin_layout LyX-Code
class PersonTraditional (Object)
\end_layout

\begin_layout LyX-Code
   def .init((name = String) (age = Bignum))
\end_layout

\begin_layout LyX-Code
      define .name name
\end_layout

\begin_layout LyX-Code
      define .age age
\end_layout

\begin_layout Standard

\emph on
Object
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Object
\end_layout

\end_inset


\emph default
s are created by calling
\emph on
 .new
\emph default
:
\end_layout

\begin_layout LyX-Code
> PersonTraditional (.new 'Abe' 99)
\end_layout

\begin_layout LyX-Code
dict
\end_layout

\begin_layout LyX-Code
      .age = 99
\end_layout

\begin_layout LyX-Code
      .name = 'Abe' # PersonTraditional Dictionary
\end_layout

\begin_layout Standard
Here is a simple implementation of
\emph on
 .new
\emph default
 in a base class:
\end_layout

\begin_layout LyX-Code
class Object (Dictionary)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  def .new(&rest args)
\end_layout

\begin_layout LyX-Code
      (tag .self (dict))
\end_layout

\begin_layout LyX-Code
         apply .init args
\end_layout

\begin_layout LyX-Code
         .self
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
   # NOOP .init method
\end_layout

\begin_layout LyX-Code
   def .init(&rest args)
\end_layout

\begin_layout LyX-Code
      .self
\end_layout

\begin_layout Standard
This
\emph on
 .new
\emph default
 collects all the input arguments via the
\emph on
 &rest
\emph default
 keyword, it creates an empty
\emph on
 dict
\emph default
, tags it with the derived class and passes the collected arguments to the
 class's
\emph on
 .init
\emph default
 function.
 The default
\emph on
 .init
\emph default
 function returns the new object un-modified.
\end_layout

\begin_layout Subsubsection
Functions on classes
\end_layout

\begin_layout Paragraph

\emph on
class
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
class
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
tag
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
tag
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
remove-tag
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
remove-tag
\end_layout

\end_inset


\emph default
 <class> <object>
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
is-instance?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
is-instance?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Automating Classification
\end_layout

\begin_layout Standard
This language embodies the opinion that objects are created first, then
 they are classified - rather than the classification
\begin_inset Index
status open

\begin_layout Plain Layout
classification
\end_layout

\end_inset

 being determined during object construction.
 Let's explore how the
\emph on
 .valid?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.valid?
\end_layout

\end_inset


\emph default
 predicates can be used to automate classification.
\end_layout

\begin_layout Standard
Validator functions can be developed to any complexity required.
 For example validators can inspect the 
\bar under
values
\bar default
 of properties and objects rather than just their type.
 Here's an example which is
\emph on
 true
\emph default
 for even numbers:
\end_layout

\begin_layout LyX-Code
class EvenNumber()
\end_layout

\begin_layout LyX-Code
   def .valid?(x)
\end_layout

\begin_layout LyX-Code
      equal? (% x 2) 0
\end_layout

\begin_layout Standard
Validators provide a way to automatically categorize unknown objects - an
 important tool for input validation.
\end_layout

\begin_layout Standard
The Genyris distribution includes file "
\emph on
examples/classify.g
\emph default
" which shows this pattern.
 It defines a simple
\emph on
 classify
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
classify
\end_layout

\end_inset


\emph default
 function which recursively walks the class hierarchy testing an object's
 compliance with validators.
 There is an example of classification of people into classes based on age
 and possessions.
 We load the source files
\begin_inset Foot
status open

\begin_layout Plain Layout
The
\emph on
 load
\emph default
 function reads an executes the source file from the Java classpath.
 Genyris initialization code source files are stored within the Java
\begin_inset Quotes eld
\end_inset

jar
\begin_inset Quotes erd
\end_inset

 file.
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
include 'examples/people.g'
\end_layout

\begin_layout LyX-Code
@prefix foaf 'http://xmlns.com/foaf/0.1/'
\end_layout

\begin_layout Standard
This creates an un-classified object, assigns it to a variable
\emph on
 vyvyan
\emph default
, and calls
\emph on
 classify
\emph default
:
\end_layout

\begin_layout LyX-Code
define vyvyan
\end_layout

\begin_layout LyX-Code
  dict
\end_layout

\begin_layout LyX-Code
     .foaf:name = 'Vyvyan'
\end_layout

\begin_layout LyX-Code
     .foaf:age = 49
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
classify foaf:Person vyvyan
\end_layout

\begin_layout Standard
We now display the object
\end_layout

\begin_layout LyX-Code
> vyvyan
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(dict (.|http://xmlns.com/foaf/0.1/age| = 49)
\end_layout

\begin_layout LyX-Code
      (.|http://xmlns.com/foaf/0.1/name| = "Vyvyan"))
\begin_inset Newline newline
\end_inset

# Boomer Dictionary 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
The result shows the classifier has recognised
\emph on
 vyvyan
\emph default
 as a
\emph on
 Boomer
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Boomer
\end_layout

\end_inset


\emph default
.
 Here are the classes that make this happen:
\end_layout

\begin_layout LyX-Code
class foaf:Person ()
\end_layout

\begin_layout LyX-Code
   def .valid? (obj)
\end_layout

\begin_layout LyX-Code
      obj
\end_layout

\begin_layout LyX-Code
         bound? .foaf:age
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
class Boomer (foaf:Person)
\end_layout

\begin_layout LyX-Code
   def .valid? (obj)
\end_layout

\begin_layout LyX-Code
      obj
\end_layout

\begin_layout LyX-Code
         between 45 .foaf:age 60
\end_layout

\begin_layout Standard
To be a valid
\emph on
 Person
\emph default
 
\emph on
vyvyan
\emph default
 must have an the
\emph on
 .foaf:age
\emph default
 property, and to be a
\emph on
 Boomer
\emph default
 its 
\emph on
foaf:age
\emph default
 must be between 45 and 60.
 The
\emph on
 classify
\emph default
 function only calls the derived class's validator if object is in the base
 class.
 It tagged
\emph on
 vyvyan
\emph default
 with the
\emph on
 Boomer
\emph default
 class.
\end_layout

\begin_layout Standard
This technique can be used to categorise a program's inputs or validate
 output data, and even re-validate previously classified objects.
\end_layout

\begin_layout Subsubsection
Duck Typing
\end_layout

\begin_layout Standard
'Duck' typing in a language is jargon for 'structural' subtyping -
\emph on
 If it looks like a duck and quacks like a duck - then it is a duck
\emph default
.
 Duck typing
\begin_inset Index
status open

\begin_layout Plain Layout
Duck typing
\end_layout

\end_inset

 relies on programmers to ensure that objects passed around actually do
 have the properties and methods expected by the downstream code.
 If there is a mis-match then eventually an error will result.
 For example if we could define a
\emph on
 .copy
\emph default
 function which expects some kind of stream object with
\emph on
 .next
\emph default
 and
\emph on
 .last?
\emph default
 methods.
 There is no need to perform type-checking in the interface since if the
 methods exits all will be well.
 Duck typing is adequate for many programming tasks, however developers
 like to formalize the interfaces with type declarations.
\end_layout

\begin_layout Standard
In Genyris an Interface could be defined by either providing an appropriate
 validator or by simply tagging objects with their supported interface classes.
 For example here is a class validator for the above scenario:
\end_layout

\begin_layout LyX-Code
class Stream-Interface()
\end_layout

\begin_layout LyX-Code
   def .valid?(object)
\end_layout

\begin_layout LyX-Code
      object
\end_layout

\begin_layout LyX-Code
         and
\end_layout

\begin_layout LyX-Code
            bound? .next
\end_layout

\begin_layout LyX-Code
            is-instance? .next Closure
\end_layout

\begin_layout LyX-Code
            bound? .last
\end_layout

\begin_layout LyX-Code
            is-instance? .last Closure
\end_layout

\begin_layout Standard
The validator here checks whether the object has
\emph on
 .next
\emph default
 and
\emph on
 .last
\emph default
 properties, and whether they are procedure objects.
\end_layout

\begin_layout Subsection
Triples
\end_layout

\begin_layout Subsubsection
Introduction
\end_layout

\begin_layout Standard
RDF
\begin_inset Index
status open

\begin_layout Plain Layout
RDF
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Resouce Description Framework
\end_layout

\end_inset

 concepts such as triples
\begin_inset Index
status open

\begin_layout Plain Layout
triple
\end_layout

\end_inset

 and graphs
\begin_inset Index
status open

\begin_layout Plain Layout
graph
\end_layout

\end_inset

 are available in Genyris as part of the language.
 Although these were made popular by the Semantic Web these Description
 Logic ideas can be used in general programming.
 The Genyris implementation removes some of the constraints of RDF and allows
 these ideas to applied at the program object level.
 The goal is for all developers to be beneficiaries of these elegent data
 structures and algorithms, not just those concerned with Semantic Web problems.
\end_layout

\begin_layout Standard
Triples and graphs which are derived from Description Logic also form the
 foundation for a future Genyris
\emph on
 type system
\emph default
.
 The type system will allow data, classes and functions to be 'marked-up'
 with meta-data describing their allowed properties and behaviours.
\end_layout

\begin_layout Standard
Description Logic techniques allow great flexibilty and power in the addition
 of meta-data and inference.
 We hope in time Genyris developers will have access to higher-order tools
 which are available for RDF and OWL within the context of their Genyris
 application programming.
\end_layout

\begin_layout Standard
Genyris includes triples as a first-class system object.
 Triples are described in the W3C RDF Primer document
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.w3.org/TR/rdf-primer/
\end_layout

\end_inset

.
 A triple
\begin_inset Index
status open

\begin_layout Plain Layout
triple
\end_layout

\end_inset

 consists of three atoms, a
\emph on
 Subject
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Subject
\end_layout

\end_inset


\emph default
,
\emph on
 Predicate
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Predicate
\end_layout

\end_inset


\emph default
 and
\emph on
 Object
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Object
\end_layout

\end_inset


\emph default
.
 Each triple is a simple descriptive statement about the relationships between
 objects or their properties.
 For example the triple:
\end_layout

\begin_layout LyX-Code
UnixBox1 hasUser root
\end_layout

\begin_layout Standard
Says that the machine UnixBox1 has a user account 'root'.
\end_layout

\begin_layout Standard
In Genyris the
\emph on
 Subject
\emph default
 of a triple may be any language object, including atoms and 'literals'
 in RDF terms.
 This allows statements to be made about any object in the system.
 Another way of viewing this is that any object in the system may have arbitrary
 properties, stored in triples.
\end_layout

\begin_layout Standard
The
\emph on
 Predicate
\emph default
 of a triple however, must be a symbol.
 This ensures that the statement is at least, readable.
\end_layout

\begin_layout Standard
Any language item may be the
\emph on
 Object
\emph default
 of a triple.
 This allows relationships between any two language items to be recorded.
\end_layout

\begin_layout Standard
Triples alone are not particularly useful without a way of comparing them
 and managing them.

\emph on
 Graphs
\begin_inset Index
status open

\begin_layout Plain Layout
graph
\end_layout

\end_inset


\emph default
 are in-memory sets of triples with functions for searching for, adding
 and removing triples.
 Because Genyris triples may have any object as their subjects, Graphs are
 used where other languages may rely on hash-tables.
 Graphs in their turn can be used as sets, with comparison, intersection
 and union functions.
\end_layout

\begin_layout Subsubsection
Creating triples with
\emph on
 triple
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
triple
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Triple objects are created by the
\emph on
 triple
\emph default
 function which takes three arguments, the
\emph on
 subject, predicate
\emph default
 and
\emph on
 object.
\emph default
The
\emph on
 predicate
\emph default
 must be a Symbol.

\emph on
 
\emph default
Example
\emph on
s
\emph default
:
\end_layout

\begin_layout LyX-Code
> triple ^Lewis ^hasMother ^Mae
\end_layout

\begin_layout LyX-Code
(triple Lewis hasMother Mae) # Triple
\end_layout

\begin_layout LyX-Code
> triple 23 ^hasUnits ^Inches
\end_layout

\begin_layout LyX-Code
(triple 23 hasUnits Inches) # Triple
\end_layout

\begin_layout Subsubsection
Accessing parts of a triple with
\emph on
 .subject
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
.subject
\end_layout

\end_inset

,
\emph on
 .predicate
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
.predicate
\end_layout

\end_inset

 and
\emph on
 .object
\begin_inset Index
status open

\begin_layout Plain Layout
.object
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The components of the triples can be accessed with the above dynamic symbols.
 For example:
\end_layout

\begin_layout LyX-Code
> var l
\end_layout

\begin_layout LyX-Code
   triple ^Lewis ^hasMother ^Mae
\end_layout

\begin_layout LyX-Code
(triple Lewis hasMother Mae) # Triple
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> list l!object l!subject l!predicate
\end_layout

\begin_layout LyX-Code
(Mae Lewis hasMother) # Pair
\end_layout

\begin_layout Subsubsection
Triple Equality
\end_layout

\begin_layout Standard
Two triples are considered
\emph on
 equal?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
equal?
\end_layout

\end_inset


\emph default
 if the subjects and predicates are
\emph on
 eq?
\emph default
and the objects are
\emph on
 equal?.
\emph default
The
\emph on
 equal?
\emph default
 test for the
\emph on
 object
\emph default
 means that strings, integers and lists which look the same will be treated
 as equal.
 Refer also to the definitions of
\emph on
 eq?
\emph default
 and
\emph on
 equal?
\emph default
.
 This style is designed to allow simple literals to be used as objects such
 as
\emph on
 12.3
\emph default
 and
\emph on
 
\begin_inset Quotes eld
\end_inset

Joe
\begin_inset Quotes erd
\end_inset


\emph default
.
 If networks of triples are required in an application, then the objects
 are also subjects.
 In this case Dictionaries or Symbols are recommended since their equality
 is specific.
\end_layout

\begin_layout Standard
For example:
\end_layout

\begin_layout LyX-Code
> equal? (triple ^S ^P 12.3) (triple ^S ^P 12.3)
\end_layout

\begin_layout LyX-Code
true # SimpleSymbol
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> equal? (triple 123 ^p "yes") (triple 123 ^p "yes")
\end_layout

\begin_layout LyX-Code
nil # SimpleSymbol
\end_layout

\begin_layout Subsection
Graphs
\end_layout

\begin_layout Standard
Genyris provides a special container class for triples, the 'graph
\begin_inset Index
status open

\begin_layout Plain Layout
graph
\end_layout

\end_inset

'.
 Graphs are really just a set of triples, since all triples within the store
 are unequal.
 Graphs are not persisted (saved on disk) they are in-memory objects.
 Graphs are used as lookup tables (instead of a hashtable) and they are
 used for more complex comparisons between sets of triples.
 The speed of the current implementation is inversely proportional to the
 number of triples in the store.
\end_layout

\begin_layout Subsubsection
Creating Graphs with
\emph on
 graph
\end_layout

\begin_layout Standard
The
\emph on
 graph
\begin_inset Index
status open

\begin_layout Plain Layout
graph
\end_layout

\end_inset


\emph default
 function constructs a graph object.
 It accepts an optional list of 3-lists which are converted to triples.
 Example:
\end_layout

\begin_layout LyX-Code
> graph
\end_layout

\begin_layout LyX-Code
   ^(joe age three)
\end_layout

\begin_layout LyX-Code
   ^(joe age ten)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(graph) # Graph
\end_layout

\begin_layout Subsubsection
Graph equality
\end_layout

\begin_layout Standard
Two graphs are
\emph on
 equal?
\emph default
 if their constituent triples have an equal triple in the other graph and
 vice versa.
\end_layout

\begin_layout Subsubsection
Adding Triples with
\emph on
 .add
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.add
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The
\emph on
 .add
\emph default
 method adds a triple to a graph.
 If the triple is already present no error is thrown.
 The graph object is returned.
 Syntax is:
\end_layout

\begin_layout LyX-Code
.add <triple>
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
ts(.add (triple ^s ^p ^o))
\end_layout

\begin_layout Subsubsection
Removing Triples with
\emph on
 .remove
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.remove
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The
\emph on
 .remove
\emph default
 method removes a single triple from a graph.
 If the triple is already absent no error is thrown.
 The graph object is returned.
 Syntax is:
\end_layout

\begin_layout LyX-Code
.remove <triple>
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
ts(.remove (triple ^s ^p ^o))
\end_layout

\begin_layout Subsubsection
Querying Triples with
\emph on
 .select
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.select
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The
\emph on
 .select
\emph default
 method provides a way of iterating over the set of triples in the graph
 and returning a new graph with triples of interest.
 Syntax:
\end_layout

\begin_layout LyX-Code
.select <subject> <predicate> <object> [<procedure>]
\end_layout

\begin_layout Standard
The function iterates through every triple in the graph, if the
\emph on
 <subject>
\emph default
,
\emph on
 <predicate>
\emph default
 and
\emph on
 <object>
\emph default
 parameters match those of the triple it is added to the result set.
 Nil parameters are ignored
\begin_inset Foot
status open

\begin_layout Plain Layout
This is likely to change since
\emph on
 nil
\emph default
 is not matchable.
\end_layout

\end_inset

.
 Matching is performed as for triple equality rules.
 Thus
\emph on
 (.select nil nil nil)
\emph default
 matches all triples.
 Matching rules:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Predicate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
subject
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
eq?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
predicate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
eq?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
property
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal?
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
If the last parameter is present it must be a procedure which takes three
 parameters of the form:
\end_layout

\begin_layout LyX-Code
function(<subject> <predicate> <object>)
\end_layout

\begin_layout Standard
If the triple is matched, then this function is called with the triple's
 subject, predicate and object as actual parameters.
 If the function returns a non
\emph on
-nil
\emph default
 value then the triple is added to the result set.
 The matching logic is equivalent to:
\end_layout

\begin_layout LyX-Code
and
\end_layout

\begin_layout LyX-Code
   eq? <subject> .subject
\end_layout

\begin_layout LyX-Code
   eq? <predicate> .predicate
\end_layout

\begin_layout LyX-Code
   equal? <object> .object
\end_layout

\begin_layout LyX-Code
   <procedure> .subject .predicate .object
\end_layout

\begin_layout Standard
Here is a simple example: of select in use:
\end_layout

\begin_layout LyX-Code
var ts
\end_layout

\begin_layout LyX-Code
   graph
\end_layout

\begin_layout LyX-Code
      ~ ^(joe age three)
\end_layout

\begin_layout LyX-Code
      ~ ^(joe age ten)
\end_layout

\begin_layout LyX-Code
      ~ ^("John" age 22)
\end_layout

\begin_layout LyX-Code
      ~ ^("John" height 223)
\end_layout

\begin_layout LyX-Code
var result
\end_layout

\begin_layout LyX-Code
   ts
\end_layout

\begin_layout LyX-Code
     .select ^joe nil nil
\end_layout

\begin_layout LyX-Code
assert
\end_layout

\begin_layout LyX-Code
   equal?
\end_layout

\begin_layout LyX-Code
      result
\end_layout

\begin_layout LyX-Code
      graph ^(joe age three) ^(joe age ten)
\end_layout

\begin_layout Subsubsection
Retrieving unique values with
\emph on
 .get
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.get
\end_layout

\end_inset

 subject predicate
\end_layout

\begin_layout Standard
Often graphs will contain unique triples
\begin_inset Index
status open

\begin_layout Plain Layout
unique triples
\end_layout

\end_inset

, ie there is only one triple with the same
\emph on
 subject
\emph default
 and predicate.
 The
\emph on
 .get
\emph default
 method retrieves the
\emph on
 object
\emph default
 of this triple.
 If there is more than one matching triple, or none, an error is raised.
\end_layout

\begin_layout Standard
Syntax:
\end_layout

\begin_layout LyX-Code
<graph> (.get subject predicate)
\end_layout

\begin_layout Subsubsection
Retrieving multiple values with
\emph on
 .get-list
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.get-list
\end_layout

\end_inset

 subject predicate
\end_layout

\begin_layout Standard
The
\emph on
 .get-list
\emph default
 method retrieves a list containing all the
\emph on
 objects
\emph default
 of the triples which have the
\emph on
 subject
\emph default
 and
\emph on
 predicate
\emph default
 specified.
 If there is no matching triple
\emph on
 NIL
\emph default
 is returned.
 Syntax:
\end_layout

\begin_layout LyX-Code
<graph> (.get-list subject predicate)
\end_layout

\begin_layout Subsubsection
Updating with
\emph on
 .put
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.put
\end_layout

\end_inset

 subject predicate object
\end_layout

\begin_layout Standard
The
\emph on
 put
\emph default
 method removes all triples from the graph with the matching
\emph on
 subject
\emph default
 and
\emph on
 predicate
\emph default
, then adds a single triple with the
\emph on
 subject predicate object
\emph default
 specified
\emph on
.
\emph default
If there are no matching triples no error is raised, the triple is simply
 added.
 This operation is intended to support the pattern of a unique triples
\begin_inset Index
status open

\begin_layout Plain Layout
unique triples
\end_layout

\end_inset

, where it serves as an update operation.
\end_layout

\begin_layout Subsubsection
Fetching all the triples with
\emph on
 .asTriples
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.asTriples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The
\emph on
 .asTriples
\emph default
 method returns a list containing all the triples in the graph.
\end_layout

\begin_layout Subsubsection
Triplification with
\emph on
 .asGraph
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.asGraph
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
This method is not fully implemented for all types yet.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All objects in Genyris can be converted into a series of triples depending
 on their type.
 Typically this results in a type triple for each of the object's classes,
 and properties as individual triples.
 Examples:
\end_layout

\begin_layout LyX-Code
>
\emph on
class Inches
\end_layout

\begin_layout LyX-Code
<class Inches (Thing)> # StandardClass
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
>
\emph on
var foot (tag Inches 12)
\end_layout

\begin_layout LyX-Code
12 # Inches Bignum
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
>
\emph on
(foot(.asGraph))(.asTriples))
\end_layout

\begin_layout LyX-Code
((triple 12 type <class Inches (Thing)>)
\end_layout

\begin_layout LyX-Code
 (triple 12 type <class Bignum (Builtin)>)) # Pair
\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout LyX-Code
>
\emph on
(^(1 2)(.asGraph))(.asTriples)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
((triple (1 2) type <class Pair (Builtin)>)) # Pair
\end_layout

\begin_layout Subsubsection
Meta-Data for Triples
\end_layout

\begin_layout Standard
Triples can belong to multiple classes just like any other Genyris object.
 This allows them to be annotated and have classes and methods.
 For example here we tag a triple as being factual:
\end_layout

\begin_layout LyX-Code
>
\emph on
class Fact
\end_layout

\begin_layout LyX-Code
<class Fact (Thing)> # StandardClass
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
>
\emph on
var kr (triple ^KevinRudd ^role ^PrimeMinister)
\end_layout

\begin_layout LyX-Code
(triple KevinRudd
\begin_inset Index
status open

\begin_layout Plain Layout
KevinRudd
\end_layout

\end_inset

 role PrimeMinister) # Triple
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
>
\emph on
tag Fact kr
\end_layout

\begin_layout LyX-Code
(triple KevinRudd role PrimeMinister) # Fact Triple
\end_layout

\begin_layout Standard
Triples can also be the subject of other triples which means complex meta-descri
ptions are possible without resorting to reification.
 Here is the example above expressed with another triple.
\end_layout

\begin_layout LyX-Code
> var meta-kr (triple kr ^Belief ^Fact)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(triple (triple KevinRudd role PrimeMinister) Belief Fact) # Triple
\end_layout

\begin_layout Standard
Triples and graphs allow the programmer to store information about objects
 which may not have a means of adding properties of their own beyond their
 class membership list.
\end_layout

\begin_layout Section
IO - Input and Output
\end_layout

\begin_layout Subsection
Output
\end_layout

\begin_layout Subparagraph
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
print
\end_layout

\end_inset


\emph on
print
\emph default
<arg1>...<argn>
\end_layout

\begin_layout Standard
Outputs its arguments to the current standard output stream as if typed
 in by a user in indented format.
 - strings are quoted, escape characters are output.
 Arguments on the output are seperated by a newline.
 Example:
\end_layout

\begin_layout LyX-Code
print ^(1 'w
\backslash
n' (x y))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
1 'w
\backslash
n'
\end_layout

\begin_layout LyX-Code
   x y
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subparagraph

\emph on
write
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
write
\end_layout

\end_inset


\emph default
<arg1>...<argn>
\end_layout

\begin_layout Standard
Outputs its arguments to the current standard output stream with parenthesis
 syntax.
 - strings are quoted, escape characters are output.
 Arguments are output sequentially without space padding.
 Example:
\end_layout

\begin_layout LyX-Code
write ^(1 2 (e) 'w')
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(1 2 (e) 'w')
\end_layout

\begin_layout Subparagraph
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
display
\end_layout

\end_inset


\emph on
display
\emph default
<arg1>...<argn>
\end_layout

\begin_layout Standard
Outputs its arguments to the current standard output stream without syntax.
 - strings are not quoted, escape characters are not output.
 Arguments are output sequentially without padding.
 Example:
\end_layout

\begin_layout LyX-Code
display ^(1 'w
\backslash
n' (x y))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(1 w
\end_layout

\begin_layout LyX-Code
 (x y))
\end_layout

\begin_layout Subsubsection

\emph on
u:format
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
format
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Outputs the args as dictated by the format-string.
 
\end_layout

\begin_layout Paragraph
Syntax:
\end_layout

\begin_layout LyX-Code
@prefix u 'http://www.genyris.org/lang/utilities#'
\end_layout

\begin_layout LyX-Code
u:format <format string> args ...
\end_layout

\begin_layout Standard
The same as 
\end_layout

\begin_layout LyX-Code
stdout(.format <format string> args ...) 
\end_layout

\begin_layout Subsubsection
Class 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Writer
\end_layout

\end_inset

Writer
\end_layout

\begin_layout Standard
A class which accepts a stream of characters.
\end_layout

\begin_layout Paragraph
Methods
\end_layout

\begin_layout Description

\emph on
.close
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.close
\end_layout

\end_inset


\emph default
 Closes the current output stream.
\end_layout

\begin_layout Description

\emph on
.flush
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.flush
\end_layout

\end_inset


\emph default
 Forces all buffered output to be written to the device.
\end_layout

\begin_layout Description

\emph on
.format
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.format
\end_layout

\end_inset


\emph default
 <format-string><arg1>...<argn> Outputs the args as dictated by the format-string.
 The format string is a normal string with the special format sequences.
 Each format sequence must be matched by a corresponding argument to format,
 used in order.
\end_layout

\begin_deeper
\begin_layout Description
%a Outputs the argument without syntax - strings are unquoted, escape characters
 are not output
\end_layout

\begin_layout Description
%s Outputs the argument using if entered by a user - strings are quoted,
 escape characters are not output
\end_layout

\begin_layout Description
%x Outputs the argument as XML using an XmlWriter
\end_layout

\begin_layout Description
%u Outputs the argument as a URL encoded string suitable for HTTP URLS
\end_layout

\begin_layout Description
%n Outputs a linefeed
\end_layout

\begin_layout Description
%% Outputs a % character
\end_layout

\begin_layout Standard
Example:
\end_layout

\end_deeper
\begin_layout LyX-Code
stdout(.format '%s %a %x %n' 'Hello' 'World' ^(img ((width= 23))))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
'Hello' World <img width="23"/>
\end_layout

\begin_layout Paragraph
Global Variables
\end_layout

\begin_layout Description

\emph on
stdin
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
stdout
\end_layout

\end_inset


\emph default
 A global variable which holds a
\emph on
 Reader
\emph default
 pointing the current Standard input device, typically the console.
\end_layout

\begin_layout Description

\emph on
stdout
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
stdout
\end_layout

\end_inset


\emph default
 A global variable which holds a
\emph on
 Writer
\emph default
 pointing the current Standard output device, typically the console.
\end_layout

\begin_layout Description

\emph on
stderr
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
stdout
\end_layout

\end_inset


\emph default
 A global variable which holds a
\emph on
 Writer
\emph default
 pointing the current Standard Error device, typically the console.
\end_layout

\begin_layout Subsection
Input
\end_layout

\begin_layout Subsubsection

\emph on
EOF
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
EOF
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Used to denote the End Of File, this symbol causes a parser to exit if seen.
\end_layout

\begin_layout Subparagraph
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
read
\end_layout

\end_inset


\emph on
read
\end_layout

\begin_layout Standard
Reads an expression from the standard input.
\end_layout

\begin_layout Subsubsection

\emph on
stdin
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
stdin
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
Class Reader
\end_layout

\begin_layout Paragraph
Globals
\end_layout

\begin_layout Description
\begin_inset Index
status collapsed

\begin_layout Plain Layout
stdin
\end_layout

\end_inset

stdin A global variable which holds a
\emph on
Reader
\emph default
 pointing the current Standard Input device, typically the console.
\end_layout

\begin_layout Paragraph
Methods
\end_layout

\begin_layout Paragraph

\emph on
.new
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.new
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
.close
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.close
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
.read
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.read
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
.hasData
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.hasData
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
.copy
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.copy
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The .copy method copies all the data from the stream to a Writer stream object
 which is passed as its only parameter.
 Fr example, the following copies all console input back to the screen until
 an EOF is found:
\end_layout

\begin_layout LyX-Code
stdin (.copy stdout)
\end_layout

\begin_layout Subsubsection
ParenParser
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
.new
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.new
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
.close
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.close
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
.read
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.read
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
.hasData
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.hasData
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
Parser
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Parser
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
StringFormatStream
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
StringFormatStream
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
.new
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.new
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection

\emph on
File
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
File
\end_layout

\end_inset


\emph default
s
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
.new
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.new
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
.open
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.open
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
.format
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.format
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
.close
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.close
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
.hasData
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.hasData
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
.read
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.read
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
.static-open
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.static-open
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection
Pipes
\begin_inset Index
status open

\begin_layout Plain Layout
Pipes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Genyris provides named pipes within the JVM which allows tasks to communicate
 with each other by sending character streams.
 Each pipe has a unique name and tasks can access the pipes by their names.
\end_layout

\begin_layout Subsubsection
.list
\begin_inset Index
status open

\begin_layout Plain Layout
.list
\end_layout

\end_inset

 - obtain a list of the current pipe names
\end_layout

\begin_layout Standard
Syntax:
\end_layout

\begin_layout LyX-Code
Pipe!list
\end_layout

\begin_layout Standard
This function returns a list of the string names of the pipes currently
 existing.
\end_layout

\begin_layout Subsubsection
\begin_inset Index
status open

\begin_layout Plain Layout
.open
\end_layout

\end_inset

.open - Create or find a named pipe
\end_layout

\begin_layout Standard
Syntax: 
\end_layout

\begin_layout LyX-Code
Pipe!open <name string>
\end_layout

\begin_layout Standard
If the pipe already exists this function returns the 
\emph on
Pipe
\emph default
 object for the pipe.
 The same object is shared between tasks in the JVM and may be used for
 synchronization.
 If there is no pipe of that name, a new one is created and returned to
 the caller.
\end_layout

\begin_layout Subsubsection
.output
\begin_inset Index
status open

\begin_layout Plain Layout
.output
\end_layout

\end_inset

 - Obtain a Writer stream for writing to a Pipe
\end_layout

\begin_layout Standard
Syntax:
\end_layout

\begin_layout LyX-Code
<pipe object>(.output)
\end_layout

\begin_layout Standard
This method returns a 
\emph on
Writer
\emph default
 object which can the be used to send characters to the pipe.
\end_layout

\begin_layout Subsubsection
.input
\begin_inset Index
status open

\begin_layout Plain Layout
.input
\end_layout

\end_inset

 - Obtain a Reader for reading from a Pipe
\end_layout

\begin_layout Standard
Syntax:
\end_layout

\begin_layout LyX-Code
<pipe object>(.input)
\end_layout

\begin_layout Standard
This method returns a 
\emph on
Reader
\emph default
 object which can the be used to read characters from the pipe.
\end_layout

\begin_layout Subsubsection
.delete
\begin_inset Index
status open

\begin_layout Plain Layout
.delete
\end_layout

\end_inset

 - Remove a named pipe from the system
\end_layout

\begin_layout Standard
Syntax:
\end_layout

\begin_layout LyX-Code
Pipe!delete <name string>
\end_layout

\begin_layout Standard
This function closes a pipe and removes it from the global list of pipes.
\end_layout

\begin_layout Subsubsection
Pipe Examples
\begin_inset Index
status open

\begin_layout Plain Layout
Pipe Examples
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Single Reader, Single Writer
\end_layout

\begin_layout Standard
The first example shows a single task writing to a pipe and a single task
 reading from it.
 Since there is no contention there is no need to synchronize the tasks.
 The writing task executes this:
\end_layout

\begin_layout LyX-Code
define shared (Pipe!open 'shared-pipe')
\end_layout

\begin_layout LyX-Code
spawn 'test/mocks/pipe-reader.g' 'shared-pipe'
\end_layout

\begin_layout LyX-Code
define out
\end_layout

\begin_layout LyX-Code
   shared(.output)
\end_layout

\begin_layout LyX-Code
out(.format 'Hello from the first task
\backslash
n')
\end_layout

\begin_layout Standard
The reader task is launched and executes this code:
\end_layout

\begin_layout LyX-Code
@prefix task 'http://www.genyris.org/lang/task#'
\end_layout

\begin_layout LyX-Code
@prefix sys 'http://www.genyris.org/lang/system#'
\end_layout

\begin_layout LyX-Code
define inpipe (Pipe(.open (nth 1 sys:argv)))
\end_layout

\begin_layout LyX-Code
define in (inpipe(.input))
\end_layout

\begin_layout LyX-Code
var line (in(.getline))
\end_layout

\begin_layout LyX-Code
assert (equal? 'Hello from the first task' line)
\end_layout

\begin_layout Paragraph
Single Reader, Multiple Writer
\end_layout

\begin_layout Standard
The second example has multiple writer tasks which must be synchronized
 when writing to the pipe otherwise the data becomes mixed.
 The read executes this code which spawns a number of writer tasks, passing
 the name of the pipe.
 It reads a number of lines checking they are exactly in sequence:
\end_layout

\begin_layout LyX-Code
define shared (Pipe!open 'shared-pipe3') # create the pipe.
\end_layout

\begin_layout LyX-Code
for i in (range 0 5)
\end_layout

\begin_layout LyX-Code
    spawn 'test/mocks/pipe-writer-synch.g' 'shared-pipe3'
\end_layout

\begin_layout LyX-Code
define in (shared(.input))
\end_layout

\begin_layout LyX-Code
for i in (range 0 100)
\end_layout

\begin_layout LyX-Code
   var line (in(.getline)) # read from the pipe
\end_layout

\begin_layout LyX-Code
   assert (equal? 'Hello from task.' line)
\end_layout

\begin_layout Standard
The writer tasks open the pipe and repeatedly write lines:
\end_layout

\begin_layout LyX-Code
@prefix task 'http://www.genyris.org/lang/task#'
\end_layout

\begin_layout LyX-Code
@prefix sys 'http://www.genyris.org/lang/system#'
\end_layout

\begin_layout LyX-Code
define shared (Pipe(.open (nth 1 sys:argv))) # open the pipe
\end_layout

\begin_layout LyX-Code
define out
\end_layout

\begin_layout LyX-Code
   shared(.output)
\end_layout

\begin_layout LyX-Code
while true
\end_layout

\begin_layout LyX-Code
    task:synchronized shared # use the pipe object to synchronize on
\end_layout

\begin_layout LyX-Code
       catch errors     # ignore errors when the reader dies.
\end_layout

\begin_layout LyX-Code
          out(.format 'Hello from task.
\backslash
n')
\end_layout

\begin_layout LyX-Code
    sleep 10
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
Interacting with Web Servers with 
\emph on
HTTP
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
HTTP
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
web:get
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
web:get
\end_layout

\end_inset


\emph default
 <url> [<request headers>]
\end_layout

\begin_layout Standard
Content can be sent to and fetched from web servers using the web: get function.
 This takes as input a URL string and an option alist of request headers.
 It sends the GET request to web server and the returns the response content
 in a Reader stream.
 The response must have the 200 'OK' status code otherwise an exception
 is raised.
\end_layout

\begin_layout Standard
Example, fetching the root file from the localhost server on port 80, providing
 a 'Basic' authentication header.
\end_layout

\begin_layout LyX-Code
web:get 'http://localhost:8080/' =
\end_layout

\begin_layout LyX-Code
        ^(('authorization' = 'Basic Zm9vOmJhcg=='))
\end_layout

\begin_layout Section
Programming in the Large
\end_layout

\begin_layout Subsection
Including Source Files
\end_layout

\begin_layout Standard
Functions are provided to allow files of source code to be read and executed.
 The parser to be used is automatically selected based on the file suffix.
 The following suffixes and parsers are supported:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
suffix
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parser Class
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Syntax
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.g
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parser
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Genyris indented syntax
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.lsp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ParenParser
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Free format LISP Syntax with parentheses in place of indentation.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
load
\begin_inset Index
status open

\begin_layout Plain Layout
load
\end_layout

\end_inset


\emph on
<java resource name>
\end_layout

\begin_layout Standard
The
\emph on
 load
\emph default
 function reads and executes a source file from the Java classpath.
 Some initialization code files are stored within the distributed binary
 Java 
\begin_inset Quotes eld
\end_inset

jar
\begin_inset Quotes erd
\end_inset

 file .
 The
\emph on
 <java resource name>
\emph default
 parameter is a full path to the file.
 For example:
\end_layout

\begin_layout LyX-Code

\series bold
load
\series default
 'examples/people.g'
\end_layout

\begin_layout Subsubsection
include
\begin_inset Index
status open

\begin_layout Plain Layout
include
\end_layout

\end_inset


\emph on
<path to filename>
\end_layout

\begin_layout Standard
The
\emph on
 include
\emph default
 function reads and executes files of scripts in the global environment.
 The <path to filename> parameter refers to a normal operating system file
 path.
 
\emph on
include 
\emph default
searches the list of directories in the
\emph on
 sys:path
\emph default
 variable and uses the first matching file it finds.
 Examples:
\end_layout

\begin_layout LyX-Code
include 'examples/people.g'   # relative path
\end_layout

\begin_layout LyX-Code
setq sys:path (cons 'examples' sys:path)
\end_layout

\begin_layout LyX-Code
include 'people.g'    # using the search path
\end_layout

\begin_layout LyX-Code
include 'c:/workspace/genyris/examples/queens.g'  # absolute path - Windows
\end_layout

\begin_layout Standard
The return value is a string with the actual file path loaded.
 If the file cannot be found an exception is raised.
\end_layout

\begin_layout Subsection
Namespaces
\end_layout

\begin_layout Standard
A way to prevent name clashes is to use symbol prefixes to define 'namespaces
\begin_inset Index
status open

\begin_layout Plain Layout
namespaces
\end_layout

\end_inset

' for symbols.
 A namespace can be defined with a Parser Directive 
\begin_inset Quotes eld
\end_inset


\emph on
@prefix
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\end_layout

\end_inset

@prefix
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 as follows
\end_layout

\begin_layout LyX-Code
@prefix magic 'http://my.org/2008/spells/'
\end_layout

\begin_layout Standard
Here the expression starting with
\emph on
 @prefi
\emph default
x is consumed by the parser, and any subsequent symbols it sees starting
 with the prefix
\emph on
 magic
\emph default
.
 are replaced with
\emph on
 http://my.org/2008/spells/
\emph default
.
 Hence the true name of
\emph on
 magic.accio
\emph default
 is
\emph on
 http://my.org/2008/spells/accio
\emph default
.
 We can print the full name of the symbol by quoting it:
\end_layout

\begin_layout LyX-Code
> @prefix magic 'http://my.org/2008/spells/'
\end_layout

\begin_layout LyX-Code
^magic:accio
\end_layout

\begin_layout LyX-Code
~ http://my.org/2008/spells/accio # URISymbol
\begin_inset Index
status open

\begin_layout Plain Layout
URISymbol
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here is the previous example re-worked using a namespace:
\end_layout

\begin_layout LyX-Code
## File Handling Module (using prefixes)
\end_layout

\begin_layout LyX-Code
@prefix file 'http://my/files/'
\end_layout

\begin_layout LyX-Code
def file:copy(from to) etc
\end_layout

\begin_layout LyX-Code
def file:delete(filename) etc
\end_layout

\begin_layout LyX-Code
def file:zip(file) etc
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
## Use of the file module
\end_layout

\begin_layout LyX-Code
@prefix f 'http://my/files/'
\end_layout

\begin_layout LyX-Code
def archive(filename)
\end_layout

\begin_layout LyX-Code
    f:copy filename '/tmp/foo'
\end_layout

\begin_layout LyX-Code
    f:zip '/tmp/foo'
\end_layout

\begin_layout LyX-Code
    f:delete filename
\end_layout

\begin_layout Standard
Prefixes apply to all symbols seen by the parser in the current parse, and
 can be used in a variety of ways (for example) to define global properties
 or interfaces.
\end_layout

\begin_layout Subsubsection
Disambiguate Properties and Methods
\end_layout

\begin_layout Standard
Like RDF, Genyris supports sharing of property names (or method names) amongst
 classes and objects.
 Indeed use of fully qualified symbols to denote identical concepts wherever
 they appear is very good practice.
 Consider the object introduced in 
\emph on
'examples/people.g'
\emph default
:
\end_layout

\begin_layout LyX-Code
@prefix foaf 'http://xmlns.com/foaf/0.1/' 
\end_layout

\begin_layout LyX-Code
dict
\end_layout

\begin_layout LyX-Code
      .foaf:name = "Neil Wheedon Watkins Pye"
\end_layout

\begin_layout LyX-Code
      .foaf:age = 49 
\end_layout

\begin_layout LyX-Code
      .bong = true
\end_layout

\begin_layout Standard
Using the RDF ontology at 
\emph on
http://xmlns.com/foaf/0.1/
\emph default
 we can deduce object is of class 
\emph on
foaf:Person
\emph default
 because there is a fully qualified 
\emph on
foaf:age
\emph default
 property.
 We also know from the ontology that the unit of 
\emph on
foaf:age
\emph default
 is integer years.
 However the meaning of the unqualified '
\emph on
bong
\emph default
' property can only be guessed.
\end_layout

\begin_layout Standard
If extensive use of mixins or multiple inheritance is used, name clashes
 may arise in languages without namespaces for symbols.
 In Genyris (as in RDF) properties can have fully qualified URI names, providing
 simple disambiguation.
 The following example avoids a clash over the 
\emph on
'draw'
\emph default
 method because the public methods of the two base classes are fully qualified:
\end_layout

\begin_layout LyX-Code
@prefix graphics 'http://www.gameslib.org/interfaces/'
\end_layout

\begin_layout LyX-Code
@prefix weapon 'http://mygame.com/007/'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
class Shape()
\end_layout

\begin_layout LyX-Code
   def .graphics:draw()
\end_layout

\begin_layout LyX-Code
        'draw object image on the computer screen'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
class SecretAgent()
\end_layout

\begin_layout LyX-Code
   def .weapon:draw()
\end_layout

\begin_layout LyX-Code
        'take gun out of holster'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
class SecretAgentSprite(Shape SecretAgent)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsubsection
Genyris property values are first class objects.
\end_layout

\begin_layout Standard
In RDF, literals such as 
\emph on

\begin_inset Quotes eld
\end_inset

Rick
\begin_inset Quotes erd
\end_inset


\emph default
 cannot belong to classes, nor can they be shared between triples.
 Genyris allows literals to be 'first class'.
 They can be shared between objects belong to classes.
 Hence another approach is to tag the values of the properties with the
 class:
\end_layout

\begin_layout LyX-Code
class foaf:name
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
define rick
\end_layout

\begin_layout LyX-Code
  dict
\end_layout

\begin_layout LyX-Code
     .name = (tag foaf:name "Rick")
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> rick
\end_layout

\begin_layout LyX-Code
(dict (.name = "Rick")) # Dictionary 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> rick!name
\end_layout

\begin_layout LyX-Code
"Rick" # |http://xmlns.com/foaf/0.1/name| String 
\end_layout

\begin_layout Standard
This has the advantage that methods can be associated with the 
\emph on
'Rick'
\emph default
 string via the 
\emph on
foaf:name
\emph default
 class.
 The system will remember that the string is a 
\emph on
foaf:name
\emph default
.
 However the program source lacks semantic mark-up.
 DEpending on the application both techniques may be appropriate.
\end_layout

\begin_layout Subsubsection
Semantic Markup
\end_layout

\begin_layout Standard
Namespaces are compatible with RDF
\begin_inset Index
status open

\begin_layout Plain Layout
RDF
\end_layout

\end_inset

 and allow you to embed the semantics of the information within the program.
 This can be used either for human consumption (to fully identify the meaning
 of the information) or for subsequent processing and linkage with external
 programs which also understand RDF.
 Here's an example:
\end_layout

\begin_layout LyX-Code
> @prefix us "http://places.org/usa#"
\end_layout

\begin_layout LyX-Code
var boston                   # variable declaration
\end_layout

\begin_layout LyX-Code
  dict                       # new dictionary object
\end_layout

\begin_layout LyX-Code
    .us:location = "Boston"
\end_layout

\begin_layout LyX-Code
    .us:zip = "02110"
\end_layout

\begin_layout LyX-Code
    .us:location-lat = 42.37
\end_layout

\begin_layout LyX-Code
    .us:location-long = 71.03
\end_layout

\begin_layout LyX-Code
dict
\end_layout

\begin_layout LyX-Code
      .|http://places.org/usa#location| = "Boston"
\end_layout

\begin_layout LyX-Code
      .|http://places.org/usa#location-lat| = 42.37
\end_layout

\begin_layout LyX-Code
      .|http://places.org/usa#location-long| = 71.03
\end_layout

\begin_layout LyX-Code
      .|http://places.org/usa#zip| = "02110" # Dictionary
\end_layout

\begin_layout Subsection
Modules
\end_layout

\begin_layout Standard
We have seen how names can be grouped within a Dictionary object.
 This idea is made easier through modules
\begin_inset Index
status open

\begin_layout Plain Layout
modules
\end_layout

\end_inset

.
 A module is simply a dictionary into which the contents of a source file
 have been bound.
 When the input file is read, all dynamic bindings are automatically made
 in a 'module' dictionary.
 Continuing with our example, first we provide a file of functions and definitio
ns called '
\emph on
file.g
\emph default
'.
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# File Handling Module
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
define .doc 'File Handling Functions'
\end_layout

\begin_layout LyX-Code
define .version '1.2'
\end_layout

\begin_layout LyX-Code
def .copy(from to)
\end_layout

\begin_layout LyX-Code
   etc
\end_layout

\begin_layout LyX-Code
def .delete(filename)
\end_layout

\begin_layout LyX-Code
   etc
\end_layout

\begin_layout LyX-Code
def .zip(file)
\end_layout

\begin_layout LyX-Code
   etc
\end_layout

\begin_layout LyX-Code
def helperFunction(args)
\end_layout

\begin_layout LyX-Code
   etc
\end_layout

\begin_layout Standard
Notice we don't need to declare a dictionary since this is provided by
\emph on
 import
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
import
\end_layout

\end_inset

.
 To use the module we first need to tell the interpreter where to find the
 file containing the module's code.
 This is done by adding to the
\emph on
 sys:path
\emph default
 global variable which is a list of directories to search:
\end_layout

\begin_layout LyX-Code
setq sys:path
\begin_inset Index
status open

\begin_layout Plain Layout
sys:path
\end_layout

\end_inset

 (cons 'examples' sys:path)
\end_layout

\begin_layout Standard
Now we read the source code:
\end_layout

\begin_layout LyX-Code
import file
\end_layout

\begin_layout Standard
This creates a variable
\emph on
 file
\emph default
 in the environment of the caller (not necessarily the global environment).
 Using the module's dictionary we can now access the functions in the module:
\end_layout

\begin_layout LyX-Code
## Use of the file module
\end_layout

\begin_layout LyX-Code
import file
\end_layout

\begin_layout LyX-Code
file!copy filename '/tmp/foo'
\end_layout

\begin_layout Standard
Note that
\emph on
 helperFunction
\emph default
 is defined with a normal lexical variable.
 It cannot be reached from outside the module since only dynamic symbols
 can be de-reference via a dictionary.
 Use this to create private variables and functions inside modules.
\end_layout

\begin_layout Standard
If we change the source code of
\emph on
 file.g
\emph default
 and need to load the new code, we must use the
\emph on
 reload
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
reload
\end_layout

\end_inset


\emph default
 macro, since import checks to see if the module already is in memory, and
 uses the already loaded module.
\end_layout

\begin_layout LyX-Code
> reload file
\end_layout

\begin_layout LyX-Code
etc...
\end_layout

\begin_layout Subsubsection
sys:import
\begin_inset Index
status open

\begin_layout Plain Layout
sys:import
\end_layout

\end_inset

 <filename name>
\end_layout

\begin_layout Standard
The
\emph on
 sys:import
\emph default
 function is similar to the include function in that it reads and executes
 a file of Genyris source code.
 However the code is executed
\emph on
 in the environment of the caller
\emph default
.
 Therefore in a lexical environment, new bindings created by
\emph on
 define
\emph default
 and
\emph on
 def
\emph default
 et.
 al.
 will be created locally.
 In a dynamic environment such as in a Dictionary, the dynamic bindings
 in the top level of the file will affect the caller's object.
 This function is used by the
\emph on
 import
\emph default
 facility to define modules.
\end_layout

\begin_layout Subsubsection
import
\begin_inset Index
status open

\begin_layout Plain Layout
import
\end_layout

\end_inset

 <module name>
\end_layout

\begin_layout Standard
The
\emph on
 import
\emph default
 macro uses
\emph on
 sys:import
\emph default
 to create dictionaries in which the file's bindings are held.
 To allow users to have multipe calls to
\emph on
 import
\emph default
, yet all refer to the same object,
\emph on
 import
\emph default
 stores all module dictionaries in the
\emph on
 sys:modules
\emph default
 graph.
 This graph contains a binding between the module name and the module object.
 When the import is called it checks to see if the module has already been
 loaded, if so it binds the module to a variable of the same name in the
 caller's environment.
 Hence there may be many bindings of the module name to the same physical
 object.
\end_layout

\begin_layout Standard
To simplify loading, the
\emph on
 import
\emph default
 macro searches for a file with the name of the module plus the
\emph on
 '.g'
\emph default
 suffix.
 It uses the list of directories in the
\emph on
 sys:path
\emph default
 variable for the search path and uses the first matching file it finds.
 Example:
\end_layout

\begin_layout LyX-Code
setq sys:path (cons 'examples' sys:path)
\end_layout

\begin_layout LyX-Code
import queens
\end_layout

\begin_layout LyX-Code
queens!queens 5  # call the module's public function
\end_layout

\begin_layout Subsubsection
reload
\begin_inset Index
status open

\begin_layout Plain Layout
reload
\end_layout

\end_inset

 <module name>
\end_layout

\begin_layout Standard
The
\emph on
 reload
\emph default
 macro uses the existing module's filename to reload the source code of
 the module.
 If there are multiple bindings to the module, only the caller will have
 a binding to the new module.
 The binding in the
\emph on
 sys:modules
\emph default
 graph is replaced with the new object.
 Other references to the module will still refer to the old module.
\end_layout

\begin_layout Section
Genyris Classes
\end_layout

\begin_layout Subsection
Class Hierarchy
\end_layout

\begin_layout Standard
Here is the default class hierarchy:
\end_layout

\begin_layout LyX-Code
 Thing
\end_layout

\begin_layout LyX-Code
    Task
\end_layout

\begin_layout LyX-Code
    Module
\end_layout

\begin_layout LyX-Code
    SetList
\end_layout

\begin_layout LyX-Code
    Alist
\end_layout

\begin_layout LyX-Code
    Builtin
\end_layout

\begin_layout LyX-Code
       PairEqual
\end_layout

\begin_layout LyX-Code
       Pair
\end_layout

\begin_layout LyX-Code
          ListOfLines
\end_layout

\begin_layout LyX-Code
          PRINTWITHEQ
\end_layout

\begin_layout LyX-Code
       Closure
\end_layout

\begin_layout LyX-Code
          LazyProcedure
\end_layout

\begin_layout LyX-Code
          EagerProcedure
\end_layout

\begin_layout LyX-Code
       Symbol
\end_layout

\begin_layout LyX-Code
          DynamicSymbolRef
\end_layout

\begin_layout LyX-Code
          URISymbol
\end_layout

\begin_layout LyX-Code
          SimpleSymbol
\end_layout

\begin_layout LyX-Code
             |http://www.genyris.org/lang/syntax#Keyword|
\end_layout

\begin_layout LyX-Code
       Graph
\end_layout

\begin_layout LyX-Code
       Triple
\end_layout

\begin_layout LyX-Code
       Sound
\end_layout

\begin_layout LyX-Code
       StringFormatStream
\end_layout

\begin_layout LyX-Code
       ParenParser
\end_layout

\begin_layout LyX-Code
       Parser
\end_layout

\begin_layout LyX-Code
       System
\end_layout

\begin_layout LyX-Code
       Writer
\end_layout

\begin_layout LyX-Code
       Reader
\end_layout

\begin_layout LyX-Code
       CSV
\end_layout

\begin_layout LyX-Code
       File
\end_layout

\begin_layout LyX-Code
       String
\end_layout

\begin_layout LyX-Code
          ShortDateTimeString
\end_layout

\begin_layout LyX-Code
       Bignum
\end_layout

\begin_layout LyX-Code
       Dictionary
\end_layout

\begin_layout LyX-Code
          Object
\end_layout

\begin_layout LyX-Code
          StandardClass
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
TODO: How to extract it by code
\end_layout

\begin_layout Subsection

\emph on
StandardClass
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
StandardClass
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
.classname
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.classname
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
.subclasses
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.subclasses
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
.superclasses
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.superclasses
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
.vars
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.vars
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
Builtin
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Builtin
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\emph on
Thing
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Thing
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
.vars
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.vars
\end_layout

\end_inset


\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
!vars
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
.self
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.self
\end_layout

\end_inset


\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
!self
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
.classes
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.classes
\end_layout

\end_inset


\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
!classes
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
.valid?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.valid?
\end_layout

\end_inset


\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
!valid?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection

\emph on
NilSymbol
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
NilSymbol
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection

\emph on
Closure
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Closure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection

\emph on
LazyProcedure
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
LazyProcedure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection

\emph on
EagerProcedure
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
EagerProcedure
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Pair"

\end_inset


\emph on
Pair
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Pair
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
list
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
list
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
car
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
car
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
cdr
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
cdr
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
left
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
left
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
right
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
right
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
cons
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
cons
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
.left
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.left
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
.right
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.right
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
rplaca
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
rplaca
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
rplacd
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
rplacd
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
reverse
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
reverse
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
length
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
length
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
map-left
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
map-left
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
member?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
member?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection

\emph on
Alist
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Alist
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph

\emph on
.lookup
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.lookup
\end_layout

\end_inset


\emph default
(key)
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph
.
\emph on
getKeys
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
getKeys
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
.hasKey
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.hasKey
\end_layout

\end_inset


\emph default
(key)
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
.render
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.render
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection

\emph on
Object
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Object
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph

\emph on
.new
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.new
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph

\emph on
.init
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.init
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Section
Launching the Interpreter 
\begin_inset CommandInset label
LatexCommand label
name "sec:Running-Genyris"

\end_inset


\end_layout

\begin_layout Subsubsection
Simplified Launching via the Path
\end_layout

\begin_layout Standard
The distribution includes shell and batch files for simplified launching,
 both which require a change to the user's environment.
\end_layout

\begin_layout Paragraph
Unix
\end_layout

\begin_layout Standard
Add an environment variable called
\emph on
 GENYRIS_HOME
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
GENYRIS_HOME
\end_layout

\end_inset


\emph default
 which contains the path of the unpacked release.
 Modify your
\emph on
 PATH
\emph default
 environment variable to include
\emph on
 $GENYRIS_HOME/bin
\emph default
.
 The interpreter can then be launched from the shell with
\end_layout

\begin_layout LyX-Code

\emph on
$ genyri
\emph default
s
\end_layout

\begin_layout Paragraph
Windows
\end_layout

\begin_layout Standard
On Windows the arrangement is similar.
 Add an environment variable called
\emph on
 GENYRIS_HOME
\emph default
.
 Modify the
\emph on
 PATH
\emph default
 environment variable to include
\emph on
 %GENYRIS_HOME%
\backslash
bin:
\emph default
 (from the GUI Start > Control Panel > System > Advanced > Environment Variables
 > New).
 Now the interpreter can then be launched from the command prompt with
\emph on
 
\begin_inset Quotes eld
\end_inset

genyri
\emph default
s
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Command line options
\end_layout

\begin_layout Standard
Genyris is started by the Java interpreter from the command line
\begin_inset Index
status open

\begin_layout Plain Layout
command line
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Paragraph
Using Genyris standard IO command-line interpreter.
\end_layout

\begin_layout Standard
The java
\emph on
 -jar
\emph default
 option specifies the jar to execute.
 For example:
\end_layout

\begin_layout LyX-Code
$
\series bold
java -jar genyris-bin-nnn-xxxxxxxxx.jar
\end_layout

\begin_layout Standard
Since the default main class is the Read-Eval-Print-Loop (REPL) command
 line it is automatically chosen by the -jar option.
 The same REPL class above can be run identically as as follows:
\end_layout

\begin_layout LyX-Code
$ java -cp genyris-bin.jar org.genyris.interp.ClassicReadEvalprintLoop
\end_layout

\begin_layout Standard
In both cases all subsequent shell command line arguments are ignored.
 The session is terminated when the interpreter read and End-Of-File from
 the standard input (^D on UNIX or ^Z on Windows).
\end_layout

\begin_layout Subparagraph
The top level
\end_layout

\begin_layout Standard
Genyris commands can be typed at the prompt, using two carriage returns
 (
\begin_inset Formula $\hookleftarrow$
\end_inset

) to terminate a statement.
 The REPL reads the next indented expression, evaluates it in the global
 environment and prints the result.
 It also appends a comment consisting of the names of the classes of the
 result.
 This allows the user to verify the correct classes have been returned.
\end_layout

\begin_layout Paragraph
Running a script in the command line
\end_layout

\begin_layout LyX-Code
DOS> genyris -eval print 'hello world'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
unix$ genyris -eval print 'hello world'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
If the return value of the expression is printed, the process exits with
 a 0 status, otherwise 1.
\end_layout

\begin_layout Paragraph
Specify a file to run on the command line
\end_layout

\begin_layout LyX-Code
$ genyris examples/queens.g 5
\end_layout

\begin_layout Standard
Arguments are passed after the file name.
\end_layout

\begin_layout Paragraph
Making a script executable (Unix)
\end_layout

\begin_layout Standard
If a script begins with
\emph on
 #!
\emph default
 it allows Unix to run the script directly.
 Here's an example script:
\end_layout

\begin_layout LyX-Code
#!/usr/bin/sh /opt/home/birchb/workspace/genyris/bin/genyris
\end_layout

\begin_layout LyX-Code
display 'Hello World'
\end_layout

\begin_layout Standard
if the script is made executable it can be run directly:
\end_layout

\begin_layout LyX-Code
$ chmod u+x myscript.g
\end_layout

\begin_layout LyX-Code
$ ./myscript.g
\end_layout

\begin_layout Subsubsection
Interpreter Boot sequence
\end_layout

\begin_layout Standard
After initialisation, the interpreter searches for the resource 
\begin_inset Quotes eld
\end_inset


\emph on
org/genyris/load/boot/init.g
\emph default

\begin_inset Quotes erd
\end_inset

 in the Java classpath and executes it.
 This file is provided in the genyris-bin jar file and contains a Genyris
 bootstrap which in loads other source files also provided within the jar
 file.
 This is equivalent to executing :
\end_layout

\begin_layout LyX-Code
load
\series bold
 
\series default
'org/genyris/load/boot/init.g
\begin_inset Index
status open

\begin_layout Plain Layout
init.g
\end_layout

\end_inset

'
\end_layout

\begin_layout Section
Tasks
\begin_inset Index
status open

\begin_layout Plain Layout
Tasks
\end_layout

\end_inset

 - Multiple Threads of Execution
\end_layout

\begin_layout Standard

\emph on
Tasks
\emph default
 in Genyris are modelled on Unix processes.
 They are seperate interpreter instances where shared memory is minimal,
 and communication is conducted via system objects outside of the interpreters
 themselves.
 This approach relieves the programmer with the burden of debugging multi-thread
ed code yet retains the advantages of asynchronous execution and multi-core
 hardware.
 This implementation uses a single Java thread per interpreter and uses
 Java in-process objects for inter-task communication.
\end_layout

\begin_layout Subsubsection
Running Multiple Interpreters in the Same Process with 
\emph on
spawn
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
spawn
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
spawn <source file to include> <args ...>
\end_layout

\begin_layout Standard
Spawn creates a new Genyris interpreter instance which is then executed
 by a seperate Java thread.
 Only the objects passed as parameters are shared between interpreter threads.
 They all share the same operating system interfaces, files, sockets etc
 since they are running in the same JVM.
 The function returns a
\emph on
 Task
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Task
\end_layout

\end_inset


\emph default
 object, which is a Dictionary containing, the name, id and state of the
 underlying Java thread.
 For example:
\end_layout

\begin_layout LyX-Code
spawn 'examples/spawn-example.g' 1 2 3 4 5
\end_layout

\begin_layout Standard
returns:
\end_layout

\begin_layout LyX-Code
(dict (.id = 9) (.name = 'examples/spawn-example.g') 
\begin_inset Newline newline
\end_inset

(.state = 'RUNNABLE')) # Task Dictionary
\end_layout

\begin_layout Standard
The
\emph on
 spawn-example.g
\emph default
 file contains:
\end_layout

\begin_layout LyX-Code
@prefix sys 'http://www.genyris.org/lang/system#'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
while true
\end_layout

\begin_layout LyX-Code
   print sys:argv
\end_layout

\begin_layout LyX-Code
   sleep 5000
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout LyX-Code
'examples/spawn-example.g' 1 2 3 4 5
\end_layout

\begin_layout LyX-Code
'examples/spawn-example.g' 1 2 3 4 5
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout Subsubsection
Termination with 
\family typewriter
\emph on
kill
\emph default
:
\end_layout

\begin_layout Standard
Tasks and the underlying Java threads are killed with the
\emph on
 task:kill
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
task:kill
\end_layout

\end_inset


\emph default
 function.
 This is also available as the
\emph on
 .kill
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.kill
\end_layout

\end_inset


\emph default
 method in the
\emph on
Task
\emph default
 class
\emph on

\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Task class
\end_layout

\end_inset


\emph default
.
 A string is returned after completion.
 Note there is no guarantee from Java that the thread will be terminated.
\end_layout

\begin_layout LyX-Code
<Thread>(.kill)
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout LyX-Code
@prefix task 'http://www.genyris.org/lang/task#'
\end_layout

\begin_layout LyX-Code
task:kill <integer Java thread id>
\end_layout

\begin_layout Subsubsection
Thread Safety
\begin_inset Index
status open

\begin_layout Plain Layout
Thread Safety
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The
\emph on
 spawn
\emph default
 function provides a way of multi-tasking sections of an application.
 This allows seperate interpreter instances to execute, and share some common
 value objects passed by main arguments.
 The interpreter does not cater for multiple threads of execution running
 within the same interpreter scope.
 Although it is technically possible to share any genyris objects including
 functions between tasks, this is not supported.
 This is because execution of stored closures will mean two interpreters
 are operating in the same environment.
\end_layout

\begin_layout Standard
Genyris
\emph on
 Tasks
\emph default
 are not
\emph on
 Threads
\emph default
 the intent is that they are self-contained, supporting single-threaded
 applications only.
 However since the underlying Java objects must be shared between tasks
 for inter-task communication, a means of making this thread-safe is provided.
\end_layout

\begin_layout Subsubsection

\emph on
task:synchronized
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
task:synchronized
\end_layout

\end_inset


\emph default
 - Controlling access to shared objects
\end_layout

\begin_layout Standard
The
\emph on
 spawn
\emph default
 and
\emph on
 httpd
\emph default
 functions allow Genyris objects to be passed from one thread of execution
 to another.
 This is provided so that system objects such as pipes, files etc can be
 shared.
\end_layout

\begin_layout Standard
Both tasks have references to the same in-memory objects, and there is real
 danger that the actions of one thread will corrupt the objects used by
 another.
 The
\emph on
 synchronized
\emph default
 macro ensures that access to shared objects is sequential.
 The syntax is as follows:
\end_layout

\begin_layout LyX-Code
task:synchronized <object>
\end_layout

\begin_layout LyX-Code
    <code body>
\end_layout

\begin_layout LyX-Code
    ....
\end_layout

\begin_layout Standard
The effect of the macro is to wait for an implicit lock associated with
 the
\emph on
 <object>
\emph default
 to become free.
 When the lock is free the thread sets the lock and executes the
\emph on
 <code body
\emph default
>.
 When the execution completes the lock is freed ready for another thread.
 A test-case:
\end_layout

\begin_layout Standard
A task loops, watching a shared
\emph on
 Pair
\emph default
, checking to see if the
\emph on
 left
\emph default
 value is ever 1.
 If so it raises an error.
\end_layout

\begin_layout LyX-Code
task:synchronized shared
\end_layout

\begin_layout LyX-Code
     setq read-value (shared.left)
\end_layout

\begin_layout LyX-Code
cond
\end_layout

\begin_layout LyX-Code
     (equal? 1 read-value)
\end_layout

\begin_layout LyX-Code
            raise "error"
\end_layout

\begin_layout Standard
A second task loops, changing the value from 0 to 1 and back.
\end_layout

\begin_layout LyX-Code
task:synchronized shared
\end_layout

\begin_layout LyX-Code
        shared (setq .left 1)
\end_layout

\begin_layout LyX-Code
        sleep 13
\end_layout

\begin_layout LyX-Code
        shared (setq .left 0)
\end_layout

\begin_layout LyX-Code
        sleep 23
\end_layout

\begin_layout Standard
Because both tasks are executing this code in the scope of a
\emph on
 synchronized
\emph default
 call, with the same shared lock object, the first task never sees the value
 altered to 1 by the second task.
 Without the
\emph on
 synchronized
\emph default
 macro the first task would see the manipulations of the second task.
\end_layout

\begin_layout Subsubsection

\emph on
ps
\emph default
 - list current running threads
\end_layout

\begin_layout Standard
The
\emph on
 ps
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
ps
\end_layout

\end_inset


\emph default
 function returns a list of
\emph on
 Task
\emph default
 objects for each of the current tasks.
\end_layout

\begin_layout Section
Running Web Servers
\end_layout

\begin_layout Standard
Genyris can run multiple a single-threaded HTTP 1.0 servers in Tasks in the
 background.
 The web server is implemented in Java and provides a simple programming
 interface.
\end_layout

\begin_layout Subsubsection
Starting a web server
\end_layout

\begin_layout Standard
A new interpreter can be started as a server with the
\emph on
 httpd
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
httpd
\end_layout

\end_inset


\emph default
 function:
\end_layout

\begin_layout LyX-Code
httpd <port> <path to source file> [args...]
\end_layout

\begin_layout Standard
The
\emph on
 httpd
\emph default
 function takes parameters:
\end_layout

\begin_layout Itemize
the path of a Genyris source file to load and run
\end_layout

\begin_layout Itemize
the TCP/IP port number on which the server will listen for requests.
\end_layout

\begin_layout Itemize
all the remaining parameters are collected in a list and bound to
\emph on
 sys:argv
\end_layout

\begin_layout Standard
The return value is a
\emph on
 Task
\emph default
 object for the web server.
 Many web servers can be started in the same JVM, each server is allocated
 a unique interpreter instance, there is no sharing between interpreters
 apart from the
\emph on
 args
\emph default
 passed in
\emph on
.
 
\emph default
Multiple tasks may be started reading from the same port to allow higher
 throughput.
\end_layout

\begin_layout Standard
The URL for the browser would be
\emph on
 http://localhost:<port>/
\emph default
.
 
\end_layout

\begin_layout Paragraph
Example
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
httpd 7777 'examples/www-demo.g' 1 2 3 4 5
\end_layout

\begin_layout Subsubsection
Stopping a web server
\end_layout

\begin_layout Standard
The server is terminated by killing the thread, or by coding an explicit
 exit function within the web application.
 The server's thread can be stopped with the
\emph on
 kill
\emph default
 functions described above.
\end_layout

\begin_layout Subsubsection
Processing Web Requests
\end_layout

\begin_layout Standard
The web server main loop expects to fnd a function called
\emph on
 httpd-serve
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
httpd-serve
\end_layout

\end_inset


\emph default
 which it calls for each web GET or POST request received from clients.
 The request from the remote client is passed to the function as a single
 parameter.
 The return from the function call must contain the response to be sent
 to the browser.
\end_layout

\begin_layout Paragraph
Example
\end_layout

\begin_layout LyX-Code
df httpd-serve (request)
\end_layout

\begin_layout LyX-Code
   list 200 'text/plain' 'Hello World'
\end_layout

\begin_layout Paragraph
Requests - HttpRequest class
\end_layout

\begin_layout Standard
The request parameter is an object of class
\emph on
 HttpRequest
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
HttpRequest
\end_layout

\end_inset

.
 The class has the following methods which return components of the request:
\end_layout

\begin_layout Description
.getMethod() GET or POST
\end_layout

\begin_layout Description
.getPath() Path component of the URL
\end_layout

\begin_layout Description
.getHeaders() an
\emph on
 AList
\emph default
 containing the headers
\end_layout

\begin_layout Description
.getParameters() an
\emph on
 AList
\emph default
 containing GET or POST parameters
\end_layout

\begin_layout Description
.getClient() gives a Pair containing the client's IP address and hostname
\end_layout

\begin_layout Description
.getBasicUsernamePassword() Returns the Basic Authentication scheme header
 as a dictionary with
\emph on
.username
\emph default
 and
\emph on
.password
\emph default
 strings.
 If no auth is present, the username and passwords are empty strings.
\end_layout

\begin_layout Description
.toHTML() a method returning an HTML list structure in %x format.
\end_layout

\begin_layout Paragraph
Responses
\end_layout

\begin_layout Standard
The return value from the
\emph on
 httpd-serve
\emph default
 function is anlaysed by the web server and executed as required.
 There are two types of response:
\end_layout

\begin_layout Itemize
Instruction to serve a file from the file system as a 'static' page
\end_layout

\begin_layout Itemize
A data structure to be converted to XHTML and transmittted
\end_layout

\begin_layout Paragraph
Static Pages
\end_layout

\begin_layout Standard
If the return value is a list of the form:
\end_layout

\begin_layout LyX-Code
SERVE-FILE <root Directory Path> <Path to File> [<list directory flag>]
\end_layout

\begin_layout Standard
Then the file referred to by the path <root Directory Path>/<Path to File>
 is served to the client.
 If the file is a directory, and the <list directory flag> is the symbol
\emph on
 ls
\emph default
, then the directory listing is returned to the client in HTML.
 The following function provides a simple static web server:
\end_layout

\begin_layout LyX-Code
df httpd-serve (request)
\end_layout

\begin_deeper
\begin_layout LyX-Code
list ^SERVE-FILE '/' (request(.getPath)) ^ls
\end_layout

\end_deeper
\begin_layout Paragraph
Http Responses in XML list structures
\end_layout

\begin_layout Standard
If the response is a list of the form:
\end_layout

\begin_layout LyX-Code
<integer status code> <mime type> <tree>
\end_layout

\begin_layout Standard
then the web server converts <tree> into the relevant encoding and transmits
 it to the client.
 The conversion depends on the <mime type>.
\end_layout

\begin_layout Subparagraph
text/plain
\end_layout

\begin_layout Standard
This type of response uses the parenthesised Genyris output formatter to
 display the <tree>.
 It is equivalent to the %s directive in the %format instruction.
\end_layout

\begin_layout Subparagraph
text/html
\end_layout

\begin_layout Standard
This type of response must be in the XML format as used by the
\emph on
 %x
\emph default
 directive in the
\emph on
 format
\emph default
 function.
 This format requires XML tags to be symbols, followed by an attribute list.
 Strings any sub-tags are interleaved.
 The general grammar is:
\end_layout

\begin_layout LyX-Code
xml=tree :== html-tag ((attribute = 'value')...)
\end_layout

\begin_deeper
\begin_layout LyX-Code
['inner text' |<xml-tree> ] ...
\end_layout

\end_deeper
\begin_layout Standard
For example, the expression:
\end_layout

\begin_layout LyX-Code
u:format '%x'
\end_layout

\begin_layout LyX-Code
   quote
\end_layout

\begin_layout LyX-Code
     html()
\end_layout

\begin_layout LyX-Code
      head()
\end_layout

\begin_layout LyX-Code
        title() "Lamp Server"
\end_layout

\begin_layout LyX-Code
          body()
\end_layout

\begin_layout LyX-Code
             form()
\end_layout

\begin_layout LyX-Code
                input((name="op") (size="100") (value =none)) ""
\end_layout

\begin_layout LyX-Code
                   verbatim() "&nbsp;&nbsp;&nbsp;"
\end_layout

\begin_layout LyX-Code
                   input((type="submit") (value="Go"))
\end_layout

\begin_layout Standard
Is converted to the corresponding XML string:
\end_layout

\begin_layout LyX-Code
<html><head><title>Lamp Server<body>
\begin_inset Newline newline
\end_inset

<form><input name="op" size="100" value="none">&nbsp;&nbsp;&nbsp;
\begin_inset Newline newline
\end_inset

<input type="submit" value="Go"/>
\end_layout

\begin_layout LyX-Code
</input></form></body></title></head></html>
\end_layout

\begin_layout Standard
The
\emph on
 verbatim
\emph default
 pseudo-tag passes text transparently.
 
\end_layout

\begin_layout Standard
The 
\emph on
stream 
\emph default
psuedo-tag allows the contents of a Reader object to be inserted in the
 output.
\end_layout

\begin_layout Standard
This example (from
\emph on
 examples/www-demo.g
\emph default
) echoes the input request in HTML:
\end_layout

\begin_layout LyX-Code
df httpd-serve (request)
\end_layout

\begin_layout LyX-Code
   list 200 'text/html'
\end_layout

\begin_layout LyX-Code
      template
\end_layout

\begin_layout LyX-Code
          html()
\end_layout

\begin_layout LyX-Code
             head()
\end_layout

\begin_layout LyX-Code
                title() 'Genyris demo'
\end_layout

\begin_layout LyX-Code
             body()
\end_layout

\begin_layout LyX-Code
                pre() ,sys.argv
\end_layout

\begin_layout LyX-Code
                ,(request (.toHTML))
\end_layout

\begin_layout Subsubsection
Starting a static web server
\end_layout

\begin_layout Standard
A static page web server can be started with the
\emph on
 www-static
\emph default
 script:
\end_layout

\begin_layout LyX-Code
httpd <port> "test/mocks/www-static.g" <root directory>
\end_layout

\begin_layout Section
Using Java Classes
\end_layout

\begin_layout Standard
The Genyris interpreter allows standard Java objects to be created and stored
 in variable bindings, and allows Java methods to be called from Genyris.
 Java objects are contained within a builtin '
\emph on
JavaWrapper
\emph default
' class, whose class list includes a Genyris class with Procedure objects
 corresponding to the Java methods.
 This allows Java objects and classes to be used in the same way as Genyris
 ones.
\end_layout

\begin_layout Standard
Java symbol names used for fields, classnames etc have a different syntax
 to Genyris, so rather than using escaped symbols, the default is to map
 Java Symbols to Genyris ones.
 The Genyris name based on the java name with some characters translated
 as follows:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Java character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Genyris Character
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
_
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
This is used for class names method names, fields names or anywhere a Java
 name is used in a Genyris program.
\end_layout

\begin_layout Subsection
Importing a Java Class with
\series medium
\size normal
\emph on
 java:import
\end_layout

\begin_layout Standard
The
\emph on
 java:import
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
java:import
\end_layout

\end_inset


\emph default
 function creates a Genyris class corresponding to a Java class.
 The properties of the new Genyris class correspond to the methods and construct
ors of the Java class.
 The syntax is:
\end_layout

\begin_layout LyX-Code
@prefix java 'http://www.genyris.org/lang/java#' java:import <java class string>
 [as <shorthand name>]
\end_layout

\begin_layout Standard
The full java class name is supplied as a string.
 Optionally a shorthand symbol to use as well as the default name can be
 specified.
 The default name is translated as described above.
 The return value is the Genyris class created.
 This class is bound to the corresponding full name in the global environment.
 If the
\emph on
 as
\emph default
 clause is present the class is also bound to the shorthand name in the
 local environment of the caller.
\end_layout

\begin_layout Standard
Example :
\end_layout

\begin_layout LyX-Code
> java:import 'java.lang.Object' as Jobject
\end_layout

\begin_layout LyX-Code
 <class java_lang_Object (Java)> # StandardClass
\end_layout

\begin_layout LyX-Code
> assert (eq? java_lang_Object Jobject)
\end_layout

\begin_layout Standard
Continuing with the
\emph on
 java.io.File
\emph default
 example, we can list the method with
\emph on
 .vars
\emph default
:
\end_layout

\begin_layout LyX-Code
Jobject.vars
\end_layout

\begin_layout Standard
produces
\end_layout

\begin_layout LyX-Code
(.notifyAll .getClass .wait-long-int .equals-java_lang_Object .hashCode
\begin_inset Newline newline
\end_inset

 .wait-long .classname .wait .java-classname .toString .new .notify
\begin_inset Newline newline
\end_inset

 .superclasses .subclasses .self .vars .classes) # Pair
\end_layout

\begin_layout Standard
The methods names include the argument types seperated by a hyphen since
 Java allows multiple methods with the same name and different arguments
 (overloading).
 Constructors, which are nameless in Java, are given the prefix
\emph on
 new
\emph default
-.
\end_layout

\begin_layout Subsubsection
Adding to Java Classes
\end_layout

\begin_layout Standard
Because
\emph on
 java:import
\emph default
 creates a standard Genyris class, you are free to add, remove, update and
 delete methods of the class.
\end_layout

\begin_layout Subsection
Creating Instances of Java Objects
\end_layout

\begin_layout Standard
Once a class has been imported, it is then possible to call the constructors
 from the Genyris class.
 The constructor returns a new instance wrapped in a
\emph on
 JavaWrapper
\emph default
 object.
 For example:
\end_layout

\begin_layout LyX-Code
> java:import 'java.io.File' as FileJ
\end_layout

\begin_layout LyX-Code
> var file (FileJ(.new-java_lang_String '/'))
\end_layout

\begin_layout LyX-Code
[java.io.File /] # java_io_File JavaWrapper
\end_layout

\begin_layout Standard
A call to a Java method involves several steps:
\end_layout

\begin_layout Itemize
The arguments are converted to the closest Java type if possible, if a
\emph on
 JavaWrapper
\emph default
 is provided, the embedded Java Object is used.
\end_layout

\begin_layout Itemize
The method is called, and exceptions caught
\end_layout

\begin_layout Itemize
The return value is converted to a Genyris type if possible, otherwise the
 return value is placed in a
\emph on
 JavaWrapper
\emph default
 object.
\end_layout

\begin_layout Itemize
Returned
\emph on
 JavaWrapper
\emph default
 objects are tagged with the relevant Genyris Java class if it has already
 been imported.
\end_layout

\begin_layout Subsection
Accessing Fields
\end_layout

\begin_layout Standard
Java objects are contained within
\emph on
 JavaWrapper
\emph default
 objects.
 When used as a function the the wrapper allows access to the fields of
 the Java objects using the dynamic symbol approach used for all other Genyris
 objects.
 In the above example we can list the Java fields with:
\end_layout

\begin_layout LyX-Code
> file!vars
\end_layout

\begin_layout LyX-Code
(.separatorChar .separator .pathSeparatorChar .pathSeparator
\end_layout

\begin_layout LyX-Code
.self .vars .classes .http://www.genyris.org/lang/java#class)
\end_layout

\begin_layout LyX-Code
# Pair
\end_layout

\begin_layout Standard
The special field 
\emph on
java:class
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
java:class
\end_layout

\end_inset


\emph default
 provides the real Java class of the object.
\end_layout

\begin_layout LyX-Code
> file!java:class
\end_layout

\begin_layout LyX-Code
'java.io.File' # String
\end_layout

\begin_layout Standard
Read access to the fields is the same as for Dictionaries for example:
\end_layout

\begin_layout LyX-Code
> file!separator
\end_layout

\begin_layout LyX-Code
'/' # String
\end_layout

\begin_layout Standard
Write access is provided with
\emph on
 setq
\emph default
 as usual, however Java restrictions still apply:
\end_layout

\begin_layout LyX-Code
> file(setq .separator ';')
\end_layout

\begin_layout LyX-Code
*** Error - 'Can not set static final java.lang.String field
\begin_inset Newline newline
\end_inset

 java.io.File.separator to java.lang.String'
\end_layout

\begin_layout Subsection
Calling Methods
\end_layout

\begin_layout Standard
Calling Java method is identical to calling Genyris methods.
 Java static methods are treated the same as Genyris functions, in that
 they do not require a dynamic environment with
\emph on
 .self
\emph default
 bound.
 Java methods must be called within the context of a
\emph on
 JavaWrapper
\emph default
 object.
 Continuing with an example to list the files in a directory:
\end_layout

\begin_layout LyX-Code
> file(.list)
\end_layout

\begin_layout LyX-Code
('sys' 'srv' 'vmlinuz' 'selinux' ...
\end_layout

\begin_layout Standard
Notice that the Java
\emph on
 list()
\emph default
 method returns an array of
\emph on
 String
\emph default
, which is automatically converted into a list of Genyris strings.
\end_layout

\begin_layout Standard
Parameters are passed as usual, however basic types are automatically converted
 to Java objects if possible.
 Refer to the table below for details.
 For example:
\end_layout

\begin_layout LyX-Code
> file(.compareTo-java_lang_Object file)
\end_layout

\begin_layout LyX-Code
0 # Bignum
\end_layout

\begin_layout Subsection
Conversions and Coersion
\end_layout

\begin_layout Standard
The following table lists the conversions of base types in method calls,
 constructor calls and in fields accesses.:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Java
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Genyris
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
short
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BigDecimal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
boolean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NIL or true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
java.awt.event.ActionListener
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<- Function Closure
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
other
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JavaWrapper
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
java.io.Reader
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reader
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Conversion To Java Objects
\end_layout

\begin_layout Standard
The conversion of Genyris atoms and lists implicit in the calling of methods
 can be used explicitly with the
\emph on
 java:toJava
\emph default
 function.
 This takes two arguments, a string containing the name of a Java class
 and a Genyris object to be converted.
 The java class naming convention is is used for arrays.
 For example to convert a list of Bignums into a Java array of Integer:
\end_layout

\begin_layout LyX-Code
> java:import  '[Ljava.lang.Integer;'
\end_layout

\begin_layout LyX-Code
> java:toJava '[Ljava.lang.Integer;' ^(1 2 3)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
[[Ljava.lang.Integer; [Ljava.lang.Integer;@148aa23] 
\begin_inset Newline newline
\end_inset

# *Ljava_lang_Integer; JavaWrapper
\end_layout

\begin_layout Standard
Note that since we imported the class
\emph on
 [Ljava.lang.Integer;
\emph default
 the conversion automatically tags the
\emph on
 JavaWrapper
\emph default
 with that class.
\end_layout

\begin_layout Subsubsection
Conversion from Java To Genyris Objects
\end_layout

\begin_layout Standard
Basic Java objects are converted into Genyris objects in a straightforward
 manner.
 These conversions implicit on the return from Java method calls can be
 called explicitly using the
\emph on
 java:toGenyris
\emph default
 function, which takes a single argument.
 For example here we convert a list of bignums to a Java array of Integer
 and back:
\end_layout

\begin_layout LyX-Code
> var y     java:toJava '[Ljava.lang.Integer;' ^(1 2 3)
\end_layout

\begin_layout LyX-Code
[[Ljava.lang.Integer; [Ljava.lang.Integer;@2087c268] # JavaWrapper
\end_layout

\begin_layout LyX-Code
> java:toGenyris y
\end_layout

\begin_layout LyX-Code
(1 2 3) # Pair
\end_layout

\begin_layout Subsection
Using Java Reflection from Genyris
\end_layout

\begin_layout Standard
Java Reflection methods can be called (just like any other Java interface)
 to get more detailed information about the Java world.
 Here is an example which lists every method of
\emph on
 java.lang.class
\emph default
 in detail:
\end_layout

\begin_layout LyX-Code
> var c
\end_layout

\begin_layout LyX-Code
  java_lang_Class
\end_layout

\begin_layout LyX-Code
      .forName-java_lang_String 'java.lang.Class'
\end_layout

\begin_layout LyX-Code
[java.lang.Class class java.lang.Class] # java_lang_Class JavaWrapper
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> for m in (c(.getMethods)) (print m)
\end_layout

\begin_layout LyX-Code
[java.lang.reflect.Method public static java.lang.Class java.lang.Class.forName(java.lang.
String) throws java.lang.ClassNotFoundException]
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout Subsection
Hooking Swing Events in Genyris
\end_layout

\begin_layout Standard
Swing programs can be written in Genyris using the FFI descibed here.
 All the Swing classes can be accessed as usual, however there is one special
 case - handling of events from Swing.
 When Swing has an event to process (typically from a user action such as
 a mouse click) it needs to call a Genyris function.
 The Genyris
\emph on
 java:actionListener
\emph default
 function creates a bridging object that holds a closure which can be called
 later by Swing.
 The syntax is:
\end_layout

\begin_layout LyX-Code
java:actionListener <closure>
\end_layout

\begin_layout Standard
Either lazy or eager procedures can be used in the closure parameter.
 Here's an example:
\end_layout

\begin_layout LyX-Code
def onCancel(event)
\end_layout

\begin_layout LyX-Code
    window(.dispose)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
cancelButton
\begin_inset Newline newline
\end_inset

   .addActionListener-java_awt_event_ActionListener
\begin_inset Newline newline
\end_inset

         java:actionListener onCancel
\end_layout

\begin_layout Standard
Here we have supplied an ActionListener to a Button object.
 The action listener saves the closure created by the
\emph on
 def
\emph default
.
 When the user presses the button the onCancel function is called.
 Notice how the closure captures the
\emph on
 window
\emph default
 binding.
\end_layout

\begin_layout Standard
Refer to the source file '
\emph on
examples/swing.g
\emph default
' for a complete example which looks like this:
\end_layout

\begin_layout Quotation
\begin_inset Graphics
	filename swing.jpg

\end_inset


\end_layout

\begin_layout Subsection
Plotting 2D Figures on a Swing Canvas
\end_layout

\begin_layout Standard
Sometimes it's useful to be able to draw shapes and place images on a simple
 canvas.
 The supplied examples include
\emph on
 swing-canvas.g
\emph default
 which draws a red oval onto the frame:
\end_layout

\begin_layout Quotation
\begin_inset Graphics
	filename redOval.jpg
	scale 50

\end_inset


\end_layout

\begin_layout Standard
To allow the frame to be re-painted when it is moved about or re-sized,
 a special Java class is provided which allows the
\emph on
 paintComponent()
\emph default
 to be executed in Genyris.
 Instead of using the
\emph on
 JPanel
\emph default
 component, one uses a
\emph on
 GPanel
\emph default
 component, supplying a closure as an argument.
 The closure is executed by Swing when it needs the frame to be re-drawn.
 Let's review code.
\end_layout

\begin_layout Standard
First a callback function is defined which takes three parameters, a
\emph on
 Graphics
\emph default
 object (where drawing is done) and and a string:
\end_layout

\begin_layout LyX-Code
java:import 'java.awt.Graphics' as Graphics
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def paint(graphics id command)
\end_layout

\begin_layout LyX-Code
  tag Graphics graphics # set up the methods
\end_layout

\begin_layout LyX-Code
  cond
\end_layout

\begin_layout LyX-Code
     graphics # did we get an object?
\end_layout

\begin_layout LyX-Code
         graphics   # ok , draw on it
\end_layout

\begin_layout LyX-Code
             .drawLine-int-int-int-int 0 0 100 100
\end_layout

\begin_layout Standard
Next the special
\emph on
 GPanel
\emph default
 is created.
 The constructor expects a Genyris closure object:
\end_layout

\begin_layout LyX-Code
java:import 'org.genyris.java.swing.GPanel' as GPanel
\end_layout

\begin_layout LyX-Code
var panel
\end_layout

\begin_layout LyX-Code
  GPanel
\end_layout

\begin_layout LyX-Code
   .new-org_genyris_interp_AbstractClosure paint
\end_layout

\begin_layout Standard
Finally the GPanel is added to a frame:
\end_layout

\begin_layout LyX-Code
frame
\end_layout

\begin_layout LyX-Code
    .add-java_awt_Component panel
\end_layout

\begin_layout LyX-Code
    .setVisible-boolean true
\end_layout

\begin_layout Standard
This approach of adding a Java class can be used wherever a
\emph on
 paintComponent
\emph default
 callback is required.
 The Java code is minimal:
\end_layout

\begin_layout LyX-Code
public class GPanel extends JPanel {
\end_layout

\begin_layout LyX-Code
    private static final long serialVersionUID = 1L;
\end_layout

\begin_layout LyX-Code
    private AbstractClosure repaint;
\end_layout

\begin_layout LyX-Code
    public GPanel(AbstractClosure closure) {
\end_layout

\begin_layout LyX-Code
        super();
\end_layout

\begin_layout LyX-Code
        repaint = closure;
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    public void paintComponent(Graphics g) {
\end_layout

\begin_layout LyX-Code
        if (repaint != null) {
\end_layout

\begin_layout LyX-Code
            Exp args[] = {
\end_layout

\begin_layout LyX-Code
               JavaUtils.wrapJavaObject(repaint.getEnv(), g)
\end_layout

\begin_layout LyX-Code
            };
\end_layout

\begin_layout LyX-Code
            try {
\end_layout

\begin_layout LyX-Code
               repaint.applyFunction(repaint.getEnv(), args);
\end_layout

\begin_layout LyX-Code
            } catch (GenyrisException e) {
\end_layout

\begin_layout LyX-Code
                e.printStackTrace();
\end_layout

\begin_layout LyX-Code
            }
\end_layout

\begin_layout LyX-Code
        }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
Limitations
\end_layout

\begin_layout Standard
The following limitations exist which may be removed in later versions:
\end_layout

\begin_layout Itemize
Genuine methods called '
\emph on
new
\emph default
' may clash with constructors.
\end_layout

\begin_layout Itemize
There may be name collisions between Genyris and Java.
 e.g.
 a Java method called
\emph on
 foo-org_bar_Class()
\emph default
 would clash with a Java method
\emph on
 foo(org.bar.Class c).
\end_layout

\begin_layout Itemize
Java Readers and Writers are not converted to Genyris streams.
\end_layout

\begin_layout Itemize
The Java class hierarchy is not duplicated in the imported Genyris classes
 since the method list is a closure over the superclasses of a class.
\end_layout

\begin_layout Itemize
There is no universal facility for allowing Java programs to call back Genyris
 functions, only
\emph on
 java.awt.event.ActionListener
\emph default
 is supported.
\end_layout

\begin_layout Section
For Maintainers
\end_layout

\begin_layout Standard
This section is for those wishing to compile Genyris from scratch for modificati
on or who are maintaining the source.
 
\end_layout

\begin_layout Subsection
Versioning Numbering
\end_layout

\begin_layout Standard
This section describes the version numbering approach used for Genyris documenta
tion, source and official executables.
 Maintainers of the official fork use the approach described here.
 
\end_layout

\begin_layout Subsubsection
Source Versioning
\end_layout

\begin_layout Standard
The source artefacts are managed in the default branch of the master Mercurial
 repository.
 Every change results in a new revision of the entire source repository.
 Refer to Mercurial documentation for details.
 The Mercurial repository version is the definitive version identification
 for the source and takes the form of a hexadecimal string.
 e.g.
 
\emph on
29e9e58f4025.
 
\emph default
Maintainers make commits to the repository for each refactoring or small
 change.
 Best endeavours are made to ensure all repository versions pass all tests
 and are complete and consistent, however this is not guaranteed.
 Working changes are 
\emph on
untagged
\emph default
 and precede formal releases.
\end_layout

\begin_layout Subsubsection
Release Versioning
\end_layout

\begin_layout Standard
Mercurial tags are used to mark particular versioned baselines of complete,
 consistent, documented and tested source artefacts.
 All formal releases are tagged with a version number tag.
 Once a versioned package has been tagged with a release version, the contents
 of that release are not modified.
 The Mercurial version number tags have the following syntax:
\end_layout

\begin_layout LyX-Code
X.Y.Z[.state]
\end_layout

\begin_layout Standard
Where : X,Y and Z are integers which increase monotonically.
 For instance: 1.9.0 < 1.10.0 < 1.11.0 and where:
\end_layout

\begin_layout Description
X is the major version number.
 All source releases with the same major version number are compatible,
 that is code written for one minor release will work on all other lesser
 releases.
 Major version zero (0.Y.Z) is for initial development and anything may change
 at any time.
 The language specification 0.Y.X should not be considered stable.
 Version 1.0.0 defines the initial public language specification.
 Major version X (X.y.z | X > 0) is incremented if any backwards incompatible
 changes are introduced to the language.
 It may include minor and fix level changes.
\end_layout

\begin_layout Description
Y is the minor version number Y (x.Y.z | x > 0) and is incremented if new,
 backwards compatible functionality is introduced to the language.
 It may be incremented if substantial new functionality or improvements
 are introduced within the private code.
 It may include fix level changes.
\end_layout

\begin_layout Description
Z Is the fix version number Z (x.y.Z | x > 0) and is incremented if bug fixes
 are introduced.
 A bug fix is defined as an implementation change that fixes divergence
 between the documentation and the implementation.
 In practice a bug fix is not 
\emph on
strictly
\emph default
 backward compatible, since applications may rely on the buggy behaviour.
 Fix versions include minor (cosmetic) corrections of documentation.
\end_layout

\begin_layout Description
state provides for special versions.
 A special version number is denoted by appending an arbitrary string immediatel
y following the fix version.
 The string is comprised of only alphanumerics plus dash [0-9A-Za-z-] and
 begins with an alpha character [A-Za-z].
 Special versions satisfy but have a lower precedence than the associated
 normal version.
 Precedence is determined by lexicographic ASCII sort order.
 For instance: 1.0.0beta1 < 1.0.0beta2 < 1.0.0.
\end_layout

\begin_layout Description
Specification_Version The Java 
\emph on
Specification Version
\emph default
 consists of the 
\emph on
Major
\emph default
 and 
\emph on
Minor
\emph default
 source version numbers.
 
\end_layout

\begin_layout Subsubsection
Source Branching
\end_layout

\begin_layout Standard
Anonymous source branches are created by maintainers for a variety of reasons
 and are merged into the master repository.
 In very exceptional circumstances tagged source branches may be created
 for maintenance of older versions by branching from the prior release.
 For example if a defect is found in release 1.1.2 whilst the latest release
 is 1.2.0 a branch may be created from 1.1.2 for the fix and released as 1.1.2fix1.
\end_layout

\begin_layout Subsubsection
Version Information in Executables
\end_layout

\begin_layout Standard
Genyris follows the Java product versioning standard
\begin_inset Foot
status open

\begin_layout Plain Layout
http://download.oracle.com/javase/1.4.2/docs/guide/versioning/spec/versioning2.html
\end_layout

\end_inset

, versioning information is available in the jar files in the following
 manifest fields:
\end_layout

\begin_layout Description
Specification-Version This field includes the Major and Minor version numbers.
 Example: 0.6
\end_layout

\begin_layout Description
Implementation-Version This field includes the Major, Minor and Fix numbers
 with identification of the build job which generated the executable.
 Example: 0.6.1-b164
\end_layout

\begin_layout Standard
Intermediate, untagged builds contain the repository version of the workspace.
 Example: 
\emph on
tip-789-d242ce4255c0-b165
\end_layout

\begin_layout Subsubsection
Obtaining Version Information at Runtime
\end_layout

\begin_layout Standard
The current version number of the Genyris interpreter is recorded in the
 Genyris jar file manifest.
 This can be accessed via the Java
\emph on
 Package
\emph default
 interface.
 Simplified access is provided in the
\emph on
 versioninfo
\emph default
 module.
 Example:
\end_layout

\begin_layout LyX-Code
import versioninfo
\end_layout

\begin_layout LyX-Code
print versioninfo
\end_layout

\begin_layout Subsection
Building From Source
\end_layout

\begin_layout Subsubsection
Obtaining source from the Mercurial Repository
\end_layout

\begin_layout Standard
The source code of Genyris is published to a Mercurial clone hosted by SourceFor
ge.
 This code will be the latest code, whereas the binary releases are slightly
 older.
 To access the default Mercurial repository, get a local copy of the genyris
 repository with this command: 
\end_layout

\begin_layout LyX-Code
hg clone https://genyris.googlecode.com/hg/ genyris 
\end_layout

\begin_layout Standard
Then 
\emph on
hg pull
\emph default
 to download source updates.
\end_layout

\begin_layout Subsubsection
The Build
\end_layout

\begin_layout Standard
To compile from source you need install
\emph on
Ant
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Ant
\end_layout

\end_inset


\emph default
 (version 1.7.1 or later).
 Change directory to the root of the unpacked directory.
 Then run the following command to build the program:
\end_layout

\begin_layout LyX-Code
$ ant
\end_layout

\begin_layout Standard
At the end of the build you should see a summary of tests passed and '
\emph on
BUILD SUCCESSFUL
\emph default
':
\end_layout

\begin_layout LyX-Code
     [exec] Total # Test Files: 57
\end_layout

\begin_layout LyX-Code
     [exec] Total # gunit Tests: 21
\end_layout

\begin_layout LyX-Code
     [exec] Total # of failed test files: 0
\end_layout

\begin_layout LyX-Code
     [exec] Total # gunit tests Failed 0
\end_layout

\begin_layout LyX-Code
     [exec] Total # of JUnit tests: 212
\end_layout

\begin_layout LyX-Code
     [exec] Total # of JUnit errors: 0
\end_layout

\begin_layout LyX-Code
test:
\end_layout

\begin_layout LyX-Code
all:
\end_layout

\begin_layout LyX-Code
BUILD SUCCESSFUL
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
The output jar files and release files are to be found in the 
\emph on
dist
\emph default
 and 
\emph on
rel
\emph default
 directories.
\end_layout

\begin_layout Paragraph
Release Automation
\end_layout

\begin_layout Standard
To build a new release make a new tag e.g.
 tag 0.6.2 and update a build repository clone to the tag.
 e.g.
\end_layout

\begin_layout LyX-Code
hg update -r 0.6.2 --clean
\end_layout

\begin_layout Standard
Then use the ant target 
\emph on
release.
 
\end_layout

\begin_layout Subsection
Reflection
\end_layout

\begin_layout Subsubsection

\emph on
symlist
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
symlist
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection

\emph on
sys:self-test
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
sys:self-test
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection
Extending and Modifying Genyris
\end_layout

\begin_layout Subsubsection
Adding Builtin Java Functions to Core Genyris Classes
\end_layout

\begin_layout Standard
All Genyris functions are implemented as normal Java classes.
 This includes the core classes for data such as Bignum, String etc.
 For example the Bignum objects are internally implemented as Java BigDecimals.
 Existing Java functionality for the internal representation can be used
 via the Java interface.
 It suffices to define a Genyris function or method which accesses the internal
 object via a reference.
 Consider:
\end_layout

\begin_layout LyX-Code
> java:import 'java.math.BigDecimal'
\end_layout

\begin_layout LyX-Code
> java:toJava 'java.math.BigDecimal' 123
\end_layout

\begin_layout LyX-Code
[java.math.BigDecimal 123] # java_math_BigDecimal
\end_layout

\begin_layout LyX-Code
                                  JavaWrapper
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
This expression
\emph on
 (java:toJava 'java.math.BigDecimal' 123)
\emph default
 obtains a reference to the internal BigDecimal object, which is in turn
 wrapped in a
\emph on
 JavaWrapper
\emph default
object and tagged with the
\emph on
 java_math_BigDecimal
\emph default
 class.
 This allows direct access to the underlying object via its methods.
\end_layout

\begin_layout Standard
Here is a Genyris method which returns the precision of a Bignum:
\end_layout

\begin_layout LyX-Code
> Bignum
\end_layout

\begin_layout LyX-Code
    def .precision()
\end_layout

\begin_layout LyX-Code
        (java:toJava 'java.math.BigDecimal' .self)
\end_layout

\begin_layout LyX-Code
             .precision
\end_layout

\begin_layout LyX-Code
> 2134(.precision)
\end_layout

\begin_layout LyX-Code
4 # Bignum
\end_layout

\begin_layout Standard
Here is another example, character replacement method for all strings:
\end_layout

\begin_layout LyX-Code
String
\end_layout

\begin_layout LyX-Code
    def .replace(old new)
\end_layout

\begin_layout LyX-Code
        (java:toJava 'java.lang.String' .self)
\end_layout

\begin_layout LyX-Code
               .replace-char-char old new
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> "Shop"(.replace 'p' 'e')
\end_layout

\begin_layout LyX-Code
'Shoe' # String
\end_layout

\begin_layout Part
Libraries
\end_layout

\begin_layout Standard
Genyris is, like Scheme, a small language which allows users to develop
 their own paradigms and languages.
 Since Genyris has access to Java classes via
\emph on
 java:import
\emph default
 a programmer can readily create their own data types, I/O libraries and
 so on.
 Hence the libraries provided with Genyris documented here are not a mandatory
 part of a Genyris implementation and their interfaces may change over time
 without changing the core language.
 The main emphasis is to provide common data types and functions useful
 for every-day scripting in a manner that fits well with the unique Genyris
 classification paradigm and its not-so-unique syntax.
\end_layout

\begin_layout Section
ListOfLines
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Section
System
\begin_inset Index
status open

\begin_layout Plain Layout
System
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The System module allows interaction with the interpreter itself.
\end_layout

\begin_layout Subsection
.exit
\begin_inset Index
status open

\begin_layout Plain Layout
.exit
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Syntax: 
\end_layout

\begin_layout LyX-Code
System!exit <process return>
\end_layout

\begin_layout Standard
This function requests the interpreter to terminate all threads and exit
 the operating system process.
 The single parameter is an integer value which the operating system returns
 as the process status.
\end_layout

\begin_layout Subsection
.HOME
\begin_inset Index
status open

\begin_layout Plain Layout
.HOME
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This variable supplies the home directory of the interpreter installation.
 This will be the same as the 
\emph on
GENYRIS_HOME
\emph default
 environment variable.
\end_layout

\begin_layout Subsection
.LIBS
\end_layout

\begin_layout Standard
This variable supplies the directory of the interpreter's genyris library
 code.
 Normally set to 
\emph on
GENYRIS_HOME/libs
\emph default
.
\end_layout

\begin_layout Section

\emph on
os
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
os
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This module contains variables and functions that allow interaction with
 the Java VM and the operating system (os).
\end_layout

\begin_layout Subsection
.getProperties
\begin_inset Index
status open

\begin_layout Plain Layout
.getProperties
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function supplies the current java properties as a dictionary.
 
\end_layout

\begin_layout Subsubsection*
Example:
\end_layout

\begin_layout LyX-Code
> os!getProperties
\end_layout

\begin_layout LyX-Code
(dict (.|awt.toolkit| = 'sun.awt.windows.WToolkit') (.|file.encoding| = 'Cp1252')
 (.|file.encoding.pkg| = 'sun.io') .....
\end_layout

\begin_layout Subsection

\emph on
.exec
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.exec
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection

\emph on
.getenv
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.getenv
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsection
.
\emph on
spawn
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
.spawn
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function starts an operating system process and returns immediately
 without waiting for the outcome.
 The function returns an object of type 
\emph on
Process
\emph default
 (see below), or an exception is raised.
\end_layout

\begin_layout Standard
Example - Here we spawn a Windows command shell with a one-line echo statement.
 The parent process obtains the output from the process and copies it to
 the standard output.:
\end_layout

\begin_layout LyX-Code
> var proc
\end_layout

\begin_layout LyX-Code
   os!spawn 'cmd.exe' '/c' 'echo' =
\end_layout

\begin_layout LyX-Code
          'Testing one two three'
\end_layout

\begin_layout LyX-Code
[java.lang.ProcessImpl java.lang.ProcessImpl@12d3205] 
\end_layout

\begin_layout LyX-Code
# java_lang_Process JavaWrapper
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
Class Process
\end_layout

\begin_layout Standard
This process is a JavaWrapper for the Java 
\emph on
java.lang.Process
\emph default
 class.
 The java methods include:
\end_layout

\begin_layout Description
.destroy Kills the subprocess.
\end_layout

\begin_layout Description
.exitValue Returns the exit value for the subprocess.
\end_layout

\begin_layout Description
.getErrorStream Gets the error stream of the subprocess.
\end_layout

\begin_layout Description
.getInputStream Gets the input stream of the subprocess.
\end_layout

\begin_layout Description
.getOutputStream Gets the output stream of the subprocess.
\end_layout

\begin_layout Description
.waitFor causes the current thread to wait, if necessary, until the process
 represented by this Process object has terminated.
\end_layout

\begin_layout Standard
Additional Genyris utility methods are defined:
\end_layout

\begin_layout Description
.getOutput returns a Genyris Reader object that can be used to read or parse
 the output of the process.
\end_layout

\begin_layout Description
.getError returns a Genyris Reader object that can be used to read or parse
 the error stream output of the process.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
> proc    
\end_layout

\begin_layout LyX-Code
   (.getOutput)
\end_layout

\begin_layout LyX-Code
       .copy stdout
\end_layout

\begin_layout LyX-Code
"Testing one two three"
\end_layout

\begin_layout LyX-Code
nil # NilSymbol SimpleSymbol 
\end_layout

\begin_layout LyX-Code
> proc
\end_layout

\begin_layout LyX-Code
   .exitValue
\end_layout

\begin_layout LyX-Code
0 # Bignum 
\end_layout

\begin_layout Section
Time and Date
\end_layout

\begin_layout Subsection

\emph on
os!ticks
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
os!ticks
\end_layout

\end_inset


\emph default
 - Current system time in milliseconds since the epoch
\end_layout

\begin_layout LyX-Code
> os!ticks
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
1266995579117 # Bignum
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> format-date 0 "dd MMM yyyy HH:mm:ss Z" 'GMT'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
'01 Jan 1970 00:00:00 +0000' # String
\end_layout

\begin_layout Subsection

\emph on
now
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
now
\end_layout

\end_inset


\emph default
 - Current system time in milliseconds since the epoch
\end_layout

\begin_layout Standard
An alias for
\emph on
os!ticks
\emph default
.
\end_layout

\begin_layout Subsection

\emph on
format-date
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
format-date
\end_layout

\end_inset


\emph default
 <epoch milliseconds> <format String> <timezone>
\end_layout

\begin_layout Standard
For example:
\end_layout

\begin_layout LyX-Code
> format-date (os!ticks) "dd MMM yyyy HH:mm:ss z" "Australia/Melbourne"
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
'24 Feb 2010 18:11:41 EST' # String
\end_layout

\begin_layout Subsection

\emph on
calendar
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
calendar
\end_layout

\end_inset


\emph default
 <epoch milliseconds> <timezone>
\end_layout

\begin_layout Standard
Returns a Calendar (dictionary) with the following properties:
\end_layout

\begin_layout Description
.am-pm = symbol indicating AM or PM
\end_layout

\begin_layout Description
.day-of-month = Integer day of the month starting with 1.
\end_layout

\begin_layout Description
.day-of-week = Integer day of the week starting with Sunday which is 1.
\end_layout

\begin_layout Description
.day-of-week-in-month = Ordinal number of the day of the week within the
 current month.
\end_layout

\begin_layout Description
.day-of-year = The day number within the current year starting with 1.
\end_layout

\begin_layout Description
.dst-offset = Daylight savings offset in milliseconds
\end_layout

\begin_layout Description
.era = symbol AD or BC
\end_layout

\begin_layout Description
.hour = Hour of the day (12 hour clock)
\end_layout

\begin_layout Description
.hour-of-day = Hour of the day (24 hour clock)
\end_layout

\begin_layout Description
.millisecond = e.g.
 93
\end_layout

\begin_layout Description
.minute = e.g.
 2
\end_layout

\begin_layout Description
.month = Integer month starting with January, which is 0
\end_layout

\begin_layout Description
.second = e.g.
 42
\end_layout

\begin_layout Description
.week-of-month = Week in the month starting from 1.
\end_layout

\begin_layout Description
.week-of-year = Week number in the year starting from 1.
\end_layout

\begin_layout Description
.year = e.g.
 2010
\end_layout

\begin_layout Description
.zone-offset = Timezone offset in milliseconds from GMT
\end_layout

\begin_layout Standard
For example:
\end_layout

\begin_layout LyX-Code
> print (calendar (os!ticks))
\end_layout

\begin_layout LyX-Code
dict (.am-pm = pm)
\end_layout

\begin_layout LyX-Code
.day-of-month = 10
\end_layout

\begin_layout LyX-Code
.day-of-week = 4
\end_layout

\begin_layout LyX-Code
.day-of-week-in-month = 2
\end_layout

\begin_layout LyX-Code
.day-of-year = 69
\end_layout

\begin_layout LyX-Code
.dst-offset = 1
\end_layout

\begin_layout LyX-Code
.era = AD
\end_layout

\begin_layout LyX-Code
.hour = 10
\end_layout

\begin_layout LyX-Code
.hour-of-day = 22
\end_layout

\begin_layout LyX-Code
.millisecond = 93
\end_layout

\begin_layout LyX-Code
.minute = 2
\end_layout

\begin_layout LyX-Code
.month = 2
\end_layout

\begin_layout LyX-Code
.second = 42
\end_layout

\begin_layout LyX-Code
.week-of-month = 2
\end_layout

\begin_layout LyX-Code
.week-of-year = 11
\end_layout

\begin_layout LyX-Code
.year = 2010
\end_layout

\begin_layout LyX-Code
.zone-offset = 10
\end_layout

\begin_layout Section
Comma-Separated-Value Files
\end_layout

\begin_layout Standard
The builtin
\emph on
 CSV
\emph default
 class is provided for reading data from CSV files.
\end_layout

\begin_layout Subsection
.read <InStream> field-separator quote-char
\end_layout

\begin_layout Standard
The CSV class has a single static method
\emph on
 .read
\emph default
 which takes an input stream as it's first parameter.
 Despite the name CSV files can come in a variety of formats, hence the
 method expects the field-seperator character and field quote character
 as parameters.
\end_layout

\begin_layout Standard
The result is a list of rows.
 Each row is itself a list of the fields parsed.
 Example: Read a comma-delimited file:
\end_layout

\begin_layout LyX-Code
CSV
\end_layout

\begin_layout LyX-Code
   .read ((File(.new 'my file')) (.open ^read)) ',' '
\begin_inset Quotes erd
\end_inset

'
\end_layout

\begin_layout Section
Sound
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
.play
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Part*
Index
\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex

\end_inset


\end_layout

\end_body
\end_document
