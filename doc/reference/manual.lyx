#LyX 1.6.4 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Genyris User Manual
\end_layout

\begin_layout Standard
\align center
Build 670
\end_layout

\begin_layout Standard
\align center
Peter William Birch
\end_layout

\begin_layout Standard
\noindent
\align center
birchb@genyris.org
\end_layout

\begin_layout Abstract
This document is the user manual for the Genyris scripting language.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Paragraph*
Conventions used in this document:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\emph on
italicized 
\emph default
Snippets of Genyris programs
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
fixed-font
\family default
 Larger programs are in a fixed font.
 Interactive sessions are show with the 
\family typewriter
>
\family default
 prompt of the command-line interpreter and the results printed underneath.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Tutorial
\end_layout

\begin_layout Section
Getting Started
\end_layout

\begin_layout Subsection*
Getting Genyris
\end_layout

\begin_layout Standard
Genyris can be downloaded from the sourceforge project 
\begin_inset Quotes eld
\end_inset

Download
\begin_inset Index
status open

\begin_layout Plain Layout
Download
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 pages as a binary release.
 The project is hosted here: 
\emph on
http://sourceforge.net/projects/genyris/.
\end_layout

\begin_layout Subsection*
Installation
\end_layout

\begin_layout Standard
Genyris is available as a 
\emph on
ZIP
\emph default
 file.
 This file needs to be unpacked into an empty directory such as 
\begin_inset Quotes eld
\end_inset

genyris
\begin_inset Quotes erd
\end_inset

.
 This becomes the home directory for Genyris.
 
\end_layout

\begin_layout Standard
Genyris is developed in Java hence needs a Java runtime.
 You don't need to understand Java to use Genyris.
 However you will need the Java 1.6 JRE
\begin_inset Index
status open

\begin_layout Plain Layout
JRE
\end_layout

\end_inset

 or later to run the Genyris interpreter.
 Java can be downloaded from Sun Microsystems.
 Check your JRE version with this command:
\end_layout

\begin_layout LyX-Code
$ 
\series bold
java -version
\end_layout

\begin_layout Standard
First change directory to the genyris home, then you can start the Genyris
 command-line interpreter with this command: 
\end_layout

\begin_layout LyX-Code
$ 
\series bold
java -jar dist/genyris-bin-nnn-xxxxxxxxx.jar
\end_layout

\begin_layout Standard
Where 
\emph on
nnn-xxxxxxxxx
\emph default
 is the version number.
 You will see a prompt indicating the interpreter is ready for your input:
\end_layout

\begin_layout LyX-Code
*** Genyris is listening...
\end_layout

\begin_layout LyX-Code
>
\end_layout

\begin_layout Standard
Refer to section 
\begin_inset CommandInset ref
LatexCommand eqref
reference "sec:Running-Genyris"

\end_inset

 for details on how to simplify running Genyris using PATH settings.
\end_layout

\begin_layout Subsection*
Executing Expressions
\end_layout

\begin_layout Standard
Genyris commands can now be typed at the prompt, use two carriage returns
 (
\begin_inset Formula $\hookleftarrow$
\end_inset

) to terminate a statement.
 For example to add two numbers type:
\end_layout

\begin_layout LyX-Code
> 
\series bold
+ 42 37 
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout Standard
Genyris responds with the answer and a comment about the result:
\end_layout

\begin_layout LyX-Code
~ 79 # Bignum
\end_layout

\begin_layout Subsection*
Verifying the Install
\end_layout

\begin_layout Standard
To test the installation run the self test suite with the following command:
\end_layout

\begin_layout LyX-Code
> 
\series bold
self-test-runner
\begin_inset Index
status open

\begin_layout Plain Layout

\series bold
self-test-runner
\end_layout

\end_inset


\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout Standard
All being well, it will print 
\begin_inset Quotes eld
\end_inset

OK
\begin_inset Quotes erd
\end_inset

 and the number of tests passed.
\end_layout

\begin_layout Subsection*
Running Examples
\end_layout

\begin_layout Standard
The release binary file includes some examples in the 
\emph on
examples
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
examples
\end_layout

\end_inset


\emph on
 
\emph default
folder.
 The files can be edited with your favourite text editor and run with the
 
\emph on
include
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
include
\end_layout

\end_inset

 function.
 For example, to load an run the 
\begin_inset Quotes eld
\end_inset

Eight Queens
\begin_inset Quotes erd
\end_inset

 example do:
\end_layout

\begin_layout LyX-Code
> 
\series bold
include 'examples/queens.g'
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 'file:/home/birchb/workspace/Genyris/examples/queens.g' # String 
\end_layout

\begin_layout LyX-Code
> 
\series bold
run-queens 8
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout Section
Syntax
\end_layout

\begin_layout Standard
The syntax of Genyris uses indentation to convey program structure.
 This is in common with other languages such as Python.
 However Genyris preserves the 
\begin_inset Quotes eld
\end_inset

prefix
\begin_inset Quotes erd
\end_inset

 notation of Lisp and Scheme.
 Here is an example of some code defining a function:
\end_layout

\begin_layout LyX-Code
def threat (i j a b)
\end_layout

\begin_layout LyX-Code
   or
\end_layout

\begin_layout LyX-Code
      equal? i a
\end_layout

\begin_layout LyX-Code
      equal? j b
\end_layout

\begin_layout LyX-Code
      equal? (- i j) (- a b)
\end_layout

\begin_layout LyX-Code
      equal? (+ i j) (+ a b)
\end_layout

\begin_layout Standard
Instead of curly braces or 
\emph on
begin
\emph default
 and 
\emph on
end
\emph default
 tokens, the indentation defines the blocks of code.
 Genyris reads lines one-by-one until it reaches the end of an expression.
 An expression ends when there are no more indented lines.
 The interactive command-line ends an expression whenever two blank lines
 are read.
 Within a line, tokens are separated by white-space.
 Genyris recognizes the following syntactic elements:
\end_layout

\begin_layout Itemize
Comments
\end_layout

\begin_layout Itemize
Numbers
\end_layout

\begin_layout Itemize
Strings
\end_layout

\begin_layout Itemize
Symbols
\end_layout

\begin_layout Itemize
Sub-expressions
\end_layout

\begin_layout Itemize
Lists (Pairs)
\end_layout

\begin_layout Itemize
Parser macros and directives
\end_layout

\begin_layout Subsection
Comments
\end_layout

\begin_layout Standard
All characters following a hash
\begin_inset Index
status open

\begin_layout Plain Layout
hash
\end_layout

\end_inset

 (pound) until the end of the line are ignored by the parser.
 For example:
\end_layout

\begin_layout LyX-Code

\series bold
# This whole line is a comment 
\end_layout

\begin_layout LyX-Code
- 4 3    
\series bold
# this comment goes to the end
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
Numbers
\end_layout

\begin_layout Standard
Numbers can be either integers or floating point with any number of leading
 or trailing digits.
 Examples:
\end_layout

\begin_layout LyX-Code
-3 23.78 -100.0089  34.45e7
\end_layout

\begin_layout Subsection
Strings
\end_layout

\begin_layout Standard
Strings are delimited by either double quote characters " or single quotes
 '.
 Within a string quotes and special characters are escaped with backslash
 
\backslash
.
 For example 
\family typewriter
\emph on
"She said 
\backslash
"sea shells
\backslash
"
\family default
\emph default
 "yields the string:
\end_layout

\begin_layout LyX-Code
She said "sea shells"
\end_layout

\begin_layout Standard
Other escape sequences are encoded as follows:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="bottom" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold

\backslash
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
New Line
\begin_inset Index
status open

\begin_layout Plain Layout
New Line
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold

\backslash
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Carriage Return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold

\backslash
f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Form Feed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold

\backslash

\backslash

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Backslash
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold

\backslash
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tab
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold

\backslash

\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quote
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold

\backslash
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bell
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The two styles of string are internally identical, which allows you to avoid
 escaping.
 For example this string contains double quotes:
\end_layout

\begin_layout LyX-Code
'"After all," said the young man, "golf
\begin_inset Index
status open

\begin_layout Plain Layout
golf
\end_layout

\end_inset

 is only a game."'
\end_layout

\begin_layout Subsection
Symbols
\end_layout

\begin_layout Standard
Symbols are a group of any printable characters with the following exceptions:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
,
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
comma
\begin_inset Index
status open

\begin_layout Plain Layout
comma
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
^
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
carat
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
period
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
single quote
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
"
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
double quote
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
`
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
backquote
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\series bold
@
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
at sign
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
square
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
brackets
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
curly
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
brackets
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal sign
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
exclamation
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The following are all examples of valid symbols:
\end_layout

\begin_layout LyX-Code
Wednesday-12
\end_layout

\begin_layout LyX-Code
_age
\end_layout

\begin_layout LyX-Code
*global*
\end_layout

\begin_layout LyX-Code
+$
\end_layout

\begin_layout LyX-Code
<variable-name>
\end_layout

\begin_layout Standard
In Genyris symbols are 
\begin_inset Quotes eld
\end_inset

interned
\begin_inset Quotes erd
\end_inset

 by the parser so that there is only ever one instance of a particular symbol.
 Symbols are case sensitive so for example 
\emph on
Kookaburra
\emph default
 and 
\emph on
kookaburra
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
kookaburra
\end_layout

\end_inset


\emph default
 are different symbols.
\end_layout

\begin_layout Subsection
Expressions and Sub-expressions
\end_layout

\begin_layout Standard
All Genyris expressions 
\begin_inset Index
status open

\begin_layout Plain Layout
expressions
\end_layout

\end_inset

are parsed and stored as linked-lists.
 A single line is converted into a single list.
 Sub-expressions are denoted in two ways, either within parentheses on a
 single line, or by an indented line.
 For example the following line contains two sub-expressions:
\end_layout

\begin_layout LyX-Code
Alpha (Beta Charlie) (Delta)
\end_layout

\begin_layout Standard
Sub-expressions made using parentheses must remain within a single line,
 they are not permitted to wrap.
 Indented lines are deemed to be sub-expressions of the superior, less indented,
 lines above.
 The above expression can be written in indented form as follows:
\end_layout

\begin_layout LyX-Code
Alpha
\end_layout

\begin_layout LyX-Code
   Beta Charlie
\end_layout

\begin_layout LyX-Code
   Delta
\end_layout

\begin_layout Standard
Indentations must line up with previous indentations
\begin_inset Index
status open

\begin_layout Plain Layout
indentation
\end_layout

\end_inset

 of the same level as follows (spaces indicated with periods):
\end_layout

\begin_layout LyX-Code
Alpha
\end_layout

\begin_layout LyX-Code
...Beta Charlie
\end_layout

\begin_layout LyX-Code
......Delta
\end_layout

\begin_layout LyX-Code
..
\series bold
.Beta
\series default
              # correct indentation
\end_layout

\begin_layout Standard
The parser is unable to cope with random indentation levels since it does
 not know what depth is required.
 The following example will generate an error:
\end_layout

\begin_layout LyX-Code
Alpha
\end_layout

\begin_layout LyX-Code
...Beta Charlie
\end_layout

\begin_layout LyX-Code
......Delta
\end_layout

\begin_layout LyX-Code
....
\series bold
Beta
\series default
              # *** ERROR
\end_layout

\begin_layout Subsection
Pairs
\begin_inset Index
status open

\begin_layout Plain Layout
Pairs
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Within Genyris lists are composed of pairs of references to objects
\begin_inset Foot
status open

\begin_layout Plain Layout
Lisp Cons
\begin_inset Index
status open

\begin_layout Plain Layout
Cons
\end_layout

\end_inset

 cells
\end_layout

\end_inset

.
 Pairs have two elements, the left
\begin_inset Index
status open

\begin_layout Plain Layout
left
\end_layout

\end_inset

 and right
\begin_inset Index
status open

\begin_layout Plain Layout
right
\end_layout

\end_inset

, which are references to other Genyris objects.
 The left and right halves of a 
\emph on
Pair
\emph default
 can be delimited with the equals = character, an infix operator.
 For example: 
\end_layout

\begin_layout LyX-Code
(1 =
\begin_inset Index
status open

\begin_layout Plain Layout
=
\end_layout

\end_inset

 2) 
\end_layout

\begin_layout Standard
denotes a 
\emph on
Pair
\emph default
 referring to the numbers 1 and 2.
 Genyris expressions are also composed of linked lists of
\emph on
 Pairs
\emph default
, hence the expression:
\end_layout

\begin_layout LyX-Code
(A B C D)
\end_layout

\begin_layout Standard
is shorthand for :
\end_layout

\begin_layout LyX-Code
(A = (B = (C = (D = nil))))
\end_layout

\begin_layout Standard
Lists
\begin_inset Index
status open

\begin_layout Plain Layout
Lists
\end_layout

\end_inset

 are terminated with the special symbol 
\emph on
nil
\emph default
.
 An indented expression can be expressed in terms of 
\emph on
Pairs
\emph default
.
 Consider:
\end_layout

\begin_layout LyX-Code
Alpha
\end_layout

\begin_layout LyX-Code
   Beta
\end_layout

\begin_layout Standard
This is the same as 
\end_layout

\begin_layout LyX-Code
(Alpha = ((Beta = nil) = nil))
\end_layout

\begin_layout Standard
Lists do not always have to be terminated with 
\emph on
nil
\emph default
 , the colon = operator can be used to squeeze one more object reference
 into the end of the list.
 For example the following list has 
\emph on
C
\emph default
 instead of 
\emph on
nil
\emph default
:
\end_layout

\begin_layout LyX-Code
(A B = C) 
\end_layout

\begin_layout Standard
New pairs can be created explicitly with the cons function which takes two
 parameters - the left and right parts of a new pair.:
\end_layout

\begin_layout LyX-Code
> cons
\begin_inset Index
status open

\begin_layout Plain Layout
cons
\end_layout

\end_inset

 123 456
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
123 = 456 # Pair
\end_layout

\begin_layout Subsection
Quoting and Special Parser Characters
\end_layout

\begin_layout Standard
Lists and atoms can be quoted in Genyris.
 Quoting is used to prevent execution of expressions.
 A single atom can be quoted within an expression
\begin_inset Foot
status open

\begin_layout Plain Layout

\emph on
list
\emph default
 is a function we will cover later.
 
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
      list
\begin_inset Index
status open

\begin_layout Plain Layout
list
\end_layout

\end_inset

 1 2 
\series bold
^a
\series default
 3 4    # evaluates to: (1 2 
\series bold
a
\series default
 3 4)
\end_layout

\begin_layout Standard
Carat characters are a shorthand notation to save typing.
 When the parser sees a carat, it collects the expression following and
 wraps it within a 
\emph on
quote
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
quote
\end_layout

\end_inset

 
\emph default
expression.
 So 
\emph on
^<exp> 
\emph default
becomes 
\emph on
(quote <exp>).
 
\emph default
When the 
\emph on
quote
\emph default
 function is evaluated it does not evaluate its argument.
 So the above expression is actually:
\end_layout

\begin_layout LyX-Code
      list  1 2 
\series bold
(quote a)
\series default
 3 4
\end_layout

\begin_layout Standard
Embedded lists can be quoted, in which case the embedded list is not evaluated:
\end_layout

\begin_layout LyX-Code
      func 1 2 
\series bold
^(x y z)
\series default
 3 4
\end_layout

\begin_layout Standard
If the quote falls at the beginning of the line, only the first element
 is quoted, not the entire line.
 So:
\end_layout

\begin_layout LyX-Code
      list 1 2
\end_layout

\begin_layout LyX-Code
          
\series bold
^x
\series default
 y z
\end_layout

\begin_layout Standard
is the same as:
\end_layout

\begin_layout LyX-Code
      list 1 2 (
\series bold
(quote x)
\series default
 y z)
\end_layout

\begin_layout Standard
To allow entire sub-trees to be quoted, the quote function needs to be used
 as in this example:
\end_layout

\begin_layout LyX-Code
      list 1 2
\end_layout

\begin_layout LyX-Code
         
\series bold
quote
\end_layout

\begin_layout LyX-Code
            x y z
\end_layout

\begin_layout Standard
which is the same as:
\end_layout

\begin_layout LyX-Code
      list 1 2 
\series bold
(quote (x y z))
\end_layout

\begin_layout Subsection
Line Continuation
\begin_inset Index
status open

\begin_layout Plain Layout
Line Continuation
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sometimes long expressions become unwieldy and must be continued on following
 lines.
 There are two mechanisms for this.
 This first is to use the equal operator and an indented line as follows:
\end_layout

\begin_layout LyX-Code
list 1 2 4 5 =
\begin_inset Index
status open

\begin_layout Plain Layout
=
\end_layout

\end_inset

 
\end_layout

\begin_layout LyX-Code

\series bold
   6 7 8
\end_layout

\begin_layout Standard
This is equivalent to: 
\end_layout

\begin_layout LyX-Code
list 1 2 4 5 
\series bold
= (6 7 8)
\end_layout

\begin_layout Standard
which is the same as:
\end_layout

\begin_layout LyX-Code
list 1 2 4 5 
\series bold
6 7 8
\end_layout

\begin_layout Standard
The second and preferred is the special line continuation character (the
 tilde
\begin_inset Index
status open

\begin_layout Plain Layout
tilde
\end_layout

\end_inset

 ~
\begin_inset Index
status open

\begin_layout Plain Layout
~
\end_layout

\end_inset

) which continues the previous line indentation
\begin_inset Index
status open

\begin_layout Plain Layout
indentation
\end_layout

\end_inset

 level at the start of the line under which it is placed.
 This allows arbitrary continuations such as:
\end_layout

\begin_layout LyX-Code
^
\end_layout

\begin_layout LyX-Code
  1 2
\end_layout

\begin_layout LyX-Code
      3
\end_layout

\begin_layout LyX-Code
      
\series bold
~ 22
\end_layout

\begin_layout LyX-Code
      99
\end_layout

\begin_layout Standard
which is the same as:
\end_layout

\begin_layout LyX-Code
^ (1 2 (3) 
\series bold
22
\series default
 (99))
\end_layout

\begin_layout Standard
if the tilde was not there the expression would become:
\end_layout

\begin_layout LyX-Code
^ (1 2 (3) 
\series bold
(22
\series default
) (99))
\end_layout

\begin_layout Subsection
More Quote Characters
\end_layout

\begin_layout Standard
Genyris also supports three other special syntactic quotes similar to the
 carat.
 They are all used to simplify writing macros with the 
\emph on
template 
\emph default
function, but can be used for anything else.
 These are converted by the parser into expressions as follows:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input Quote Sequence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Translated Expression
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
,
\begin_inset Index
status open

\begin_layout Plain Layout
,
\end_layout

\end_inset

<exp>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(comma
\begin_inset Index
status open

\begin_layout Plain Layout
comma
\end_layout

\end_inset

 <exp>)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
,@
\begin_inset Index
status open

\begin_layout Plain Layout
,@
\end_layout

\end_inset

<exp>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(comma-at
\begin_inset Index
status open

\begin_layout Plain Layout
comma-at
\end_layout

\end_inset

 <exp>)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
`
\begin_inset Index
status open

\begin_layout Plain Layout
`
\end_layout

\end_inset

<exp>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(template
\begin_inset Index
status open

\begin_layout Plain Layout
template
\end_layout

\end_inset

 <exp>)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Square and Curly Brackets
\begin_inset Index
status open

\begin_layout Plain Layout
Brackets
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The square []
\begin_inset Index
status open

\begin_layout Plain Layout
[]
\end_layout

\end_inset

 and curly {}
\begin_inset Index
status open

\begin_layout Plain Layout
{}
\end_layout

\end_inset

 brackets are parsed specially so they can be used by the user in the expression
s.
 In both cases they are converted to a list with a symbol as follows:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Input Sequence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Translated Expression
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
[<list>]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
(squareBracket <list>)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
{<listL}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
(curlyBracket <list>)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 [1 2 3]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(squareBracket 1 2 3)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 {a b c}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(curlyBracket a b c)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Variables
\begin_inset Index
status open

\begin_layout Plain Layout
Variables
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
New variables are created with the 
\emph on
defvar
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
defvar
\end_layout

\end_inset

 
\emph default
or 
\emph on
define
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
define
\end_layout

\end_inset


\emph default
 functions.
 These functions also take an initial value for the variable:
\end_layout

\begin_layout LyX-Code
define name 'William'
\end_layout

\begin_layout LyX-Code
defvar ^name 'William'
\end_layout

\begin_layout Standard
In both examples, the symbol 
\emph on
name
\emph default
 is bound to the value 
\emph on

\begin_inset Quotes eld
\end_inset

William
\begin_inset Quotes erd
\end_inset


\emph default
 in the current environment.
 After the variable has been bound, its value can be used in any expression
 in the scope.
 The 
\emph on
define 
\emph default
function has an alias 
\emph on
var
\emph default
 which is quicker to type:
\end_layout

\begin_layout LyX-Code

\series bold
var
\series default
 name 'William'
\end_layout

\begin_layout Standard
When the interpreter sees a symbol in an argument list it looks for a binding
 in the current environment and all parent environments right up to the
 global execution environment.
 If you define a variable at the command line, it is bound in the global
 execution environment and hence is available everywhere.
 If you try to access a variable when there is no binding, an "unbound variable"
 error will be reported.
\end_layout

\begin_layout Standard
Variable values can be updated with the 
\emph on
set
\emph default
 or 
\emph on
setq
\emph default
 functions, for example:
\end_layout

\begin_layout LyX-Code
set ^name 'William Pitt
\begin_inset Index
status open

\begin_layout Plain Layout
William Pitt
\end_layout

\end_inset

'
\end_layout

\begin_layout LyX-Code
setq name 'William Pitt'
\end_layout

\begin_layout Standard
As shorthand for 
\emph on
setq
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
setq
\end_layout

\end_inset


\emph default
 the pair operator
\begin_inset Index
status open

\begin_layout Plain Layout
pair operator
\end_layout

\end_inset

 
\emph on
=
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
=
\end_layout

\end_inset


\emph default
 can be used as in:
\end_layout

\begin_layout LyX-Code
name = 'William Pitt'
\end_layout

\begin_layout Standard
A predicate function 
\emph on
bound?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
bound?
\end_layout

\end_inset


\emph default
 is provided to test whether a symbol has a binding in the current environments.
 It returns the symbol 
\emph on
true
\emph default
 if the variable is defined otherwise 
\emph on
nil
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
nil
\end_layout

\end_inset


\emph default
.
 
\end_layout

\begin_layout Section
Functions
\end_layout

\begin_layout Standard
As we have seen, Genyris can execute statements immediately at the command
 line.
 The expression:
\end_layout

\begin_layout LyX-Code
+ 42 37
\end_layout

\begin_layout Standard
Yields the addition of the two numbers (79).
 Let's explore how this works.
 The interpreter looks for list expressions and assumes the first token
 (or sub-expression) is a procedure.
 The rest of the list constitute the arguments to the procedure.
 In this case 
\emph on
+
\emph default
 is a symbol which yields a procedure object.
 The arguments are also evaluated and the results are passed to the procedure
 to be evaluated.
 Lets have a look at 
\emph on
+
\emph default
 by getting its value:
\end_layout

\begin_layout LyX-Code
> the +
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ <org.genyris.math.PlusFunction> # EagerProcedure
\end_layout

\begin_layout Standard
The function 
\emph on
the
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
the
\end_layout

\end_inset


\emph default
 is the identity function - it simply returns the value of its argument.
 Since the symbol + is an argument to 
\emph on
the,
\emph default
 its value is the underlying procedure.
 A 
\begin_inset Quotes eld
\end_inset

Procedure
\begin_inset Index
status open

\begin_layout Plain Layout
Procedure
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, or 
\begin_inset Quotes eld
\end_inset

Closure
\begin_inset Index
status open

\begin_layout Plain Layout
Closure
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, is an object which keeps a reference to the environment in which it was
 originally defined and the executable code to be run when called.
 In addition it knows how its arguments are to be handled before the executable
 code is run.
\end_layout

\begin_layout Subsection
Eager Functions
\end_layout

\begin_layout Standard
Eager
\begin_inset Index
status open

\begin_layout Plain Layout
Eager
\end_layout

\end_inset

 functions are the default in most programming languages.
 These evaluate their arguments prior to applying the underlying procedure.
 Mathematical functions such as 
\emph on
+
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
+
\end_layout

\end_inset

 -
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
-
\end_layout

\end_inset

 *
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
*
\end_layout

\end_inset


\emph default
 and /
\begin_inset Index
status open

\begin_layout Plain Layout
/
\end_layout

\end_inset

 are eager functions.
 Let's experiment with some simple math function calls.
 All the following expressions evaluate to 12:
\end_layout

\begin_layout LyX-Code
+ 6 6
\end_layout

\begin_layout LyX-Code
+ (* 2 3) (+ 2 4)
\end_layout

\begin_layout LyX-Code
+ 2 2 2 2 2 2
\end_layout

\begin_layout Standard
Notice that the + function can have many arguments.
 Another function that takes multiple arguments is 
\emph on
list
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
list
\end_layout

\end_inset

.
 This function constructs a list from its arguments.
 Here's an example:
\end_layout

\begin_layout LyX-Code
> list (* 34 8) 'pears' (/ 34 5) 'kilos'
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
272 'pears' 6.8 'kilos' # Pair
\end_layout

\begin_layout Standard
Note that the interpreter always prints a comment after the result.
 This comment is the list of classes the result belongs to.
 Since 
\emph on
list
\emph default
 returns a list, which is composed of Pairs, 
\emph on

\begin_inset Quotes eld
\end_inset

Pair
\emph default
 
\begin_inset Quotes eld
\end_inset

is printed.
 
\end_layout

\begin_layout Subsection
Lazy
\begin_inset Index
status open

\begin_layout Plain Layout
Lazy
\end_layout

\end_inset

 Functions - Conditional Execution
\end_layout

\begin_layout Standard
In contrast to Eager functions, Lazy functions do not evaluate their arguments.
 In other words, the interpreter passes the 
\series bold
source code
\series default
 of their arguments to the function.
 This allows the function to defer evalution or even exclude evaluation
 altogether, as is the case in conditional (flow control) constructs.
 
\end_layout

\begin_layout Standard
The 
\emph on
cond
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
cond
\end_layout

\end_inset


\emph default
 function is a lazy function that allows program flow to change depending
 on the outcome of conditional expressions.
 Here's the syntax of 
\emph on
cond
\emph default
: 
\end_layout

\begin_layout LyX-Code
   cond
\end_layout

\begin_layout LyX-Code
      (<condition 1>)
\end_layout

\begin_layout LyX-Code
         <sequence 1>
\end_layout

\begin_layout LyX-Code
      (<condition 2>)
\end_layout

\begin_layout LyX-Code
         <sequence 2>
\end_layout

\begin_layout LyX-Code
      ...
\end_layout

\begin_layout LyX-Code
      (<condition N>)
\end_layout

\begin_layout LyX-Code
         <sequence N>
\end_layout

\begin_layout Standard
Each condition is evaluated in turn until one returns which is not 
\emph on
nil
\emph default
.
 The associated sequence is evaluated and the value of the last expression
 in the sequence is returned.
 If there is no sequence, the value of the condition is returned.
 Typically the last condition is a non-nil constant and its sequence is
 the default.
 The symbol 
\emph on
else
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
else
\end_layout

\end_inset


\emph default
 is provided for this purpose.
 Here's an example: 
\end_layout

\begin_layout LyX-Code
   cond
\end_layout

\begin_layout LyX-Code
      (equal? foo 1)
\end_layout

\begin_layout LyX-Code
         'One'
\end_layout

\begin_layout LyX-Code
      (equal? foo 2)
\end_layout

\begin_layout LyX-Code
         'Two'
\end_layout

\begin_layout LyX-Code
      else
\end_layout

\begin_layout LyX-Code
         'Other'
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout Standard
The function 
\emph on
equal?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
equal?
\end_layout

\end_inset


\emph default
 returns 
\emph on
true
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
true
\end_layout

\end_inset


\emph default
 if the two arguments are the same otherwise 
\emph on
nil
\emph default
.
 So if the symbol 
\emph on
foo
\emph default
 is bound to the value 2 this expression will return 
\emph on
'Two'
\emph default
.
 
\end_layout

\begin_layout Subsection
Defining Your Own Functions 
\end_layout

\begin_layout Standard
Functions in Genyris are defined in the usual way for functional programming
 languages.
 The 
\emph on
def
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
def
\end_layout

\end_inset


\emph default
 function binds a name to a lexical closure
\begin_inset Index
status open

\begin_layout Plain Layout
lexical closure
\end_layout

\end_inset

 containing the current environment and the code to be applied in future
 calls.
 The body of the function is a sequence of expressions to be executed in
 the lexical environment, the last expression's value is returned.
 Here's a definition of the identity function:
\end_layout

\begin_layout LyX-Code
def identity (arg) arg
\end_layout

\begin_layout Standard
Genyris has two kinds of user-defined functions 'eager
\begin_inset Index
status open

\begin_layout Plain Layout
eager
\end_layout

\end_inset

' and 'lazy
\begin_inset Index
status open

\begin_layout Plain Layout
lazy
\end_layout

\end_inset

'.
 An eager function evaluates its arguments before it applies them, whereas
 a lazy function does not.
 Traditional functions such as '+' and 
\emph on
the
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
the
\end_layout

\end_inset


\emph default
 are eager.
 
\emph on
list
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
list
\end_layout

\end_inset


\emph default
 is an eager function which returns all its arguments in a list.
 The 
\emph on
quote
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
quote
\end_layout

\end_inset


\emph default
 function is a lazy procedure which returns its single argument un-evaluated.
 
\end_layout

\begin_layout Standard
Here is a more complex function definition:
\end_layout

\begin_layout LyX-Code
def factorial
\begin_inset Index
status open

\begin_layout Plain Layout
factorial
\end_layout

\end_inset

 (n) 
\end_layout

\begin_layout LyX-Code
   if (< n 2) 1 
\end_layout

\begin_layout LyX-Code
      * n 
\end_layout

\begin_layout LyX-Code
        factorial (- n 1)
\end_layout

\begin_layout Standard
The 
\emph on
if
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
if
\end_layout

\end_inset


\emph default
 function is lazy, since, depending on the value of the first argument,
 it executes only one of its other two arguments .
 In fact, 
\emph on
if
\emph default
 is a macro
\begin_inset Index
status open

\begin_layout Plain Layout
macro
\end_layout

\end_inset

 - a special kind of lazy function which we introduce later.
\end_layout

\begin_layout Subsection
Anonymous Functions with function and Friends 
\end_layout

\begin_layout Standard
Actually the 
\emph on
def
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
def
\end_layout

\end_inset


\emph default
 and 
\emph on
defmacro
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
defmacro
\end_layout

\end_inset


\emph default
 functions are lazy functions.
 They bind a variable name to procedure compiled from the function body.
 But what if we want a function without the binding? Genyris provides three
 kinds of in-built procedure-building functions.
 The function 
\emph on
function
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
function
\end_layout

\end_inset


\emph default
 (aka 
\emph on
lambda
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
lambda
\end_layout

\end_inset


\emph default
) creates a user-defined eager procedure object which is a closure at the
 point of definition.
 For example we can create an anonymous function at the command-line:
\end_layout

\begin_layout LyX-Code
> 
\series bold
function
\series default
 (x) (* x x)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ <org.genyris.interp.ClassicFunction> # EagerProcedure 
\end_layout

\begin_layout Standard
To actually call it we place it wherever a function is expected, such as
 a parameter to a function, or at the beginning of a list:
\end_layout

\begin_layout LyX-Code
> 
\series bold
(function (x) (* x x))
\series default
 3
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 9 # Bignum
\end_layout

\begin_layout Standard
Notice the parentheses are required around the expression to trigger the
 execution.
 The argument 3 is passed to the resulting closure.
 Functions are 'first class' and can be assigned to variables, which is
 how 
\emph on
def
\emph default
 works.
 The following two expressions are equivalent:
\end_layout

\begin_layout LyX-Code
define square
\end_layout

\begin_layout LyX-Code
   function (x) (* x x) 
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
def square (x)
\end_layout

\begin_layout LyX-Code
   * x x 
\end_layout

\begin_layout Subsubsection
Anonymous Lazy Functions
\end_layout

\begin_layout Standard
To defer evaluation, a lazy function can be defined using the 
\emph on
lambdaq
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
lambdaq
\end_layout

\end_inset

 
\emph default
or
\emph on
 lambdam
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
lambdam
\end_layout

\end_inset


\emph default
 macros.
 
\emph on
lambdaq
\emph default
 is just like 
\emph on
function
\emph default
 except it builds a lazy procedure, 
\emph on
lambdam
\emph default
 builds anonymous macros.
 The next example creates an anonymous function which prepends its argument
 (without evaluation) to a list:
\end_layout

\begin_layout LyX-Code
> (
\series bold
lambdaq
\series default
 (x) (list x 'World')) (+ 'Hello')
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
(+ 'Hello') 'World' # Pair
\end_layout

\begin_layout Subsection
Executable Comments
\end_layout

\begin_layout Standard
Sometimes it's necessary to temporarily 'comment
\begin_inset Index
status open

\begin_layout Plain Layout
comment
\end_layout

\end_inset

 out' functions or provide in-line text.
 This is done via the function 
\emph on
'//
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
//
\end_layout

\end_inset

' 
\emph default
which is a lazy function that ignores it's arguments and return 
\emph on
nil
\emph default
.
 It is defined as:
\end_layout

\begin_layout LyX-Code
df // (&rest body)
\end_layout

\begin_layout Standard
and can be used as follows:
\end_layout

\begin_layout LyX-Code
// def allcommentedout(arg) # to comment out an entire function
\end_layout

\begin_layout LyX-Code
  function (x)
\end_layout

\begin_layout LyX-Code
    cond
\end_layout

\begin_layout LyX-Code
      (eq? nil (cdr x))
\end_layout

\begin_layout LyX-Code
         car x
\end_layout

\begin_layout LyX-Code
      else
\end_layout

\begin_layout LyX-Code
         last (cdr x)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def myfun()
\end_layout

\begin_layout LyX-Code
   // 'in-line  documentation'
\end_layout

\begin_layout LyX-Code
   +
\end_layout

\begin_layout LyX-Code
      // + 1      # however this causes an error because // returns nil.
\end_layout

\begin_layout LyX-Code
          + 34
\end_layout

\begin_layout LyX-Code
          + 45
\end_layout

\begin_layout LyX-Code
      99
\end_layout

\begin_layout Subsection
Defining Macros
\end_layout

\begin_layout Standard
Macros
\begin_inset Index
status open

\begin_layout Plain Layout
Macros
\end_layout

\end_inset

 are lazy functions which are very handy for extending the syntax of the
 language or creating Domain-Specific Languages
\begin_inset Index
status open

\begin_layout Plain Layout
Domain-Specific Languages
\end_layout

\end_inset

 (DSL
\begin_inset Index
status open

\begin_layout Plain Layout
DSL
\end_layout

\end_inset

s).
 Macros re-evaluate the returned value in the environment of the caller.
 Here's an example:
\end_layout

\begin_layout LyX-Code
defmacro trace(&rest body)
\end_layout

\begin_layout LyX-Code
  print body
\end_layout

\begin_layout LyX-Code
  body
\end_layout

\begin_layout Standard
This macro prints an expression which is then evaluated.
 The keyword 
\emph on
&rest
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
&rest
\end_layout

\end_inset


\emph default
 tells the interpreter to collate the values of all remaining arguments
 into the single variable 
\emph on
body
\emph default
.
 So when called with:
\end_layout

\begin_layout LyX-Code
> trace (+ 1 2)
\end_layout

\begin_layout Standard
It prints the expression and the result is calculated:
\end_layout

\begin_layout LyX-Code
(+ 1 2)
\end_layout

\begin_layout LyX-Code
~ 3 # Bignum
\end_layout

\begin_layout Standard
Here is a more complex example - definition of a control flow function:
 
\end_layout

\begin_layout LyX-Code

\series bold
defmacro
\series default
 my-if (test success-result failure-result)
\end_layout

\begin_layout LyX-Code
   
\series bold
template
\end_layout

\begin_layout LyX-Code
      cond
\end_layout

\begin_layout LyX-Code
         ,test ,success-result
\end_layout

\begin_layout LyX-Code
         else ,failure-result
\end_layout

\begin_layout Standard
This macro uses the 
\emph on
template
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
template
\end_layout

\end_inset


\emph default
 function and 
\emph on
comma
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
comma
\end_layout

\end_inset


\emph default
 to splice the arguments into a formulaic expression.
 Here's an example if its use:
\end_layout

\begin_layout LyX-Code
define test 3    # binding in the caller's environment
\end_layout

\begin_layout LyX-Code
my-if (equal? test 3) 1 2     
\end_layout

\begin_layout Standard
This returns 1.
 Notice how the variable 
\emph on
test
\emph default
 is defined in the caller's environment used in the condition, not the binding
 of the same name within 
\emph on
my-if
\emph default
.
 
\end_layout

\begin_layout Subsection
Lexical Scoping
\begin_inset Index
status open

\begin_layout Plain Layout
Lexical Scoping
\end_layout

\end_inset

 Captures Environments
\end_layout

\begin_layout Standard
Genyris is "lexically scoped" - when a function is defined it remembers
 the environment in which it was defined and re-uses that environment when
 it executes.
 This provides a way of hiding data and giving functions stateful side effects.
 The following example
\begin_inset Foot
status open

\begin_layout Plain Layout
refer to Abelson and Sussmans' book 
\begin_inset Quotes eld
\end_inset

Structure and Interpretation of Computer Programs
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 creates a function which captures the 
\emph on
balance
\emph default
 variable:
\end_layout

\begin_layout LyX-Code
def make-withdraw (balance) 
\end_layout

\begin_layout LyX-Code
   function (amount) 
\end_layout

\begin_layout LyX-Code
      setq balance (- balance amount)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
define W1 (make-withdraw 100)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
> W1 25
\end_layout

\begin_layout LyX-Code
W1 25
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 75 # Bignum
\end_layout

\begin_layout LyX-Code
~ 50 # Bignum
\end_layout

\begin_layout Standard
Repeated execution of the function 
\emph on
W1
\emph default
 reduces the value of the balance each time.
 The sequence of evaluation is as follows:
\end_layout

\begin_layout Enumerate
the lazy 
\emph on
def
\emph default
 expression is executed which results in a procedure object bound to the
 symbol 
\emph on
make-withdraw
\end_layout

\begin_layout Enumerate
the 
\emph on
balance
\emph default
 argument (
\emph on
100
\emph default
) to the eager 
\emph on
define
\emph default
 expression is evaluated and 
\emph on
make-withdraw 
\emph default
is called
\emph on
.
\end_layout

\begin_layout Enumerate
the eager 
\emph on
make-withdraw 
\emph default
creates a new environment in which it binds 
\emph on
balance
\emph default
 to 
\emph on
100
\end_layout

\begin_layout Enumerate
the body of 
\emph on
make-withdraw
\emph default
 is evaluated resulting in another procedure object which captures a reference
 to 
\emph on
balance 
\emph default
and contains the executable code starting with 
\emph on
setq
\end_layout

\begin_layout Enumerate
the procedure object is bound to W1
\end_layout

\begin_layout Enumerate

\emph on
W1
\emph default
 is called with the argument 25
\end_layout

\begin_layout Enumerate
the procedure 
\emph on
W1
\emph default
 subtracts 25 from the 
\emph on
balance
\emph default
 binding in the
\emph on
 
\emph default
environment created in step 3
\end_layout

\begin_layout Standard
Note that there is no way to directly access the 
\emph on
balance
\emph default
 variable.
 
\end_layout

\begin_layout Section
Everything is Callable
\end_layout

\begin_layout Standard
The Genyris evaluator expects the first element of a list to be some kind
 of procedure
\begin_inset Index
status open

\begin_layout Plain Layout
procedure
\end_layout

\end_inset

 object - something that can compute its arguments and apply them.
 This is the role of traditional functions such as 
\emph on
+
\emph default
 or user-defined functions.
 In Genyris, 
\bar under
all
\bar default
 objects are callable, even atomic types.
 For example an integer can be called as a function thus:
\end_layout

\begin_layout LyX-Code
> 
\series bold
12
\series default
 (+ 33 44) (- 4 3)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 1 # Bignum
\end_layout

\begin_layout Standard
Lets analyse what happens.
 The integer 
\emph on
12
\emph default
 was called with two argument 
\emph on
(+ 33 44)
\emph default
 and 
\emph on
(- 4 3)
\emph default
.
 
\emph on
12
\emph default
 is a lazy function and does not evaluate its arguments.
 It treats its arguments as a sequence of expressions to be evaluated in
 a new environment.
 So it calculated 333 + 44 = 77, and then 4 -3 = 1.
 When it reached this last expression it returned the value 1.
 This expression can be written in indented form with the same result as
 follows:
\end_layout

\begin_layout LyX-Code

\series bold
12
\series default
 
\end_layout

\begin_layout LyX-Code
   + 33 44
\end_layout

\begin_layout LyX-Code
   - 4 3
\end_layout

\begin_layout Standard
If an atom is called with no arguments, it simply returns itself.
 So at the command line typing a number alone returns the number:
\end_layout

\begin_layout LyX-Code
> 1024
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 1024 # Bignum
\end_layout

\begin_layout Standard
As well as executing the sequence of expressions, an execution environment
 was created in which the number 12 is a bound to the dynamic variable
\begin_inset Index
status open

\begin_layout Plain Layout
dynamic variable
\end_layout

\end_inset

 
\emph on
.self
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.self
\end_layout

\end_inset


\emph default
.
 The variable can be used as follows:
\end_layout

\begin_layout LyX-Code
> 12 (+ 
\series bold
.self .self
\series default
) 
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 24 # Bignum
\end_layout

\begin_layout Standard
Here the number is added to itself.
 The environment can also be used to create local bindings with the 
\emph on
define
\emph default
 functions:
\end_layout

\begin_layout LyX-Code
12
\end_layout

\begin_layout LyX-Code
  
\series bold
define foo 987
\end_layout

\begin_layout LyX-Code
  + foo .self
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 999 # Bignum  
\end_layout

\begin_layout Standard
If a symbol is called as a function it is by default evaluated to locate
 the binding in the current evironment.
 If we make the value an atom, we can use the symbol as a a keyword.
 For example, the symbol 
\emph on
my-do
\emph default
 could be defined like this:
\end_layout

\begin_layout LyX-Code
define my-do ^my-do 
\end_layout

\begin_layout Standard
Now whenever we call 
\emph on
my-do
\emph default
 as a function, it acts as a code block which can be used in a function:
\end_layout

\begin_layout LyX-Code

\series bold
def my-function()
\end_layout

\begin_layout LyX-Code

\series bold
   my-do
\end_layout

\begin_layout LyX-Code
      some-function 'Hi!'
\end_layout

\begin_layout LyX-Code
      define a-variable 42
\end_layout

\begin_layout LyX-Code
      print .self
\end_layout

\begin_layout Standard
However there is a catch - within the context the do block of 
\emph on
.self 
\emph default
is bound to 
\emph on
my-do
\emph default
.
 Hence the above function prints 
\begin_inset Quotes eld
\end_inset

my-do
\begin_inset Quotes erd
\end_inset

.
 A better way to add new syntax is to create a macro, since 
\emph on
.self
\emph default
 is not affected.
 
\end_layout

\begin_layout Subsection
Dynamic Variables
\begin_inset Index
status open

\begin_layout Plain Layout
Dynamic Variables
\end_layout

\end_inset


\end_layout

\begin_layout Standard
'Dynamic' variables are those which are bound in the environment of the
 caller and hence depend on who is evaluating the expression.
 In Genyris dynamic variables are limited to being properties of the currently
 called object, and called objects are part of their environment.
 In other words when an object is used as a procedure, the environment created
 to make the call is a merge of the object itself and a lexical environment.
 When prefixed with the period .
 character, the binding for the symbol is looked up in the dynamic context.
 An example will make this clearer:
\end_layout

\begin_layout Standard
The number 12 above has two dynamic variables, 
\emph on
.self
\emph default
 and 
\emph on
.classes
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.classes
\end_layout

\end_inset


\emph default
.
 They can be accessed as follows:
\end_layout

\begin_layout LyX-Code
12
\end_layout

\begin_layout LyX-Code
  print .self .classes
\end_layout

\begin_layout Standard
Here we see that the
\emph on
 .classes
\emph default
 variable is referring to the class list of 
\emph on
12.
 
\emph default
It has a single class, 
\emph on
Bignum,
\emph default
 which is printed.
 This behaviour is the same for the other atomic types: Bignums, Pairs and
 Strings.
 Consider the following examples:
\end_layout

\begin_layout LyX-Code
> 'What am I?'.classes
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
<class String (Builtin)> # Pair
\end_layout

\begin_layout Standard
However where symbols are concerned, the evaluator always looks up the value
 binding.
 So to work with a symbol we must first quote it:
\end_layout

\begin_layout LyX-Code
> ^a-symbol.classes
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
(<class SimpleSymbol (Symbol)>) # Pair 
\end_layout

\begin_layout Standard
Likewise the interpreter assumes a list is a normal function call so a quote
 is needed to see this behaviour: 
\end_layout

\begin_layout LyX-Code
> ^(3).classes
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
<class Pair (Builtin)> # Pair
\end_layout

\begin_layout Standard
Most atomic types have only a single dynamic variable, richer examples lie
 in the compound object types.
\end_layout

\begin_layout Subsection
Working With Pairs and Lists
\end_layout

\begin_layout Standard
Like its forbears Lisp and Scheme, Genyris is a list-processing
\begin_inset Index
status open

\begin_layout Plain Layout
list-processing
\end_layout

\end_inset

 language - its source code is expressed as lists and it has inbuilt functions
 for parsing and manipulating list data.
 Since programs and data are stored in the same form, Genyris is an ideal
 platform for developing DSLs or even new programming languages.
 Happily, manipulating lists is easy.
 Lists are a kind of binary tree.
 Trees are constructed with the 
\emph on
cons
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
cons
\end_layout

\end_inset


\emph default
 function which accepts two arguments for the left and right halves of the
 
\emph on
Pair
\emph default
:
\end_layout

\begin_layout LyX-Code
> 
\series bold
cons
\series default
 'A' 'B'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
('A' = 'B') # Pair
\end_layout

\begin_layout Standard
Note the interpreter prints a colon between the left and right halves of
 the Pair.
 The individual elements of a Pair can be accessed with the 
\emph on
left
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
left
\end_layout

\end_inset


\emph default
 and 
\emph on
right
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
right
\end_layout

\end_inset


\emph default
 functions:
\end_layout

\begin_layout LyX-Code
> 
\series bold
left
\series default
 (cons 'A' 'B')
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
'A' # String
\end_layout

\begin_layout Standard
Alternatively the dynamic variables 
\emph on
.left
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.left
\end_layout

\end_inset


\emph default
 and 
\emph on
.right
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.right
\end_layout

\end_inset


\emph default
 can be used when the list is called:
\end_layout

\begin_layout LyX-Code
> var my-pair (cons 'A' 'B') 
\end_layout

\begin_layout LyX-Code
my-pair .
\series bold
right
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
'B' # String
\end_layout

\begin_layout LyX-Code
> my-pair
\end_layout

\begin_layout LyX-Code
   
\series bold
setq .left 33
\end_layout

\begin_layout LyX-Code
   .self
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
33 = 'B' # Pair
\end_layout

\begin_layout Standard
To construct a proper List, the final right hand element will be 
\emph on
nil
\emph default
:
\end_layout

\begin_layout LyX-Code
> cons 'A'
\end_layout

\begin_layout LyX-Code
    cons 'B'
\end_layout

\begin_layout LyX-Code
       cons 'C' nil 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
'A' 'B' 'C' # Pair
\end_layout

\begin_layout Standard
The printing of trees (by default) assumes that the tree is a kind of list,
 hence you don't see the parentheses in this case.
 See how the interpreter identified the list as a 
\emph on
Pair
\emph default
, since it only has a reference to the first 
\emph on
Pair
\emph default
.
 
\end_layout

\begin_layout Standard
To help view 
\emph on
Pairs
\emph default
 explicitly, a list can be tagged with the PRINTWITHEQ
\begin_inset Index
status open

\begin_layout Plain Layout
PRINTWITHEQ
\end_layout

\end_inset

 class, which forces the printer to display the full tree structure.
 The parser does this automatically, so Pairs which the user types with
 a colon are printed the same way.
 For example:
\end_layout

\begin_layout LyX-Code
> ^('A' = ('B' = ('C' )))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
('A' = ('B' = ('C'))) # Pair 
\end_layout

\begin_layout Subsection
Dictionaries - Your Everyday Objects
\end_layout

\begin_layout Standard
Genyris provides 
\begin_inset Quotes eld
\end_inset

dictionary
\begin_inset Index
status open

\begin_layout Plain Layout
dictionary
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 objects which are 
\begin_inset Quotes eld
\end_inset

objects
\begin_inset Quotes erd
\end_inset

 in the normally understood sense for programming languages.
 Each dictionary provides a un-ordered set of dynamic symbols and bindings
 - called 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Index
status open

\begin_layout Plain Layout
properties
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 A dictionary is created with the 
\emph on
dict
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
dict
\end_layout

\end_inset


\emph default
 function call, e.g.:
\end_layout

\begin_layout LyX-Code
define pitt
\end_layout

\begin_layout LyX-Code
  
\series bold
dict 
\end_layout

\begin_layout LyX-Code

\series bold
    .name  = 'Willam Pitt
\begin_inset Index
status open

\begin_layout Plain Layout

\series bold
Willam Pitt
\end_layout

\end_inset

'
\end_layout

\begin_layout LyX-Code

\series bold
    .title = 'Prime Minister'
\end_layout

\begin_layout LyX-Code

\series bold
    .date-of-birth   = '28 May 1759'
\end_layout

\begin_layout Standard
Here we have created a 
\emph on
dict
\emph default
 with three properties.
 The 
\emph on
dict
\emph default
 function takes a variable number of property definitions in Pairs, more
 formally: 
\end_layout

\begin_layout LyX-Code
  dict
\end_layout

\begin_layout LyX-Code
     <dynamic symbol1> = <initial value1>
\end_layout

\begin_layout LyX-Code
     <dynamic symbol2> = <initial value2>
\end_layout

\begin_layout LyX-Code
     etc...
\end_layout

\begin_layout Standard
If there are no initial values given , the symbol 
\emph on
nil
\emph default
 is used as the value as in this example:
\end_layout

\begin_layout LyX-Code
> 
\series bold
dict
\end_layout

\begin_layout LyX-Code

\series bold
   .foo
\end_layout

\begin_layout LyX-Code

\series bold
   .bar
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
dict
\end_layout

\begin_layout LyX-Code
      .bar = nil
\end_layout

\begin_layout LyX-Code
      .foo = nil # Dictionary      
\end_layout

\begin_layout Standard
Having properties is all very well, but we need a way to access them.
 As we have seen all objects are callable - including dictionaries.
 So to access the above 
\emph on
dict
\emph default
 object we call it and use the dynamic variables as follows:
\end_layout

\begin_layout LyX-Code
> pitt .name
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 'Willam Pitt' # String
\end_layout

\begin_layout Standard
Here the 
\emph on
.name
\emph default
 dynamic variable is bound to the 
\emph on
.name
\emph default
 property in the dict.
 To set the property value we use the 
\emph on
setq
\emph default
 function:
\end_layout

\begin_layout LyX-Code
pitt
\end_layout

\begin_layout LyX-Code
   
\series bold
setq
\begin_inset Index
status open

\begin_layout Plain Layout

\series bold
setq
\end_layout

\end_inset

 
\series default
.name 'William Pitt The Younger'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
New properties can be created with 
\emph on
define
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
define
\end_layout

\end_inset


\emph default
 since the object acts as an environment in its own right.
 e.g.:
\end_layout

\begin_layout LyX-Code
pitt 
\end_layout

\begin_layout LyX-Code
   
\series bold
define
\series default
 .father 'William Pitt the Elder'
\end_layout

\begin_layout Standard
Dictionaries also have a 
\begin_inset Quotes eld
\end_inset

magic
\begin_inset Quotes erd
\end_inset

 variable 
\emph on
.vars
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.vars
\end_layout

\end_inset


\emph default
 which lists all the variables defined in the dictionary.
 This is handy for debugging.
 For example:
\end_layout

\begin_layout LyX-Code
> pitt 
\series bold
.vars
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
.date-of-birth .father .name .title .vars # Pair
\end_layout

\begin_layout Subsection
Adding Behaviour to Dictionaries
\end_layout

\begin_layout Standard
Since functions in Genyris are bound to variables, and dictionaries have
 variables, behaviour can be added to dictionaries.
 It suffices to define a function with a dynamic name in the scope of a
 dictionary:
\end_layout

\begin_layout LyX-Code
define jeb
\end_layout

\begin_layout LyX-Code
  
\series bold
 dict
\end_layout

\begin_layout LyX-Code

\series bold
      .firstName= 'Joe' 
\end_layout

\begin_layout LyX-Code

\series bold
      .middleName= 'E.'
\end_layout

\begin_layout LyX-Code

\series bold
      .lastName= 'Brown'
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
jeb 
\end_layout

\begin_layout LyX-Code
   
\series bold
def .displayName()
\end_layout

\begin_layout LyX-Code

\series bold
       list .firstName .middleName .lastName
\end_layout

\begin_layout Standard
Once defined, the function is callable in the context of the 
\emph on
jeb
\emph default
 dict:
\end_layout

\begin_layout LyX-Code
> jeb 
\series bold
(.displayName)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
'Joe' 'E.' 'Brown' # Pair
\end_layout

\begin_layout Standard
A dict can be used a mechanism for organisation.
 Consider the following fictional example - a set of functions organised
 in a dictionary called 
\emph on
file
\emph default
:
\end_layout

\begin_layout LyX-Code
## File Handling code
\end_layout

\begin_layout LyX-Code
define file
\end_layout

\begin_layout LyX-Code
  dict 
\end_layout

\begin_layout LyX-Code
    .name  = 'File Handling Functions'
\end_layout

\begin_layout LyX-Code
    .version = '1.2'
\end_layout

\begin_layout LyX-Code
file
\end_layout

\begin_layout LyX-Code
   
\series bold
def .copy(from to) etc
\end_layout

\begin_layout LyX-Code

\series bold
   def .delete(filename) etc
\end_layout

\begin_layout LyX-Code

\series bold
   def .zip(file) etc
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
## Use of the file module
\end_layout

\begin_layout LyX-Code
def archive(filename)
\end_layout

\begin_layout LyX-Code
    
\series bold
(file.copy) filename '/tmp/foo'
\end_layout

\begin_layout LyX-Code

\series bold
    (file.zip) '/tmp/foo'
\end_layout

\begin_layout LyX-Code

\series bold
    (file.delete) filename
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Here we define three functions bound to a single dict object.
 The functions can only be called by referencing the 
\emph on
file
\emph default
 object.
 
\end_layout

\begin_layout Subsection
More Synactic Sugar - Using the exclamation mark
\begin_inset Foot
status open

\begin_layout Plain Layout
The choice of this syntax is a tribute to Martin Richards
\begin_inset Index
status open

\begin_layout Plain Layout
Martin Richards
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The exclamation mark
\begin_inset Index
status open

\begin_layout Plain Layout
exclamation mark
\end_layout

\end_inset

, ! (aka pling
\begin_inset Index
status open

\begin_layout Plain Layout
pling
\end_layout

\end_inset

) provides a shorthand way of accessing the properties of a dictionary.
 This is implemented in the parser like quotes.
 Here are some examples
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Tra
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit

\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Input Quote Sequence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
Translated Expression
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a!b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(a .b)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a!b!c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
((a .b) .c)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(f).a!b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(f)(.a .b)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(dict)!self
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
((dict) .self)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a!b(var .x 23)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(a .b)(var .x 23)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.x!y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(.x .y)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The previous example can be written succinctly:
\end_layout

\begin_layout LyX-Code
def archive(filename)
\end_layout

\begin_layout LyX-Code
    
\series bold
file!copy filename '/tmp/foo'
\end_layout

\begin_layout LyX-Code

\series bold
    file!zip '/tmp/foo'
\end_layout

\begin_layout LyX-Code

\series bold
    file!delete filename
\end_layout

\begin_layout Section
Modules
\end_layout

\begin_layout Standard
The previous example shows how names can be grouped within a Dictionary
 object.
 This idea is made easier in the langugae through modules
\begin_inset Index
status open

\begin_layout Plain Layout
modules
\end_layout

\end_inset

.
 A module is simply a dictionary into which the contents of a source file
 have been bound.
 Continuing with our example, first we provide a file of functions and definitio
ns called 'file.g
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# File Handling Module
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
define .doc 'File Handling Functions'
\end_layout

\begin_layout LyX-Code
define .version '1.2'
\end_layout

\begin_layout LyX-Code

\series bold
def .copy(from to) 
\end_layout

\begin_layout LyX-Code

\series bold
   etc
\end_layout

\begin_layout LyX-Code

\series bold
def .delete(filename)
\end_layout

\begin_layout LyX-Code

\series bold
   etc
\end_layout

\begin_layout LyX-Code

\series bold
def .zip(file)
\end_layout

\begin_layout LyX-Code

\series bold
   etc
\end_layout

\begin_layout LyX-Code
def helperFunction(args)
\end_layout

\begin_layout LyX-Code
   etc
\end_layout

\begin_layout Standard
Notice we don't need to declare a dictionary since this is provided by 
\emph on
import
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
import
\end_layout

\end_inset

.
 To use the module we first need to tell the interpreter where to find the
 file containing the module's code.
 This is done by adding to the 
\emph on
sys:path
\emph default
 global variable which is a list of directories to search:
\end_layout

\begin_layout LyX-Code
sys:path
\begin_inset Index
status open

\begin_layout Plain Layout
sys:path
\end_layout

\end_inset

 = (cons 'examples' sys:path)
\end_layout

\begin_layout Standard
Now we read the source code:
\end_layout

\begin_layout LyX-Code
import file
\end_layout

\begin_layout Standard
This creates a variable 
\emph on
file
\emph default
 in the environment of the caller (not necessarily the global environment).
 Using the module's dictionary we can now access the functions in the module:
\end_layout

\begin_layout LyX-Code
## Use of the file module
\end_layout

\begin_layout LyX-Code
import file
\end_layout

\begin_layout LyX-Code

\series bold
file!copy filename '/tmp/foo'
\end_layout

\begin_layout Standard
Note that 
\emph on
helperFunction
\emph default
 is defined with a normal lexical variable.
 It cannot be reached from outside the module since only dynamic symbols
 can be de-reference via adictionary.
 Use this to create private variables and functions inside modules.
\end_layout

\begin_layout Standard
If we change the source code of 
\emph on
file.g
\emph default
 and need to load the new code, we must use the 
\emph on
reload
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
reload
\end_layout

\end_inset


\emph default
 macro, since import checks to see if the module already is in memory, and
 uses the already loaded module.
 
\end_layout

\begin_layout LyX-Code
> reload file
\end_layout

\begin_layout LyX-Code
etc...
\end_layout

\begin_layout Section
Namespaces
\end_layout

\begin_layout Standard
A way to prevent name clashes is to use symbol prefixes to define 'namespaces
\begin_inset Index
status open

\begin_layout Plain Layout
namespaces
\end_layout

\end_inset

' for symbols.
 A namespace can be defined with a Parser Directive 
\begin_inset Quotes eld
\end_inset


\emph on
@prefix
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\end_layout

\end_inset

@prefix
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 as follows
\end_layout

\begin_layout LyX-Code
@prefix magic 'http://my.org/2008/spells/'
\end_layout

\begin_layout Standard
Here the expression starting with 
\emph on
@prefi
\emph default
x is consumed by the parser, and any subsequent symbols it sees starting
 with the prefix 
\emph on
magic
\emph default
.
 are replaced with 
\emph on
http://my.org/2008/spells/
\emph default
.
 Hence the true name of 
\emph on
magic.accio
\emph default
 is 
\emph on
http://my.org/2008/spells/accio
\emph default
.
 We can print the full name of the symbol by quoting it:
\end_layout

\begin_layout LyX-Code
> @prefix magic 'http://my.org/2008/spells/'
\end_layout

\begin_layout LyX-Code
^magic:accio
\end_layout

\begin_layout LyX-Code
~ http://my.org/2008/spells/accio # URISymbol
\begin_inset Index
status open

\begin_layout Plain Layout
URISymbol
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here is the previous example re-worked using a namespace:
\end_layout

\begin_layout LyX-Code
## File Handling Module (using prefixes)
\end_layout

\begin_layout LyX-Code
@prefix file 'http://my/files/'
\end_layout

\begin_layout LyX-Code
def file:copy(from to) etc
\end_layout

\begin_layout LyX-Code
def file:delete(filename) etc
\end_layout

\begin_layout LyX-Code
def file:zip(file) etc
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
## Use of the file module
\end_layout

\begin_layout LyX-Code
@prefix f 'http://my/files/'
\end_layout

\begin_layout LyX-Code
def archive(filename)
\end_layout

\begin_layout LyX-Code
    f:copy filename '/tmp/foo'
\end_layout

\begin_layout LyX-Code
    f:zip '/tmp/foo'
\end_layout

\begin_layout LyX-Code
    f:delete filename
\end_layout

\begin_layout Standard
Prefixes apply to all symbols seen by the parser in the current parse, and
 can be used in a variety of ways (for example) to define global properties
 or interfaces.
  
\end_layout

\begin_layout Subsection
Using Namespaces for Semantic Markup
\end_layout

\begin_layout Standard
Namespaces are compatible with RDF
\begin_inset Index
status open

\begin_layout Plain Layout
RDF
\end_layout

\end_inset

 and allow you to embed the semantics of the information within the program.
 This can be used either for human consumption (to nail the meaning of the
 information) or for subsequent processing and linkage with external programs
 which also understand RDF.
 Here's an example:
\end_layout

\begin_layout LyX-Code
> @prefix us "http://places.org/usa#"
\end_layout

\begin_layout LyX-Code
var boston                   # variable declaration
\end_layout

\begin_layout LyX-Code
  dict                       # new dictionary object
\end_layout

\begin_layout LyX-Code
    .us:location = "Boston"
\end_layout

\begin_layout LyX-Code
    .us:zip = "02110"
\end_layout

\begin_layout LyX-Code
    .us:location-lat = 42.37
\end_layout

\begin_layout LyX-Code
    .us:location-long = 71.03
\end_layout

\begin_layout LyX-Code
dict
\end_layout

\begin_layout LyX-Code
      .|http://places.org/usa#location| = "Boston"
\end_layout

\begin_layout LyX-Code
      .|http://places.org/usa#location-lat| = 42.37
\end_layout

\begin_layout LyX-Code
      .|http://places.org/usa#location-long| = 71.03
\end_layout

\begin_layout LyX-Code
      .|http://places.org/usa#zip| = "02110" # Dictionary
\end_layout

\begin_layout Section
Using Classes to Organise Behaviour
\end_layout

\begin_layout Standard
All Genyris objects, be they atomic (like numbers) or composite (like dictionari
es) can belong to one or more classes.
 As such Genyris is a fully 
\begin_inset Quotes eld
\end_inset

Object-Oriented
\begin_inset Index
status open

\begin_layout Plain Layout
Object-Oriented
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 language.
 The interpreter looks at the classes for functions to execute if the function
 name is dynamic (starts with a .).
 This way you can add behaviour to many objects in a single place.
 Classes are dictionaries with special variables which hold the relationships
 between classes.
 The standard classes all have the following variables:
\end_layout

\begin_layout Description
.classes
\begin_inset Index
status open

\begin_layout Plain Layout
.classes
\end_layout

\end_inset

 The list of classes to which the object belongs.
\end_layout

\begin_layout Description
.vars
\begin_inset Index
status open

\begin_layout Plain Layout
.vars
\end_layout

\end_inset

 List of property names.
\end_layout

\begin_layout Description
.classname
\begin_inset Index
status open

\begin_layout Plain Layout
.classname
\end_layout

\end_inset

 The String name of the class.
\end_layout

\begin_layout Description
.superclasses
\begin_inset Index
status open

\begin_layout Plain Layout
.superclasses
\end_layout

\end_inset

 The list of classes from which the class inherits.
\end_layout

\begin_layout Description
.subclasses
\begin_inset Index
status open

\begin_layout Plain Layout
.subclasses
\end_layout

\end_inset

 The list of classes which inherit from this class.
\end_layout

\begin_layout Standard
Genyris has a number of built-in classes beginning with 
\emph on
Thing
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Thing
\end_layout

\end_inset


\emph default
, root of the class hierarchy.
 Here is the builtin class hierarchy:
\end_layout

\begin_layout LyX-Code
 Thing
\end_layout

\begin_layout LyX-Code
    Task
\end_layout

\begin_layout LyX-Code
    Module
\end_layout

\begin_layout LyX-Code
    SetList
\end_layout

\begin_layout LyX-Code
    Alist
\end_layout

\begin_layout LyX-Code
    Builtin
\end_layout

\begin_layout LyX-Code
       PairEqual
\end_layout

\begin_layout LyX-Code
       Pair
\end_layout

\begin_layout LyX-Code
          ListOfLines
\end_layout

\begin_layout LyX-Code
          PRINTWITHEQ
\end_layout

\begin_layout LyX-Code
       Closure
\end_layout

\begin_layout LyX-Code
          LazyProcedure
\end_layout

\begin_layout LyX-Code
          EagerProcedure
\end_layout

\begin_layout LyX-Code
       Symbol
\end_layout

\begin_layout LyX-Code
          DynamicSymbolRef
\end_layout

\begin_layout LyX-Code
          URISymbol
\end_layout

\begin_layout LyX-Code
          SimpleSymbol
\end_layout

\begin_layout LyX-Code
             |http://www.genyris.org/lang/syntax#Keyword|
\end_layout

\begin_layout LyX-Code
       Triplestore
\end_layout

\begin_layout LyX-Code
       Triple
\end_layout

\begin_layout LyX-Code
       Sound
\end_layout

\begin_layout LyX-Code
       StringFormatStream
\end_layout

\begin_layout LyX-Code
       ParenParser
\end_layout

\begin_layout LyX-Code
       Parser
\end_layout

\begin_layout LyX-Code
       System
\end_layout

\begin_layout LyX-Code
       Writer
\end_layout

\begin_layout LyX-Code
       Reader
\end_layout

\begin_layout LyX-Code
       CSV
\end_layout

\begin_layout LyX-Code
       File
\end_layout

\begin_layout LyX-Code
       String
\end_layout

\begin_layout LyX-Code
          ShortDateTimeString
\end_layout

\begin_layout LyX-Code
       Bignum
\end_layout

\begin_layout LyX-Code
       Dictionary
\end_layout

\begin_layout LyX-Code
          Object
\end_layout

\begin_layout LyX-Code
          StandardClass
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
To add behaviour to a class, we need to add a dynamic variable bound to
 a closure object - in other words we need to define a method
\begin_inset Index
status open

\begin_layout Plain Layout
method
\end_layout

\end_inset

.
 For example a method to compute the square of a number is added to the
 
\emph on
Bignum
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset

 class:
\end_layout

\begin_layout LyX-Code
Bignum
\end_layout

\begin_layout LyX-Code
   def .square() (* 
\series bold
.self .self
\series default
)
\end_layout

\begin_layout Standard
Notice that the method uses the 
\emph on
.self
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
.self
\end_layout

\end_inset

 variable which will be automatically bound to an object.
 Now all Bignums can compute their own square e.g.:
\end_layout

\begin_layout LyX-Code
> 4234389 (.square)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 17930050203321 # Bignum
\end_layout

\begin_layout Standard
We need to call methods in the correct way to ensure they refer to the right
 object since they are dynamic, not lexical variables.
 So if we tried to say:
\end_layout

\begin_layout LyX-Code
> (4234389.square)
\end_layout

\begin_layout Standard
We would get an error.
 There is a big difference between 
\emph on
4234389 (.square)
\emph default
 and 
\emph on
(4234389.square)
\emph default
.
 In the first case we are creating an environment around the Bignum 
\emph on
4234389
\emph default
, then we execute the function bound to the dynamic variable 
\emph on
.square
\emph default
 from Bignum.
 In the second however, we are getting the Bignum's 
\emph on
.square
\emph default
 function but then applying it in the context of the caller.
 This is most likely not what was intended.
 In general, methods should almost always be called in the first way as
 in:
\end_layout

\begin_layout LyX-Code
<object> (<method> <arg1> <arg2> ...
 <argn>)
\end_layout

\begin_layout Standard
Or if there are multiple method calls to be made:
\end_layout

\begin_layout LyX-Code
<object>
\end_layout

\begin_layout LyX-Code
     <method> <arg1> <arg2> ...
 <argn>
\end_layout

\begin_layout LyX-Code
     <method> <arg1> <arg2> ...
 <argn>
\end_layout

\begin_layout LyX-Code
     etc...
\end_layout

\begin_layout Subsection
Defining Your Own Classes 
\end_layout

\begin_layout Standard
Classes are relatively complex objects so the language provides a built-in
 macro for creating new classes and binding them.
 The syntax is straight forward - let's define a class for length units:
\end_layout

\begin_layout LyX-Code
> 
\series bold
class
\begin_inset Index
status open

\begin_layout Plain Layout

\series bold
class
\end_layout

\end_inset


\series default
 Inches()
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
<class Inches (Thing)> # StandardClass Dictionary
\end_layout

\begin_layout Standard
This simply creates a class which is a subclass of
\emph on
 Thing
\emph default
.
 By convention class names begin with an upper-case character.
 We can use this class to annotate existing objects.
 For example:
\end_layout

\begin_layout LyX-Code
> 
\series bold
tag
\series default
 Inches 12
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 12 # Inches Bignum
\end_layout

\begin_layout Standard
The 
\emph on
tag
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
tag
\end_layout

\end_inset


\emph default
 function adds a class to an object's list of classes and returns it.
 Notice the interpreter prints out the list of classes 12 belongs to, now
 including 
\emph on
Inches
\emph default
.
 
\end_layout

\begin_layout Standard
So far so good, now let's add a method to convert to meters.
 Lets assume an 
\emph on
Inches
\emph default
 object is a kind of 
\emph on
Bignum
\emph default
, and add a method to it:
\end_layout

\begin_layout LyX-Code
class Inches(
\series bold
Bignum
\series default
)
\end_layout

\begin_layout LyX-Code
   def .toMeters()
\end_layout

\begin_layout LyX-Code
      * .self 0.0254
\end_layout

\begin_layout Standard
The second parameter to 
\emph on
class 
\emph default
a list of superclasses, in this example, just 
\emph on
Bignum
\emph default
.
 We can now define a foot and convert it as follows:
\end_layout

\begin_layout LyX-Code
define a-foot
\end_layout

\begin_layout LyX-Code
   tag Inches 12
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
> a-foot (
\series bold
.toMeters
\series default
)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 0.3048 # Bignum
\end_layout

\begin_layout Standard
This is fine, but we are still returning a 
\emph on
Bignum
\emph default
.
 Let's refactor to add a 
\emph on
Meters
\emph default
 class and tag the return appropriately:
\end_layout

\begin_layout LyX-Code

\series bold
class Length()
\end_layout

\begin_layout LyX-Code

\series bold
   def .toMeters()
\end_layout

\begin_layout LyX-Code

\series bold
      raise 'Oops - you invoked an abstract class!'
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
class Inches(
\series bold
Length
\series default
)
\end_layout

\begin_layout LyX-Code
   def .toMeters()
\end_layout

\begin_layout LyX-Code
      tag Meters (* .self 0.0254) 
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code

\series bold
class Meters(Length)
\end_layout

\begin_layout LyX-Code

\series bold
   def .toMeters() .self
\end_layout

\begin_layout Standard
Here we have defined an abstract base class and two derived classes which
 both have the .
\emph on
toMeters
\emph default
 method.
 The 
\emph on
raise
\emph default
 function catches invalid use of the 
\emph on
Length
\emph default
 class.
 Lets try the conversion again:
\end_layout

\begin_layout LyX-Code
> 
\series bold
(tag Inches 12)
\series default
 (.toMeters)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 0.3048 # 
\series bold
Meters
\series default
 Bignum 
\end_layout

\begin_layout Standard
Here we are using a sub-expression which returns 
\emph on
12
\emph default
 
\emph on
Inches
\emph default
 and this object is the focus of the call to 
\emph on
.toMeters
\emph default
.
 Note the result is now in 
\emph on
Meters
\emph default
.
 With this new class structure in place we can now add a method to add two
 lengths in any units:
\end_layout

\begin_layout LyX-Code
Length
\end_layout

\begin_layout LyX-Code
   
\series bold
def .add(other)
\end_layout

\begin_layout LyX-Code

\series bold
      tag Meters
\end_layout

\begin_layout LyX-Code

\series bold
         + (.toMeters)
\end_layout

\begin_layout LyX-Code

\series bold
            other (.toMeters)
\end_layout

\begin_layout Standard
This method converts both the current object and the argument to 
\emph on
Meters,
\emph default
 performs the addition and returns the result in 
\emph on
Meters
\emph default
.
 Here's how it runs:
\end_layout

\begin_layout LyX-Code
define a-meter
\end_layout

\begin_layout LyX-Code
   tag Meters 1
\end_layout

\begin_layout LyX-Code
define a-foot (tag Inches 12)
\end_layout

\begin_layout LyX-Code
> a-foot (.add a-meter)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 1.3048 # 
\series bold
Meters
\series default
 Bignum
\end_layout

\begin_layout Standard
This is useful however in the above example a user of our classes could
 get errors by tagging objects which cannot be added together.
 For example a string will fail:
\end_layout

\begin_layout LyX-Code
(tag 
\series bold
Inches '12'
\series default
) (.add (tag Meters 1))          # Error
\end_layout

\begin_layout Standard
To provide protection and we use type checking features and class validators.
\end_layout

\begin_layout Subsection
Type-Checked Function Arguments
\end_layout

\begin_layout Standard
Genyris supports type annotations
\begin_inset Index
status open

\begin_layout Plain Layout
type annotations
\end_layout

\end_inset

 found in most statically typed languages.
 These type checks are purely optional.
 When a function is defined, the arguments and return value may be annotated
 with a class.
 The actual arguments are checked with a validator (if present).
 Here's an example of a sensitive function protected by type checks:
\end_layout

\begin_layout LyX-Code
def safe-call ((a =
\begin_inset Index
status collapsed

\begin_layout Plain Layout
=
\end_layout

\end_inset

 Bignum) (b = Bignum) = Bignum) 
\end_layout

\begin_layout LyX-Code
    fragile-function a b    
\end_layout

\begin_layout Standard
This function only allows Bignums to be passed in or returned.
 The last element of the arguments list specifies the return type.
 If a type check fails an exception is raised.
\end_layout

\begin_layout Subsection
In-Line Type Checks
\end_layout

\begin_layout Standard
Genyris provides another mechanism for checking type constraints.
 The 
\emph on
is?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
is?
\end_layout

\end_inset


\emph default
 function will check if the result of the expression is 
\emph on
.valid
\emph default
?
\emph on

\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.valid?
\end_layout

\end_inset


\emph default
, or if it is an instance of the class.
 For example this function will always raise an error because
\emph on
 3
\emph default
 is not a subclass of 
\emph on
String
\emph default
:
\end_layout

\begin_layout LyX-Code
def fails()
\end_layout

\begin_layout LyX-Code
    define x 3
\end_layout

\begin_layout LyX-Code
    is? x String
\end_layout

\begin_layout Standard
If a class validator is provided, this will be used otherwise a simple 
\begin_inset Quotes eld
\end_inset

nominative
\begin_inset Quotes erd
\end_inset

 type check of class membership based on the object's tagged classes is
 used.
 The 
\emph on
.valid?
\emph default
 method is a stronger check, however nominative checking is sometimes preferred
\begin_inset Foot
status open

\begin_layout Plain Layout
Genyris supports both 
\begin_inset Quotes eld
\end_inset

nominative
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

structural
\begin_inset Quotes erd
\end_inset

 subtyping
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Inheritance and Class Properties
\end_layout

\begin_layout Standard
The inheritance
\begin_inset Index
status open

\begin_layout Plain Layout
inheritance
\end_layout

\end_inset

 mechanism in Genyris works by searching on object's classes list for classes
 which have the dynamic symbol required, it also recursively searches the
 superclasses of all the classes it finds in the classes list.
 The classes are ordered with those classes deepest in the hierarchy first.
 
\begin_inset Foot
status open

\begin_layout Plain Layout
This order is listed when the classes are printed by the command-line interprete
r.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
This inheritance of properties is the same regardless of the type of property
 (method or data).
 Hence an object can access information stored in it's classes and superclasses.
 Here's an example where a base class supplies a boolean value to an object:
\end_layout

\begin_layout LyX-Code
class Orange()
\end_layout

\begin_layout LyX-Code
   define .pips ^true
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
> (tag Orange 'my lunch').pips
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ true # Symbol 
\end_layout

\begin_layout Subsection
Class Validators
\end_layout

\begin_layout Standard
To help define membership of a class, the class can provide a 
\emph on
.valid?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.valid?
\end_layout

\end_inset


\emph default
 predicate method.
 This can assess an object and return 
\emph on
true
\emph default
 if it is a valid member of the class.
 The 
\emph on
tag
\emph default
 function calls 
\emph on
.valid?
\emph default
 if provided and fails when 
\emph on
.valid?
\emph default
 returns 
\emph on
nil
\emph default
.
 We can add a validator to our example base class:
\end_layout

\begin_layout LyX-Code
Length
\end_layout

\begin_layout LyX-Code
   
\series bold
def .valid?(obj)
\end_layout

\begin_layout LyX-Code

\series bold
      is-instance? obj Bignum
\end_layout

\begin_layout Standard
The 
\emph on
is-instance?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
is-instance?
\end_layout

\end_inset


\emph default
 function only returns true if the object is an instance of 
\emph on
Bignum
\emph default
 or its subclasses.
 This prevents anything except numbers being tagged.
 
\end_layout

\begin_layout Subsection
Traditional Constructors and Factories
\end_layout

\begin_layout Standard
While the philosophy of Genyris is to classify objects after construction,
 it does not inhibit using traditional constructors
\begin_inset Index
status open

\begin_layout Plain Layout
constructors
\end_layout

\end_inset

 in classes.
 'Factory' functions for object construction are preferred even in traditional
 languages.
 Factory functions are simply functions which construct the appropriate
 kind of object based on the inputs given.
 A factory/constructor can be as simple as this:
\end_layout

\begin_layout LyX-Code
class Person ()
\end_layout

\begin_layout LyX-Code
   def .new (name date-of-birth)
\end_layout

\begin_layout LyX-Code
      dict
\end_layout

\begin_layout LyX-Code
         .name = name
\end_layout

\begin_layout LyX-Code
         .dob = date-of-birth
\end_layout

\begin_layout LyX-Code
         .classes = (list Person)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
Person!new 'Jo' 23
\end_layout

\begin_layout Standard
A more general approach is to provide a 
\begin_inset Quotes eld
\end_inset


\emph on
new
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
new
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 function which calls a class-specific 
\begin_inset Quotes eld
\end_inset


\emph on
init
\emph default

\begin_inset Quotes erd
\end_inset

 function.
 For example here is a class with an 
\emph on
.init
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.init
\end_layout

\end_inset


\emph default
 member which creates properties in a dict created by 
\emph on
.new
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.new
\end_layout

\end_inset


\emph default
:
\end_layout

\begin_layout LyX-Code
class PersonTraditional (Object)
\end_layout

\begin_layout LyX-Code
   def .init((name = String) (age = Bignum))
\end_layout

\begin_layout LyX-Code
      define .name name
\end_layout

\begin_layout LyX-Code
      define .age age
\end_layout

\begin_layout Standard

\emph on
Object
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Object
\end_layout

\end_inset

s
\emph default
 are created by calling 
\emph on
.new
\emph default
: 
\end_layout

\begin_layout LyX-Code
> PersonTraditional (.new 'Abe' 99)
\end_layout

\begin_layout LyX-Code
dict
\end_layout

\begin_layout LyX-Code
      .age = 99
\end_layout

\begin_layout LyX-Code
      .name = 'Abe' # PersonTraditional Dictionary
\end_layout

\begin_layout Standard
Here is a simple implementation of 
\emph on
.new
\emph default
 in a base class:
\end_layout

\begin_layout LyX-Code
class Object (Dictionary)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  def .new(&rest args)
\end_layout

\begin_layout LyX-Code
      (tag .self (dict))                     
\end_layout

\begin_layout LyX-Code
         apply .init args
\end_layout

\begin_layout LyX-Code
         .self
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
   # NOOP .init method
\end_layout

\begin_layout LyX-Code
   def .init(&rest args)
\end_layout

\begin_layout LyX-Code
      .self
\end_layout

\begin_layout Standard
This 
\emph on
.new
\emph default
 collects all the input arguments via the 
\emph on
&rest
\emph default
 keyword, it creates an empty 
\emph on
dict
\emph default
, tags it with the derived class and passes the collected arguments to the
 class's 
\emph on
.init
\emph default
 function.
 The default 
\emph on
.init
\emph default
 function returns the new object un-modified.
\end_layout

\begin_layout Subsection
Automating Classification
\end_layout

\begin_layout Standard
This language embodies the opinion that objects are created first, then
 they are classified - rather than the classification
\begin_inset Index
status open

\begin_layout Plain Layout
classification
\end_layout

\end_inset

 being determined during object construction.
 Let's explore how the 
\emph on
.valid?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.valid?
\end_layout

\end_inset


\emph default
 predicates can be used to automate classification.
 
\end_layout

\begin_layout Standard
Validator functions can be developed to any complexity required.
 For example validators can inspect the 
\bar under
values
\bar default
 of properties and objects rather than just their type.
 Here's an example which is 
\emph on
true
\emph default
 for even numbers:
\end_layout

\begin_layout LyX-Code
class EvenNumber()
\end_layout

\begin_layout LyX-Code
  
\series bold
def .valid?(x)
\end_layout

\begin_layout LyX-Code

\series bold
      equal? (% x 2) 0
\end_layout

\begin_layout Standard
Validators provide a way to automatically categorize unknown objects - an
 important tool for input validation.
\end_layout

\begin_layout Standard
The Genyris distribution includes file "examples/classify.g" which shows
 this pattern.
 It defines a simple 
\emph on
classify
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
classify
\end_layout

\end_inset


\emph default
 function which recursively walks the class hierarchy testing an object's
 compliance with validators.
 There is an example of classification of people into classes based on age
 and possessions.
 We load the source files 
\begin_inset Foot
status open

\begin_layout Plain Layout
The 
\emph on
load
\emph default
 function reads an executes the source file from the Java classpath.
 Genyris initialization code source files are stored within the Java 
\begin_inset Quotes eld
\end_inset

jar
\begin_inset Quotes erd
\end_inset

 file.
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code

\series bold
include
\series default
 'examples/people.g'
\end_layout

\begin_layout Standard
This creates an un-classified object, assigns it to a variable 
\emph on
kevin
\emph default
, and calls 
\emph on
classify
\emph default
:
\end_layout

\begin_layout LyX-Code
define kevin
\end_layout

\begin_layout LyX-Code
  dict
\end_layout

\begin_layout LyX-Code
     .name= 'Kevin'
\end_layout

\begin_layout LyX-Code
     .age= 49
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code

\series bold
classify Person kevin
\end_layout

\begin_layout Standard
We now display the object
\end_layout

\begin_layout LyX-Code
> kevin
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
dict
\end_layout

\begin_layout LyX-Code
      .age = 49
\end_layout

\begin_layout LyX-Code
      .name = 'Kevin' # Boomer Dictionary
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
The result shows the classifier has recognised 
\emph on
kevin
\emph default
 as a 
\emph on
Boomer
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Boomer
\end_layout

\end_inset


\emph default
.
 Here are the classes that make this happen:
\end_layout

\begin_layout LyX-Code
class Person ()
\end_layout

\begin_layout LyX-Code
   def .valid? (obj)
\end_layout

\begin_layout LyX-Code
      obj
\end_layout

\begin_layout LyX-Code
         bound? .age
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
class Boomer (Person)
\end_layout

\begin_layout LyX-Code
   
\series bold
def .valid? (obj)
\end_layout

\begin_layout LyX-Code
      
\series bold
obj  
\series default
                        
\end_layout

\begin_layout LyX-Code
        
\series bold
 between 45 .age 60   
\series default
   
\end_layout

\begin_layout Standard
To be a valid 
\emph on
Person
\emph default
 kevin must have an the 
\emph on
.age
\emph default
 property, and to be a 
\emph on
Boomer
\emph default
 it's value must be between 45 and 60.
 The 
\emph on
classify
\emph default
 function only calls the derived class's validator if object is in the base
 class.
 It tagged 
\emph on
kevin
\emph default
 with the 
\emph on
Boomer
\emph default
 class.
\end_layout

\begin_layout Standard
This technique can be used to categorise a program's inputs or validate
 output data, and even re-validate previously classified objects.
\end_layout

\begin_layout Subsection
On Ducks and Interfaces
\end_layout

\begin_layout Standard
'Duck' typing in a language is jargon for 'structural' subtyping - 
\emph on
If it looks like a duck and quacks like a duck - then it is a duck
\emph default
.
 Duck typing
\begin_inset Index
status open

\begin_layout Plain Layout
Duck typing
\end_layout

\end_inset

 relies on programmers to ensure that objects passed around actually do
 have the properties and methods expected by the downstream code.
 If there is a mis-match then eventually an error will result.
 For example if we could define a 
\emph on
.copy
\emph default
 function which expects some kind of stream object with 
\emph on
.next
\emph default
 and 
\emph on
.last? 
\emph default
methods.
 There is no need to perform type-checking in the interface since if the
 methods exits all will be well.
 Duck typing is perfectly adequate for most programming tasks, however many
 developers like to formalize the interfaces.
 
\end_layout

\begin_layout Standard
In Genyris an Interface could be defined by
\emph on
 
\emph default
either providing an appropriate validator or by simply tagging objects with
 their supported interface classes.
 For example here is a class validator for the above scenario:
\end_layout

\begin_layout LyX-Code
class Stream-Interface()
\end_layout

\begin_layout LyX-Code
   def .valid?(object)
\end_layout

\begin_layout LyX-Code
      object
\end_layout

\begin_layout LyX-Code
         and
\end_layout

\begin_layout LyX-Code
            bound? .next
\end_layout

\begin_layout LyX-Code
            is-instance? .next Closure
\end_layout

\begin_layout LyX-Code
            bound? .last
\end_layout

\begin_layout LyX-Code
            is-instance? .last Closure 
\end_layout

\begin_layout Standard
The validator here checks whether the object has 
\emph on
.next
\emph default
 and 
\emph on
.last
\emph default
 properties, and whether they are procedure objects.
 
\end_layout

\begin_layout Section
Symbols and Semantic Triples
\end_layout

\begin_layout Standard
RDF
\begin_inset Index
status open

\begin_layout Plain Layout
RDF
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Resouce Description Framework
\end_layout

\end_inset

 concepts such as triples
\begin_inset Index
status open

\begin_layout Plain Layout
triple
\end_layout

\end_inset

 and triplestores
\begin_inset Index
status open

\begin_layout Plain Layout
triplestore
\end_layout

\end_inset

 are available in Genyris as part of the language.
 Although these were made popular by the Semantic Web these Description
 Logic ideas can be used in general programming.
 The Genyris implementation removes some of the constraints of RDF and allows
 these ideas to applied at the program object level.
 The goal is for all developers to be beneficiaries of these elegent data
 structures and algorithms, not just those concerned with Semantic Web problems.
 
\end_layout

\begin_layout Standard
Triples and triplestores which are derived from Description Logic also form
 the foundation for the Genyris 
\emph on
type system
\emph default
.
 The type system will allow data, classes and functions to be 'marked-up'
 with meta-data describing their allowed properties and behaviours.
 
\end_layout

\begin_layout Standard
Description Logic techniques allow great flexibilty and power in the addition
 of meta-data and inference.
 We hope in time Genyris developers will have access to higher-order tools
 which are available for RDF and OWL within the context of their Genyris
 application programming.
\end_layout

\begin_layout Subsection
Triples
\end_layout

\begin_layout Standard
Genyris includes triples as a first-class system object.
 Triples are described in the W3C RDF Primer document, amongst others.
 A triple
\begin_inset Index
status open

\begin_layout Plain Layout
triple
\end_layout

\end_inset

 consists of three atoms, a 
\emph on
Subject
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Subject
\end_layout

\end_inset


\emph default
 , 
\emph on
Predicate
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Predicate
\end_layout

\end_inset


\emph default
 and 
\emph on
Object
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Object
\end_layout

\end_inset


\emph default
.
 Each triple is a simple descriptive statement about the relationships between
 objects or their properties.
 For example the triple:
\end_layout

\begin_layout LyX-Code
UnixBox1 hasUser root
\end_layout

\begin_layout Standard
Says that the machine UnixBox1 has a user account 'root'.
 
\end_layout

\begin_layout Standard
In Genyris the 
\emph on
Subject
\emph default
 of a triple may be any language object, including atoms and 'literals'
 in RDF terms.
 This allows statements to be made about any object in the system.
 Another way of viewing this is that any object in the system may have arbitrary
 properties, stored in triples.
 
\end_layout

\begin_layout Standard
The 
\emph on
Predicate
\emph default
 of a triple however, must be a symbol.
 This ensures that the statement is at least, readable.
\end_layout

\begin_layout Standard
Any language item may be the 
\emph on
Object
\emph default
 of a triple.
 This allows relationships between any two language items to be recorded.
 
\end_layout

\begin_layout Standard
Triples alone are not particularly useful without a way of comparing them
 and managing them.
 
\emph on
Triplestores
\begin_inset Index
status open

\begin_layout Plain Layout
triplestore
\end_layout

\end_inset

 
\emph default
(as the name suggests) are in-memory sets of triples with functions for
 searching for, adding and removing triples.
 Because Genyris triples may have any object as their subjects, Triplestores
 are used where other languages may rely on hash-tables.
 Triplestores in their turn can be used as sets, with comparison, intersection
 and union functions.
\end_layout

\begin_layout Subsubsection
Creating triples with 
\emph on
triple
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
triple
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Triple objects are created by the 
\emph on
triple
\emph default
 function which takes three arguments, the 
\emph on
subject, predicate
\emph default
 and 
\emph on
object.
 
\emph default
The 
\emph on
predicate 
\emph default
must be a Symbol.

\emph on
 Example
\emph default
s:
\end_layout

\begin_layout LyX-Code
> triple ^Lewis ^hasMother ^Mae
\end_layout

\begin_layout LyX-Code
(triple Lewis hasMother Mae) # Triple
\end_layout

\begin_layout LyX-Code
> triple 23 ^hasUnits ^Inches
\end_layout

\begin_layout LyX-Code
(triple 23 hasUnits Inches) # Triple
\end_layout

\begin_layout Subsubsection
Accessing parts of a triple with 
\emph on
.subject
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
.subject
\end_layout

\end_inset

, 
\emph on
.predicate
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
.predicate
\end_layout

\end_inset

 and 
\emph on
.object
\begin_inset Index
status open

\begin_layout Plain Layout
.object
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The components of the triples can be accessed with the above dynamic symbols.
 For example:
\end_layout

\begin_layout LyX-Code
> var l 
\end_layout

\begin_layout LyX-Code
   triple ^Lewis ^hasMother ^Mae
\end_layout

\begin_layout LyX-Code
(triple Lewis hasMother Mae) # Triple
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> list l!object l!subject l!predicate
\end_layout

\begin_layout LyX-Code
(Mae Lewis hasMother) # Pair
\end_layout

\begin_layout Subsubsection
Triple Equality
\end_layout

\begin_layout Standard
Two triples are considered 
\emph on
equal?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
equal?
\end_layout

\end_inset


\emph default
 if the subjects and predicates are 
\emph on
eq? 
\emph default
and the objects are 
\emph on
equal?.
 
\emph default
The 
\emph on
equal?
\emph default
 test for the 
\emph on
object
\emph default
 means that strings, integers and lists which look the same will be treated
 as equal.
 Refer also to the definitions of 
\emph on
eq?
\emph default
 and 
\emph on
equal?
\emph default
.
 This style is designed to allow simple literals to be used as objects such
 as 
\emph on
12.3
\emph default
 and 
\emph on

\begin_inset Quotes eld
\end_inset

Joe
\begin_inset Quotes erd
\end_inset


\emph default
.
 If networks of triples are required in an application, then the objects
 are also subjects.
 In this case Dictionaries or Symbols are recommended since their equality
 is specific.
\end_layout

\begin_layout Standard
For example:
\end_layout

\begin_layout LyX-Code
> equal? (triple ^S ^P 12.3) (triple ^S ^P 12.3)
\end_layout

\begin_layout LyX-Code
true # SimpleSymbol
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> equal? (triple 123 ^p "yes") (triple 123 ^p "yes")
\end_layout

\begin_layout LyX-Code
nil # SimpleSymbol
\end_layout

\begin_layout Subsection
TripleStores
\end_layout

\begin_layout Standard
Genyris provides a special container class for triples, the 'triplestore
\begin_inset Index
status open

\begin_layout Plain Layout
triplestore
\end_layout

\end_inset

'.
 Triplestores are really just a set of triples, since all triples within
 the store are unequal.
 Triplestores are not persisted (saved on disk) they are purely in-memory
 objects.
 Triplestores are used as lookup tables (instead of a hashtable) and they
 are used for more complex comparisons between sets of triples.
 The speed of the current implementation is inversely proportional to the
 number of triples in the store.
\end_layout

\begin_layout Subsubsection
Creating TripleStores with 
\emph on
tripleStore
\end_layout

\begin_layout Standard
The 
\emph on
triplestore
\begin_inset Index
status open

\begin_layout Plain Layout
triplestore
\end_layout

\end_inset


\emph default
 function constructs a triplestore object.
 It accepts an option list of 3-lists which are converted to triples.
 Example:
\end_layout

\begin_layout LyX-Code
> triplestore 
\end_layout

\begin_layout LyX-Code
   ^(joe age three) 
\end_layout

\begin_layout LyX-Code
   ^(joe age ten)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(triplestore) # Triplestore
\end_layout

\begin_layout Subsubsection
TripleStore equality
\end_layout

\begin_layout Standard
Two triplestores are 
\emph on
equal?
\emph default
 if their constituent triples have an equal triple in the other triplestore
 and vice versa.
 
\end_layout

\begin_layout Subsubsection
Adding Triples with 
\emph on
.add
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.add
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
.add
\emph default
 method adds a triple to a triplestore.
 If the triple is already present no error is thrown.
 The triplestore object is returned.
 Syntax is:
\end_layout

\begin_layout Standard

\emph on
.add <triple>
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
ts(.add (triple ^s ^p ^o))
\end_layout

\begin_layout Subsubsection
Removing Triples with 
\emph on
.remove
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.remove
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
.remove
\emph default
 method removes a single triple from a triplestore.
 If the triple is already absent no error is thrown.
 The triplestore object is returned.
 Syntax is:
\end_layout

\begin_layout Standard

\emph on
.remove <triple>
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
ts(.remove (triple ^s ^p ^o))
\end_layout

\begin_layout Subsubsection
Querying Triples with 
\emph on
.select
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.select
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
.select
\emph default
 method provides a way of iterating over the set of triples in the triplestore
 and returning a new triplestore with triples of interest.
 Syntax:
\end_layout

\begin_layout LyX-Code

\emph on
.select <subject> <predicate> <object> [<procedure>]
\end_layout

\begin_layout Standard
The function iterates through every triple in the triplestore, if the 
\emph on
<subject>
\emph default
, 
\emph on
<predicate>
\emph default
 and 
\emph on
<object>
\emph default
 parameters match those of the triple it is added to the result set.
 Nil parameters are ignored
\begin_inset Foot
status open

\begin_layout Plain Layout
This is likely to change since 
\emph on
nil
\emph default
 is not matchable.
\end_layout

\end_inset

.
 Matching is performed as for triple equality rules.
 Thus 
\emph on
(.select nil nil nil)
\emph default
 matches all triples.
 Matching rules:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Predicate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
subject
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
eq?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
predicate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
eq?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
property
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal?
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
If the last parameter is present it must be a procedure which takes three
 parameters of the form:
\end_layout

\begin_layout LyX-Code

\emph on
function
\emph default
 
\emph on
(<subject> <predicate> <object>)
\emph default
 
\end_layout

\begin_layout Standard
If the triple is matched, then this function is called with the triple's
 subject, predicate and object as actual parameters.
 If the function returns a non
\emph on
-nil
\emph default
 value then the triple is added to the result set.
 The matching logic is equivalent to:
\end_layout

\begin_layout LyX-Code
and
\end_layout

\begin_layout LyX-Code
   eq? <subject> .subject
\end_layout

\begin_layout LyX-Code
   eq? <predicate> .predicate
\end_layout

\begin_layout LyX-Code
   equal? <object> .object
\end_layout

\begin_layout LyX-Code
   <procedure> .subject .predicate .object
\end_layout

\begin_layout Standard
Here is a simple example: of select in use:
\end_layout

\begin_layout LyX-Code
var ts
\end_layout

\begin_layout LyX-Code
   triplestore 
\end_layout

\begin_layout LyX-Code
      ~ ^(joe age three)
\end_layout

\begin_layout LyX-Code
      ~ ^(joe age ten)
\end_layout

\begin_layout LyX-Code
      ~ ^("John" age 22)
\end_layout

\begin_layout LyX-Code
      ~ ^("John" height 223)
\end_layout

\begin_layout LyX-Code
var result
\end_layout

\begin_layout LyX-Code
   ts
\end_layout

\begin_layout LyX-Code
     .select ^joe nil nil
\end_layout

\begin_layout LyX-Code
assert
\end_layout

\begin_layout LyX-Code
   equal?
\end_layout

\begin_layout LyX-Code
      result
\end_layout

\begin_layout LyX-Code
      triplestore ^(joe age three) ^(joe age ten)
\end_layout

\begin_layout Subsubsection
Retrieving unique values with 
\emph on
.get
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.get
\end_layout

\end_inset

 subject predicate
\end_layout

\begin_layout Standard
Often triplestores will contain unique triples
\begin_inset Index
status open

\begin_layout Plain Layout
unique triples
\end_layout

\end_inset

, ie there is only one triple with the same 
\emph on
subject
\emph default
 and predicate.
 The 
\emph on
.get 
\emph default
method retrieves the 
\emph on
object
\emph default
 of this triple.
 If there is more than one matching triple, or none, an error is raised.
 
\end_layout

\begin_layout Standard
Syntax:
\end_layout

\begin_layout LyX-Code
<triplestore> (.get subject predicate)
\end_layout

\begin_layout Subsubsection
Retrieving multiple values with 
\emph on
.get-list
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.get-list
\end_layout

\end_inset

 subject predicate
\end_layout

\begin_layout Standard
The 
\emph on
.get-list 
\emph default
method retrieves a list containing all the 
\emph on
objects
\emph default
 of the triples which have the 
\emph on
subject
\emph default
 and 
\emph on
predicate
\emph default
 specified.
 If there is no matching triple 
\emph on
NIL
\emph default
 is returned.
 Syntax:
\end_layout

\begin_layout LyX-Code
<triplestore> (.get-list subject predicate)
\end_layout

\begin_layout Subsubsection
Updating with 
\emph on
.put
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.put
\end_layout

\end_inset


\emph default
 
\emph on
subject predicate object
\end_layout

\begin_layout Standard
The 
\emph on
put
\emph default
 method removes all triples from the triplestore with the matching 
\emph on
subject
\emph default
 and 
\emph on
predicate
\emph default
, then adds a single triple with the 
\emph on
subject predicate object 
\emph default
specified
\emph on
.
 
\emph default
If there are no matching triples no error is raised, the triple is simply
 added.
 This operation is intended to support the pattern of a unique triples
\begin_inset Index
status open

\begin_layout Plain Layout
unique triples
\end_layout

\end_inset

, where it serves as an update operation.
 
\end_layout

\begin_layout Subsubsection
Fetching all the triples with 
\emph on
.asTriples
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.asTriples
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
.asTriples 
\emph default
method returns a list containing all the triples in the triplestore.
\end_layout

\begin_layout Subsubsection
Triplification with 
\emph on
.asTripleStore
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.asTripleStore
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
This method is not fully implemented for all types.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All objects in Genyris can be converted into a series of triples depending
 on their type.
 Typically this results in a type triple for each of the object's classes,
 and properties as individual triples.
 Examples:
\end_layout

\begin_layout LyX-Code
> 
\emph on
class Inches
\end_layout

\begin_layout LyX-Code
<class Inches (Thing)> # StandardClass
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> 
\emph on
var foot (tag Inches 12)
\end_layout

\begin_layout LyX-Code
12 # Inches Bignum
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> 
\emph on
(foot(.asTripleStore))(.asTriples))
\end_layout

\begin_layout LyX-Code
((triple 12 type <class Inches (Thing)>) 
\end_layout

\begin_layout LyX-Code
 (triple 12 type <class Bignum (Builtin)>)) # Pair 
\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout LyX-Code
> 
\emph on
(^(1 2)(.asTripleStore))(.asTriples)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
((triple (1 2) type <class Pair (Builtin)>)) # Pair 
\end_layout

\begin_layout Subsubsection
Adding Meta-Data to Triples
\end_layout

\begin_layout Standard
Triples can belong to multiple classes just like any other Genyris object.
 This allows them to be annotated and have classes and methods.
 For example here we tag a triple as being factual:
\end_layout

\begin_layout LyX-Code
> 
\emph on
class Fact
\end_layout

\begin_layout LyX-Code
<class Fact (Thing)> # StandardClass 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> 
\emph on
var kr (triple ^KevinRudd ^role ^PrimeMinister)
\end_layout

\begin_layout LyX-Code
(triple KevinRudd
\begin_inset Index
status open

\begin_layout Plain Layout
KevinRudd
\end_layout

\end_inset

 role PrimeMinister) # Triple 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> 
\emph on
tag Fact kr
\end_layout

\begin_layout LyX-Code
(triple KevinRudd role PrimeMinister) # Fact Triple 
\end_layout

\begin_layout Standard
Triples can also be the subject of other triples which means complex meta-descri
ptions are possible without resorting to reification.
 Here is the example above expressed with another triple.
\end_layout

\begin_layout LyX-Code
> var meta-kr (triple kr ^Belief ^Fact)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(triple (triple KevinRudd role PrimeMinister) Belief Fact) # Triple 
\end_layout

\begin_layout Standard
Triples and triplestores allow the programmer to store information about
 objects which may not have a means of adding properties of their own beyond
 their class membership list.
 
\end_layout

\begin_layout Part
Reference
\end_layout

\begin_layout Section
Building From Source
\end_layout

\begin_layout Subsection
Obtaining Source from the Released Files
\end_layout

\begin_layout Standard
The source code for released binaries can be downloaded from the URL below
 and unzipped.
 
\end_layout

\begin_layout LyX-Code
http://sourceforge.net/projects/genyris/files/
\end_layout

\begin_layout Standard
Download the source release file 
\emph on
genyris-source-NNN-DDDDDDD.zip , 
\emph default
unzip the file to a working directory.
 Change directory to the root of the unpacked directory.
\end_layout

\begin_layout Subsection
Obtaining source from the Mercurial Repository
\end_layout

\begin_layout Standard
The source code of Genyris is published to a Mercurial clone hosted by SourceFor
ge.
 This code will be the latest code, whereas the binary releases re slightly
 older.
 To access the default Mercurial repository, configure your Mercurial client
 as follows: 
\end_layout

\begin_layout LyX-Code
http://genyris.hg.sourceforge.net:8000/hgroot/genyris/genyris
\end_layout

\begin_layout Standard
Then do an 
\emph on
hg pull
\emph default
 to download the source.
\end_layout

\begin_layout Subsection
The Build
\end_layout

\begin_layout Standard
To compile from source you need install 
\emph on
Ant
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Ant
\end_layout

\end_inset


\emph default
 (version 1.7.1 or later).
 Then run the following command to build the program:
\end_layout

\begin_layout LyX-Code
$ ant
\end_layout

\begin_layout Standard
At the end of the build you should see a summary of tests passed:
\end_layout

\begin_layout LyX-Code
OK (212 tests)
\end_layout

\begin_layout Subsection
Running Genyris
\begin_inset CommandInset label
LatexCommand label
name "sec:Running-Genyris"

\end_inset


\end_layout

\begin_layout Subsubsection
Simplified Launching via the Path
\end_layout

\begin_layout Standard
The distribution includes shell and batch files for simplified launching,
 both which require a change to the user's environment.
 
\end_layout

\begin_layout Paragraph
Unix
\end_layout

\begin_layout Standard
Add an environment variable called 
\emph on
GENYRIS_HOME
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
GENYRIS_HOME
\end_layout

\end_inset


\emph default
 which contains the path of the unpacked release.
 Modify your 
\emph on
PATH
\emph default
 environment variable to include 
\emph on
$GENYRIS_HOME/bin
\emph default
.
 The interpreter can then be launched from the shell with 
\end_layout

\begin_layout LyX-Code

\emph on
$ genyri
\emph default
s
\end_layout

\begin_layout Paragraph
Windows
\end_layout

\begin_layout Standard
On Windows the arrangement is similar.
 Add an environment variable called 
\emph on
GENYRIS_HOME
\emph default
.
 Modify the 
\emph on
PATH
\emph default
 environment variable to include 
\emph on
%GENYRIS_HOME%
\backslash
bin:
\emph default
 (from the GUI Start > Control Panel > System > Advanced > Environment Variables
 > New).
 Now the interpreter can then be launched from the command prompt with 
\emph on
genyri
\emph default
s.
\end_layout

\begin_layout Subsubsection
Command line options
\end_layout

\begin_layout Standard
Genyris is started by the Java interpreter from the command line
\begin_inset Index
status open

\begin_layout Plain Layout
command line
\end_layout

\end_inset

.
 Java options are used to specify which main class.
 to use.
 There are multiple 
\emph on
main 
\emph default
classes in the genyris-bin jar so the main class can be specified explicitly
 with 
\emph on
-cp
\emph default
 syntax.
 
\end_layout

\begin_layout Paragraph
Using Genyris standard IO command-line interpreter.
\end_layout

\begin_layout Standard
The java 
\emph on
-jar
\emph default
 option specifies the jar to execute.
 For example:
\end_layout

\begin_layout LyX-Code
$ 
\series bold
java -jar genyris-bin-nnn-xxxxxxxxx.jar
\end_layout

\begin_layout Standard
Since the default main class is the REPL commandline it is automatically
 chosen by the -jar option.
 The same REPL class above can be run identically as as follows: 
\end_layout

\begin_layout LyX-Code
$ java -cp genyris-bin.jar org.genyris.interp.ClassicReadEvalprintLoop 
\end_layout

\begin_layout Standard
In both cases all subsequent shell command line arguments are ignored.
 The session is terminated when the interpreter read and End-Of-File from
 the standard input (^D on UNIX or ^Z on Windows).
\end_layout

\begin_layout Subparagraph
The top level
\end_layout

\begin_layout Standard
Genyris commands can be typed at the prompt, using two carriage returns
 (
\begin_inset Formula $\hookleftarrow$
\end_inset

) to terminate a statement.
 The CLI reads the next indented expression, evaluates it in the global
 environment and prints the result.
 It also appends a comment consisting of the names of the classes of the
 result.
 This allows the user to verify the correct classes have been returned.
\end_layout

\begin_layout Paragraph
Running a script in the command line
\end_layout

\begin_layout LyX-Code
DOS> genyris -eval print 'hello world'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
unix$ genyris -eval print 'hello world'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
If the return value of the expression is printed, the process exits with
 a 0 status, otherwise 1.
\end_layout

\begin_layout Paragraph
Specify a file to run on the command line
\end_layout

\begin_layout LyX-Code
$ genyris examples/queens.g 5
\end_layout

\begin_layout Standard
Arguments are passed after the file name.
\end_layout

\begin_layout Paragraph
Making a script executable (Unix)
\end_layout

\begin_layout Standard
If a script begins with 
\emph on
#!
\emph default
 it allows the Unix kernel to run the script directly.
 Here's an example script:
\end_layout

\begin_layout LyX-Code
#!/usr/bin/sh /opt/home/birchb/workspace/genyris/bin/genyris
\end_layout

\begin_layout LyX-Code
display 'Hello World'
\end_layout

\begin_layout Standard
if the script is made executable it can be run directly:
\end_layout

\begin_layout LyX-Code
$ chmod u+x myscript.g
\end_layout

\begin_layout LyX-Code
$ ./myscript.g
\end_layout

\begin_layout Subsubsection
Interpreter Boot sequence
\end_layout

\begin_layout Standard
Regardless of the enclosing main class, the interpreter boot sequence is
 the same.
 After initialisation the interpreter searches for the resource 
\begin_inset Quotes eld
\end_inset


\emph on
org/genyris/load/boot/init.g
\emph default

\begin_inset Quotes erd
\end_inset

 in the Java classpath and executes it.
 This file is provided in the genyris-bin jar file and contains a Genyris
 bootstrap which in loads other source files also provided within the jar
 file.
 This is equivalent to executing :
\end_layout

\begin_layout LyX-Code

\series bold
load
\series default
 'org/genyris/load/boot/init.g
\begin_inset Index
status open

\begin_layout Plain Layout
init.g
\end_layout

\end_inset

'
\end_layout

\begin_layout Subsection
Loading Source Files
\end_layout

\begin_layout Standard
Functions are provided to allow files of source code to be read and executed.
 The parser to be used is automatically selected based on the fule suffix.
 The following suffixes and parsers are supported:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
suffix
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parser Class
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Syntax
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lin
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parser
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Genyris indented syntax
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lsp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ParenParser
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Free format LISP Syntax with parentheses in place of indentation.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
load
\begin_inset Index
status open

\begin_layout Plain Layout
load
\end_layout

\end_inset

 
\emph on
<java resource name>
\end_layout

\begin_layout Standard
The 
\emph on
load
\emph default
 function reads and executes a source file from the Java classpath.
 Some initialization code files are stored within the distributed binary
 Java 
\begin_inset Quotes eld
\end_inset

jar
\begin_inset Quotes erd
\end_inset

 file .
 The 
\emph on
<java resource name>
\emph default
 parameter is a full path to the file.
 For example:
\end_layout

\begin_layout LyX-Code

\series bold
load
\series default
 'examples/people.g'
\end_layout

\begin_layout Subsubsection
include
\begin_inset Index
status open

\begin_layout Plain Layout
include
\end_layout

\end_inset

 
\emph on
<path to filename>
\end_layout

\begin_layout Standard
The 
\emph on
include
\emph default
 function reads and executes files of scripts in the global environment.
 The <path to filename> parameter refers to a normal operating system file
 path.
 Examples:
\end_layout

\begin_layout LyX-Code
include 'examples/people.g'   # relative path
\end_layout

\begin_layout LyX-Code
include 'c:/workspace/genyris/examples/queens.g'  # absolute path - Windows
\end_layout

\begin_layout Standard
The return value is a string with the actual file path loaded.
 If the file cannot be found an exception is raised.
\end_layout

\begin_layout Subsubsection
sys:import
\begin_inset Index
status open

\begin_layout Plain Layout
sys:import
\end_layout

\end_inset

 <filename name>
\end_layout

\begin_layout Standard
The 
\emph on
sys:import
\emph default
 function is similar to the include function in that it reads and executes
 a file of Genyris source code.
 However the code is executed
\emph on
 in the environment of the caller
\emph default
.
 Therefore in a lexical environment, new bindings created by 
\emph on
define
\emph default
 and 
\emph on
def 
\emph default
et.
 al.
 will be created locally.
 In a deynamic environment such as in a Dictionary, the dynamic bindings
 in the top level of the file will affect the caller's object.
 This function is used by the 
\emph on
import
\emph default
 facility to define modules.
 
\end_layout

\begin_layout Subsubsection
import <module name>
\end_layout

\begin_layout Standard
The 
\emph on
import
\emph default
 macro uses 
\emph on
sys:import
\emph default
 to create dictionaries in which the file's bindings are held.
 To allow users to have multipe calls to 
\emph on
import
\emph default
, yet all refer to the same object, 
\emph on
import
\emph default
 stores all module dictionaries in the 
\emph on
sys:modules
\emph default
 triplestore.
 This triplestore contains a binding between the module name and the module
 object.
 When the import is called it checks to see if the module has already been
 loaded, if so it binds the module to a variable of the same name in the
 caller's environment.
 Hence there may be many bindings of the module name to the same physical
 object.
\end_layout

\begin_layout Standard
To simplify loading, the 
\emph on
import
\emph default
 macro searches for a file with the name of the module plus the 
\emph on
'.g'
\emph default
 suffix.
 It uses the list of directories in the 
\emph on
sys:path
\emph default
 variable for the search path and uses the first matching file it finds.
 Example:
\end_layout

\begin_layout LyX-Code
sys:path = (cons 'examples' sys:path)
\end_layout

\begin_layout LyX-Code
import queens
\end_layout

\begin_layout LyX-Code
queens!queens 5  # call the module's public function
\end_layout

\begin_layout Subsubsection
reload <module name>
\end_layout

\begin_layout Standard
The 
\emph on
reload
\emph default
 macro uses the existing module's filename to reload the source code of
 the module.
 If there are multiple bindings to the module, only the caller will have
 a binding to the new module.
 The binding in the 
\emph on
sys:modules
\emph default
 triplestore is replace with the new object.
 Other references to the module will still refer to the old module.
 
\end_layout

\begin_layout Subsection
Syntax
\end_layout

\begin_layout Subsubsection
Indented Format
\end_layout

\begin_layout Subsubsection
~ for line continuation
\end_layout

\begin_layout Subsubsection
Lisp Format
\end_layout

\begin_layout Subsubsection
carat ^
\end_layout

\begin_layout Subsubsection
Equals =
\end_layout

\begin_layout Subsubsection
Parentheses ()
\end_layout

\begin_layout Subsubsection
comments #
\end_layout

\begin_layout Subsubsection
accessing dynamic variables with .
\end_layout

\begin_layout Subsubsection
comma ,
\end_layout

\begin_layout Subsubsection
comma-at ,@
\end_layout

\begin_layout Subsubsection
backquote `
\end_layout

\begin_layout Subsubsection
[] and {}
\end_layout

\begin_layout Subsubsection
parser directives
\end_layout

\begin_layout Subsubsection
@prefix
\end_layout

\begin_layout Subsection
Evaluation
\end_layout

\begin_layout Subsubsection
eval <expression>
\end_layout

\begin_layout Subsubsection
apply <closure> <parameter list>
\end_layout

\begin_layout Subsubsection
Type Checks with = 
\end_layout

\begin_layout Subsubsection
symbol-value <symbol>
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
> (dict (.a = 1)(.b = 2))
\end_layout

\begin_layout LyX-Code
    (symbol-value ^.b)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
2 # Bignum 
\end_layout

\begin_layout Standard
More complex example:
\end_layout

\begin_layout LyX-Code
> var D (dict (.a=1)(.b=2))  
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
> for v in D
\end_layout

\begin_layout LyX-Code
   u:format "%s = %s
\backslash
n" v (D (symbol-value v))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
.b = 2
\end_layout

\begin_layout LyX-Code
.a = 1
\end_layout

\begin_layout LyX-Code
.self = (dict (.a = 1) (.b = 2))
\end_layout

\begin_layout LyX-Code
.vars = (.b .a .self .vars .classes)
\end_layout

\begin_layout LyX-Code
.classes = (<class Dictionary (Builtin)>)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout Subsubsection
dynamic-symbol-value <symbol>
\end_layout

\begin_layout Subsubsection
template <expression>
\end_layout

\begin_layout Subsubsection
quote <expression>
\end_layout

\begin_layout Subsubsection
the <expression>
\end_layout

\begin_layout Subsection
Bindings
\end_layout

\begin_layout Subsubsection
Definition of Variables
\end_layout

\begin_layout Paragraph
var
\end_layout

\begin_layout Paragraph
defvar
\end_layout

\begin_layout Paragraph
define
\end_layout

\begin_layout Paragraph
bound?
\end_layout

\begin_layout Subsubsection
Assignment
\end_layout

\begin_layout Paragraph
setq
\end_layout

\begin_layout Paragraph
set
\end_layout

\begin_layout Subsubsection
Definition of Functions
\end_layout

\begin_layout Paragraph
def
\end_layout

\begin_layout Paragraph
df
\end_layout

\begin_layout Paragraph
defmacro
\end_layout

\begin_layout Subsection
Control Flow
\end_layout

\begin_layout Subsubsection
Conditional Execution
\end_layout

\begin_layout Paragraph
cond
\end_layout

\begin_layout Paragraph
if
\end_layout

\begin_layout Subsubsection
Looping and Iterators
\end_layout

\begin_layout Paragraph

\emph on
while
\end_layout

\begin_layout LyX-Code
while <expression>
\end_layout

\begin_layout LyX-Code
    <body>
\end_layout

\begin_layout Paragraph
Iterators
\end_layout

\begin_layout LyX-Code
<expression>(.mkIterator)
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
define L ^(1 2)
\end_layout

\begin_layout LyX-Code
define iter (L(.mkIterator))
\end_layout

\begin_layout LyX-Code
assert
\end_layout

\begin_layout LyX-Code
   equal?
\end_layout

\begin_layout LyX-Code
      list (iter) (iter) (iter)
\end_layout

\begin_layout LyX-Code
      ^(1 2 sys:StopIteration)
\end_layout

\begin_layout Paragraph
Traversing with 
\emph on
for
\end_layout

\begin_layout LyX-Code
for <var> in <expression with .mkIterator>
\end_layout

\begin_layout LyX-Code
    <body>
\end_layout

\begin_layout Standard
List example:
\end_layout

\begin_layout LyX-Code
define n ^(1 2)
\end_layout

\begin_layout LyX-Code
define z ^(A B)
\end_layout

\begin_layout LyX-Code
for v1 in n
\end_layout

\begin_layout LyX-Code
   for v2 in z
\end_layout

\begin_layout LyX-Code
        u:format "%s %s
\backslash
n" v1 v2
\end_layout

\begin_layout Standard
prints:
\end_layout

\begin_layout LyX-Code
1 A
\end_layout

\begin_layout LyX-Code
1 B
\end_layout

\begin_layout LyX-Code
2 A
\end_layout

\begin_layout LyX-Code
2 B
\end_layout

\begin_layout Standard
dictionary example
\end_layout

\begin_layout LyX-Code
var D (dict (.a=1)(.b=2))  
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
for v in D
\end_layout

\begin_layout LyX-Code
   u:format "%s = %s
\backslash
n" v (D (symbol-value v))
\end_layout

\begin_layout Standard
prints:
\end_layout

\begin_layout LyX-Code
.a = 1
\end_layout

\begin_layout LyX-Code
.b = 2
\end_layout

\begin_layout LyX-Code
.self = (dict (.a = 1) (.b = 2))
\end_layout

\begin_layout LyX-Code
.vars = (.a .b .self .vars .classes)
\end_layout

\begin_layout LyX-Code
.classes = (<class Dictionary (Builtin)>)
\end_layout

\begin_layout Paragraph
Ranges
\end_layout

\begin_layout LyX-Code
range <low> <high>
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout LyX-Code
> var R (range 1 3)
\end_layout

\begin_layout LyX-Code
(1 3) # Range Pair 
\end_layout

\begin_layout LyX-Code
> var iter (R(.mkIterator))
\end_layout

\begin_layout LyX-Code
<EagerProc: <anonymous lambda>> # RangeIterator EagerProcedure 
\end_layout

\begin_layout LyX-Code
> iter
\end_layout

\begin_layout LyX-Code
1 # Bignum 
\end_layout

\begin_layout LyX-Code
> iter
\end_layout

\begin_layout LyX-Code
2 # Bignum 
\end_layout

\begin_layout Standard
with 
\emph on
for:
\end_layout

\begin_layout LyX-Code
> for i in (range 1 3)
\end_layout

\begin_layout LyX-Code
     print i
\end_layout

\begin_layout LyX-Code
~ 1
\end_layout

\begin_layout LyX-Code
~ 2
\end_layout

\begin_layout LyX-Code
~ 3
\end_layout

\begin_layout Subsubsection
Exceptions
\end_layout

\begin_layout Paragraph
raise <expression>
\end_layout

\begin_layout Paragraph
assert
\end_layout

\begin_layout Subsection
Predicates
\end_layout

\begin_layout Standard
Predicates are a general class of functions which either return 
\emph on
nil
\emph default
 to signify falsehood, or a non
\emph on
-nil
\emph default
 value for truth.
\end_layout

\begin_layout Subsubsection
Comparisons
\end_layout

\begin_layout Paragraph
eq? <a> <b>
\end_layout

\begin_layout Standard
The 
\emph on
eq?
\emph default
 function compares two expressions to see if they are the same physical
 object in the interpreter memory.
 In other words it returns 
\emph on
true if 
\emph default
the by-value references passed in as parameters are the same, otherwise
 
\emph on
nil
\emph default
 is returned.
 Examples:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expression
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
eq?
\emph default
 return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
eq? ^a ^a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
eq? 1 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nil
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
eq? 'c' 'c'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nil
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
equal?
\end_layout

\begin_layout Standard
The 
\emph on
equal?
\emph default
 function compares the contents of two expressions and returns 
\emph on
true 
\emph default
if they have the same value, otherwise 
\emph on
nil.
 
\emph default
If two expressions are 
\emph on
eq?
\emph default
 they are always 
\emph on
equal?
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expression
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
equal?
\emph default
 return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal? ^a ^a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal? 1 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal? 'c' 'c'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal? ^(1 2) ^(1 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
equal? (dict (.a=2))(dict(.a=2))
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
false
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
>
\end_layout

\begin_layout Standard
The greater than function returns 
\emph on
true
\emph default
 if its first argument is numerically greater than its second argument.
\end_layout

\begin_layout Paragraph
<
\end_layout

\begin_layout Standard
The greater than function returns 
\emph on
true
\emph default
 if its first argument is numerically less than its second argument.
\end_layout

\begin_layout Subsubsection
Logical Functions
\end_layout

\begin_layout Standard
Genyris has a set of boolean functions which expect arguments which are
 either 
\emph on
nil
\emph default
 to signify falsehood or non-nil for truth.
 
\end_layout

\begin_layout Paragraph
not <x>, null?
\end_layout

\begin_layout Standard
If the argument is 
\emph on
nil 
\emph default
these functions return 
\emph on
true
\emph default
 otherwise 
\emph on
nil 
\emph default
is returned
\emph on
.
\end_layout

\begin_layout Paragraph
and <a1> <a2> ...
\end_layout

\begin_layout Standard
This macro executes its arguments in turn, if an argument evaluates to a
 
\emph on
nil
\emph default
 value execution stops and it returns 
\emph on
nil.
 
\emph default
Otherwise execution continues to the last argument whose value is returned.
 Examples:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expression
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Result
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and 1 2 3 4 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and 1 2 3 nil 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nil
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and (print 1) (print 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Both 1 and 2 are printed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and (not (print 1)) (print 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nil
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 is printed
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
or
\end_layout

\begin_layout Standard
This macro executes its arguments in turn, if an argument evaluates to a
 non-
\emph on
nil
\emph default
 value execution stops and it returns 
\emph on
true.
 
\emph default
Examples
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expression
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Result
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
or 1 2 3 4 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
or nil 2 3 nil 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
or (print 1) (print 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 is printed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
or (not (print 1)) (print 2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
true
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 and 2 are printed
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Closures
\end_layout

\begin_layout Standard
Closures are executable objects which retain the environment in which they
 were created for use during execution at a later time.
\end_layout

\begin_layout Subsubsection

\emph on
lambda
\emph default
 or 
\emph on
function
\emph default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
lambda
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
[function|lambda] ([arg1]...
 [&rest restargs] [= return-validator]) [body]
\end_layout

\begin_layout Standard
The 
\emph on
function
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
function
\end_layout

\end_inset


\emph default
 macro creates a lexical closure at the point of definition and returns
 an anonymous 'eager' procedure object.
 
\emph on
lambda
\emph default
 is an alias for 
\emph on
function
\emph default
 and is kept for historical reasons.
 The procedure object can be invoked as a function.
 When the procedure is called it's real arguments must match the formal
 arguments specified in the function definition.
 The formal arguments may have one of the following forms:
\end_layout

\begin_layout LyX-Code
() - no arguments
\end_layout

\begin_layout LyX-Code
(arg1 arg2 ..
 argn) - alist of required arguments
\end_layout

\begin_layout LyX-Code
(...
 &rest arglist) - variable arguments 
\end_layout

\begin_layout Standard
If the argument list includes &rest, all the remaining real arguments are
 collected into a list and passed to the function in a single argument,
 the name of which is specified after the &rest
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
&rest
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The function body - a list of expressions - is executed each expression
 in turn, the last evaluation is returned by the function.
 Formal arguments may be specified in two forms, either as a symbol or as
 a type specification.
 If a symbol is used, the real arguments are bound to the symbol in the
 execution environment of the function when it is called.
 The type of the formal argument may be supplied as the right hand side
 of a cons pair:
\end_layout

\begin_layout LyX-Code
(arg-name = validator)
\end_layout

\begin_layout Standard
The validator must be a symbol bound to a dictionary or class which has
 a validator function (
\emph on
.valid?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.valid?
\end_layout

\end_inset


\emph default
).
 When the procedure is called, the interpreter executes the .valid?
\begin_inset Index
status open

\begin_layout Plain Layout
valid?
\end_layout

\end_inset

 function with the real argument as its single parameter.
 If the validator returns false, a type miss-match error is raised.
\end_layout

\begin_layout Standard
The expected type of the return value can be specified after a trailing
 = in the argument list.
 
\end_layout

\begin_layout Paragraph*
Examples:
\end_layout

\begin_layout LyX-Code
function ()
\end_layout

\begin_layout Standard
returns a procedure which returns nil 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
function (x y) (cons x y)
\end_layout

\begin_layout Standard
returns a procedure with two mandatory arguments
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
function (x &rest y) (list x y)
\end_layout

\begin_layout Standard
returns a procedure with one mandatory and one rest argument
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
function ((i = Bignum) (j = Bignum) = Bignum) (+ i j)
\end_layout

\begin_layout Standard
returns a procedure with two mandatory arguments with expected types and
 a return value with expected type.
\end_layout

\begin_layout Subsubsection

\emph on
lambadq
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
lambadq
\end_layout

\end_inset


\emph default
 
\end_layout

\begin_layout Standard
This macro is identical in syntax to 
\emph on
function
\emph default
 but it creates an anonymous lazy procedure (which does not execute it's
 arguments when called).
\end_layout

\begin_layout Subsubsection

\emph on
lambdam
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
lambdam
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This macro is identical in syntax to 
\emph on
function
\emph default
 but it creates a lazy procedure which re-executes it's return value in
 the environment of the caller - in other an anonymous macro.
\end_layout

\begin_layout Subsection
Classification
\end_layout

\begin_layout Subsubsection

\emph on
class
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
class
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
tag
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
tag
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
remove-tag
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
remove-tag
\end_layout

\end_inset


\emph default
 <class> <object>
\end_layout

\begin_layout Subsubsection

\emph on
is-instance?
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
is-instance?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Constants
\end_layout

\begin_layout Standard
The interpreter pre-loads a number of bindings in the global environment
 which are treated by users as constants.
\end_layout

\begin_layout Subsubsection

\emph on
nil
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
nil
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This symbol is used to denote an empty list, the end of a list.
 It is used by the conditiona macro 
\emph on
cond
\emph default
 amongst others to denote falsehood.
 
\emph on
nil
\emph default
 is bound to itself in the global environment.
 The empty list 
\emph on
() 
\emph default
is a synonym for nil.
\end_layout

\begin_layout Subsubsection

\emph on
EOF
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
EOF
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Used to denote the End Of File, this symbol causes a parser to exit if seen.
\end_layout

\begin_layout Subsubsection
true
\begin_inset Index
status open

\begin_layout Plain Layout
true
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A convenient symbol used to explicitly signal the opposite of 
\emph on
nil
\emph default
, 
\emph on
true
\emph default
 is bound to itself in the global environment.
\end_layout

\begin_layout Subsection
Tasks
\begin_inset Index
status open

\begin_layout Plain Layout
Tasks
\end_layout

\end_inset

 - Multiple Threads of Execution
\end_layout

\begin_layout Standard

\emph on
Tasks
\emph default
 in Genyris are modelled on Unix processes.
 They are seperate interpreter instances where shared memory is minimal,
 and communication is conducted via system objects outside of the interpreters
 themselves.
 This approach relieves the programmer with the burden of debugging multi-thread
ed code yet retains the advantages of asynchronous execution and multi-core
 hardware.
 This implementation uses a single Java thread per interpreter and uses
 Java in-process objects for inter-task communication.
\end_layout

\begin_layout Subsubsection
Running Multiple Interpreters in the Same Process with 
\emph on
spawn
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
spawn
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
spawn <source file to include> <args ...>
\end_layout

\begin_layout Standard
Spawn creates a new Genyris interpreter instance which is then executed
 by a seperate Java thread.
 Only the objects passed as parameters are shared between interpreter threads.
 They all share the same operating system interfaces, files, sockets etc
 since they are running in the same process.
 The function returns a 
\emph on
Task
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Task
\end_layout

\end_inset


\emph default
 object, which is a Dictionary containing, the name, id and state of the
 underlying Java thread.
 For example:
\end_layout

\begin_layout LyX-Code
spawn 'testscripts/spawn-example.g' 1 2 3 4 5
\end_layout

\begin_layout Standard
returns:
\end_layout

\begin_layout LyX-Code
(dict (.id = 9) (.name = 'examples/spawn-example.g') (.state = 'RUNNABLE'))
 # Task Dictionary
\end_layout

\begin_layout Standard
The 
\emph on
spawn-example.g 
\emph default
file contains:
\end_layout

\begin_layout LyX-Code
@prefix sys 'http://www.genyris.org/lang/system#'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
while true
\end_layout

\begin_layout LyX-Code
   print sys:argv
\end_layout

\begin_layout LyX-Code
   sleep 5000
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout LyX-Code
'examples/spawn-example.g' 1 2 3 4 5
\end_layout

\begin_layout LyX-Code
'examples/spawn-example.g' 1 2 3 4 5
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout Subsubsection
Termination with 
\family typewriter
\emph on
kill
\emph default
:
\end_layout

\begin_layout Standard
Tasks and the underlying Java threads are killed with the
\emph on
 task:kill
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
task:kill
\end_layout

\end_inset


\emph default
 function.
 This is also available as the 
\emph on
.kill
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
.kill
\end_layout

\end_inset


\emph default
 method in the 
\emph on
Task
\emph default
 class
\emph on

\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
Task class
\end_layout

\end_inset


\emph default
.
 A string is returned after completion.
 Note there is no guarantee from Java that the thread will be terminated.
\end_layout

\begin_layout LyX-Code
<Thread>(.kill)
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout LyX-Code
@prefix task 'http://www.genyris.org/lang/task#'
\end_layout

\begin_layout LyX-Code
task:kill <integer Java thread id>
\end_layout

\begin_layout Subsubsection
Thread Safety
\begin_inset Index
status open

\begin_layout Plain Layout
Thread Safety
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
spawn
\emph default
 function provides a way of multi-tasking sections of an application.
 This allows seperate interpreter instances to execute, and share some common
 value objects passed by main arguments.
 The interpreter does not cater for multiple threads of execution running
 within the same interpreter scope.
 Although it is technically possible to any genyris objects including functions
 between tasks, this is not supported.
 This is because execution of stored closures will mean two interpreters
 are operating in the same environment.
 
\end_layout

\begin_layout Standard
Genyris 
\emph on
Tasks 
\emph default
are not 
\emph on
Threads
\emph default
 the intent is that they are self-contained, supporting single-threaded
 applications only.
 However since the underlying Java objects must be shared between tasks
 for inter-task communication, a means of making this thread-safe is provided.
\end_layout

\begin_layout Subsubsection

\emph on
task:synchronized
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
task:synchronized
\end_layout

\end_inset


\emph default
 - Controlling access to shared objects
\end_layout

\begin_layout Standard
The 
\emph on
spawn
\emph default
 and 
\emph on
httpd
\emph default
 functions allow Genyris objects to be passed from one thread of execution
 to another.
 This is provided so that system objects such as pipes, files etc can be
 shared.
 
\end_layout

\begin_layout Standard
Both tasks have references to the same in-memory objects, and there is real
 danger that the actions of one thread will corrupt the objects used by
 another.
 The 
\emph on
synchronized
\emph default
 macro ensures that developers can serialise access to shared objects.
 The syntax is as follows:
\end_layout

\begin_layout LyX-Code
task:synchronized <object>
\end_layout

\begin_layout LyX-Code
    <code body>
\end_layout

\begin_layout LyX-Code
    ....
\end_layout

\begin_layout Standard
The effect of the macro is to wait for an implicit lock associated with
 the 
\emph on
<object>
\emph default
 to become free.
 When the lock is free the thread sets the lock and executes the 
\emph on
code body
\emph default
.
 When the execution completes the lock is freed ready for another thread.
 A test-case:
\end_layout

\begin_layout Standard
A task loops, watching a shared 
\emph on
Pair
\emph default
, checking to see if the 
\emph on
left
\emph default
 value is ever 1.
 If so it raises an error.

\emph on
 
\end_layout

\begin_layout LyX-Code
task:synchronized shared
\end_layout

\begin_layout LyX-Code
     read-value = (shared.left)
\end_layout

\begin_layout LyX-Code
cond
\end_layout

\begin_layout LyX-Code
     (equal? 1 read-value)
\end_layout

\begin_layout LyX-Code
            raise "error"
\end_layout

\begin_layout Standard
A second task loops, changing the value from 0 to 1 and back.
\end_layout

\begin_layout LyX-Code
task:synchronized shared
\end_layout

\begin_layout LyX-Code
        shared (.left = 1)
\end_layout

\begin_layout LyX-Code
        sleep 13
\end_layout

\begin_layout LyX-Code
        shared (.left = 0)
\end_layout

\begin_layout LyX-Code
        sleep 23
\end_layout

\begin_layout Standard
Because both tasks are executing this code in the scope of a 
\emph on
synchronized
\emph default
 call, with the same shared lock object, the first task never sees the value
 altered to 1 by the second task.
 Without the 
\emph on
synchronized
\emph default
 macro the first task sees the manipulations of the second.
\end_layout

\begin_layout Subsubsection

\emph on
ps
\emph default
 - list current running threads
\end_layout

\begin_layout Standard
The 
\emph on
ps
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
ps
\end_layout

\end_inset


\emph default
 function returns a list of 
\emph on
Task
\emph default
 objects for each of the current tasks.
\end_layout

\begin_layout Part
Libraries
\end_layout

\begin_layout Standard
Genyris is, like Scheme, a small language which allows users to develop
 their own paradigms and languages.
 Since Genyris has access to Java classes via 
\emph on
java:import 
\emph default
a programmer can readily create his or her data types, I/O libraries and
 so on.
 Hence the libraries provided with Genyris documented here are not a mandatory
 part of a Genyris implementation and their interfaces may change over time
 without changing the core language.
 The main emphasis is to provide common data types and functions useful
 for every-day scripting in a manner that fits well with the unique Genyris
 classification paradigm and its not-so-unique syntax.
\end_layout

\begin_layout Section
Maths Functions
\end_layout

\begin_layout Standard
Genyris includes basic arithmetic operations on Bignum obects.
\end_layout

\begin_layout Subsection
+
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
+
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
This function computes the sum of its arguments, which may be many.
\end_layout

\begin_layout Subsection

\emph on
-
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
-
\end_layout

\end_inset


\emph default
 
\end_layout

\begin_layout Standard
This function computes the accumulated difference of its arguments, which
 may be many.
 Example:
\end_layout

\begin_layout LyX-Code
(- 1 2 3) = -4
\emph on
 
\end_layout

\begin_layout Subsection
*
\end_layout

\begin_layout Standard
This function computes the product of its arguments, which must number two
 or more.
\end_layout

\begin_layout Subsection
/
\end_layout

\begin_layout Standard
This function computes the quotient of its arguments, which must number
 at two or more.
\end_layout

\begin_layout Subsection
%
\end_layout

\begin_layout Standard
This function computes the remainder of its arguments, which must number
 at two or more.
\end_layout

\begin_layout Subsection
power
\end_layout

\begin_layout Standard
This function calculates the first argument raised to the power of the second.
 Example: 
\emph on
(power 2 8) => 256
\end_layout

\begin_layout Section
Time and Dates
\end_layout

\begin_layout Subsection

\emph on
System!ticks
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
System!ticks
\end_layout

\end_inset


\emph default
 - Current system time in milliseconds since the epoch
\end_layout

\begin_layout LyX-Code
> System!ticks
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
1266995579117 # Bignum
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> format-date 0 "dd MMM yyyy HH:mm:ss Z" 'GMT'
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
'01 Jan 1970 00:00:00 +0000' # String
\end_layout

\begin_layout Subsection

\emph on
now
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
now
\end_layout

\end_inset


\emph default
 - Current system time in milliseconds since the epoch
\end_layout

\begin_layout Standard
An alias for 
\emph on
System!ticks
\emph default
.
\end_layout

\begin_layout Subsection

\emph on
format-date
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
format-date
\end_layout

\end_inset


\emph default
 <epoch milliseconds> <format String> <timezone>
\end_layout

\begin_layout Standard
For example:
\end_layout

\begin_layout LyX-Code
> format-date (System!ticks) "dd MMM yyyy HH:mm:ss z" "Australia/Melbourne"
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
'24 Feb 2010 18:11:41 EST' # String  
\end_layout

\begin_layout Subsection

\emph on
calendar
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
calendar
\end_layout

\end_inset


\emph default
 <epoch milliseconds> <timezone>
\end_layout

\begin_layout Standard
Returns a Calendar (dictionary) with the following properties:
\end_layout

\begin_layout Description
.am-pm = symbol indicating AM or PM
\end_layout

\begin_layout Description
.day-of-month = Integer day of the month starting with 1.
\end_layout

\begin_layout Description
.day-of-week = Integer day of the week starting with Sunday which is 1.
\end_layout

\begin_layout Description
.day-of-week-in-month = Ordinal number of the day of the week within the
 current month.
\end_layout

\begin_layout Description
.day-of-year = The day number within the current year starting with 1.
\end_layout

\begin_layout Description
.dst-offset = Daylight savings offset in milliseconds
\end_layout

\begin_layout Description
.era = symbol AD or BC
\end_layout

\begin_layout Description
.hour = Hour of the day (12 hour clock)
\end_layout

\begin_layout Description
.hour-of-day = Hour of the day (24 hour clock)
\end_layout

\begin_layout Description
.millisecond = e.g.
 93
\end_layout

\begin_layout Description
.minute = e.g.
 2
\end_layout

\begin_layout Description
.month = Integer month starting with January, which is 0
\end_layout

\begin_layout Description
.second = e.g.
 42
\end_layout

\begin_layout Description
.week-of-month = Week in the month starting from 1.
\end_layout

\begin_layout Description
.week-of-year = Week number in the year starting from 1.
\end_layout

\begin_layout Description
.year = e.g.
 2010
\end_layout

\begin_layout Description
.zone-offset = Timezone offset in milliseconds from GMT
\end_layout

\begin_layout Standard
For example:
\end_layout

\begin_layout LyX-Code
> print (calendar (System!ticks))
\end_layout

\begin_layout LyX-Code
dict (.am-pm = pm)
\end_layout

\begin_layout LyX-Code
.day-of-month = 10
\end_layout

\begin_layout LyX-Code
.day-of-week = 4
\end_layout

\begin_layout LyX-Code
.day-of-week-in-month = 2
\end_layout

\begin_layout LyX-Code
.day-of-year = 69
\end_layout

\begin_layout LyX-Code
.dst-offset = 1
\end_layout

\begin_layout LyX-Code
.era = AD
\end_layout

\begin_layout LyX-Code
.hour = 10
\end_layout

\begin_layout LyX-Code
.hour-of-day = 22
\end_layout

\begin_layout LyX-Code
.millisecond = 93
\end_layout

\begin_layout LyX-Code
.minute = 2
\end_layout

\begin_layout LyX-Code
.month = 2
\end_layout

\begin_layout LyX-Code
.second = 42
\end_layout

\begin_layout LyX-Code
.week-of-month = 2
\end_layout

\begin_layout LyX-Code
.week-of-year = 11
\end_layout

\begin_layout LyX-Code
.year = 2010
\end_layout

\begin_layout LyX-Code
.zone-offset = 10
\end_layout

\begin_layout Section
Input and Output
\end_layout

\begin_layout Subsubsection
Global Output Functions
\end_layout

\begin_layout Paragraph
\begin_inset Index
status collapsed

\begin_layout Plain Layout
print
\end_layout

\end_inset


\emph on
print
\emph default
<arg1>...<argn>
\end_layout

\begin_layout Standard
Outputs its arguments to the current standard output stream as if typed
 in by a user in indented format.
 - strings are quoted, escape characters are output.
 Arguments on the output are seperated by a newline.
 Example:
\end_layout

\begin_layout LyX-Code
print ^(1 'w
\backslash
n' (x y))
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
1 'w
\backslash
n'
\end_layout

\begin_layout LyX-Code
   x y  
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Paragraph

\emph on
write
\begin_inset Index
status open

\begin_layout Plain Layout

\emph on
write
\end_layout

\end_inset


\emph default
<arg1>...<argn>
\end_layout

\begin_layout Standard
Outputs its arguments to the current standard output stream with parenthesis
 syntax.
 - strings are quoted, escape characters are output.
 Arguments are output sequentially without space padding.
 Example:
\end_layout

\begin_layout LyX-Code
write ^(1 2 (e) 'w')
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(1 2 (e) 'w')
\end_layout

\begin_layout Paragraph
\begin_inset Index
status collapsed

\begin_layout Plain Layout
display
\end_layout

\end_inset

display<arg1>...<argn>
\end_layout

\begin_layout Standard
Outputs its arguments to the current standard output stream without syntax.
 - strings are not quoted, escape characters are not output.
 Arguments are output sequentially without padding.
 Example:
\end_layout

\begin_layout LyX-Code
display ^(1 'w
\backslash
n' (x y))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(1 w
\end_layout

\begin_layout LyX-Code
 (x y))
\end_layout

\begin_layout Subsubsection
Global Input Functions
\end_layout

\begin_layout Paragraph
\begin_inset Index
status collapsed

\begin_layout Plain Layout
read
\end_layout

\end_inset

read
\end_layout

\begin_layout Standard
Reads an expression from the standard input.
\end_layout

\begin_layout Subsubsection
Class 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Writer
\end_layout

\end_inset

Writer
\end_layout

\begin_layout Standard
A class which accepts a stream of characters.
\end_layout

\begin_layout Paragraph
Methods
\end_layout

\begin_layout Description
.
\begin_inset Index
status collapsed

\begin_layout Plain Layout
close
\end_layout

\end_inset

close() Closes the current output stream.
\end_layout

\begin_layout Description
.
\begin_inset Index
status collapsed

\begin_layout Plain Layout
flush
\end_layout

\end_inset

flush() Forces all buffered output to be written to the device.
\end_layout

\begin_layout Description
.
\begin_inset Index
status collapsed

\begin_layout Plain Layout
format
\end_layout

\end_inset

format <format-string><arg1>...<argn> Outputs the args as dictated by the format-st
ring.
 The format string is a normal string with the special format sequences.
 Each format sequence must be matched by a corresponding argument to format,
 used in order.
 
\end_layout

\begin_deeper
\begin_layout Description
%a Outputs the argument without syntax - strings are unquoted, escape characters
 are not output
\end_layout

\begin_layout Description
%s Outputs the argument using if entered by a user - strings are quoted,
 escape characters are not output
\end_layout

\begin_layout Description
%x Outputs the argument as XML using an XmlWriter
\end_layout

\begin_layout Description
%u Outputs the argument as a URL encoded string suitable for HTTP URLS
\end_layout

\begin_layout Description
%n Outputs a linefeed
\end_layout

\begin_layout Description
%% Outputs a % character
\end_layout

\begin_layout Standard
Example:
\end_layout

\end_deeper
\begin_layout LyX-Code
stdout(.format '%s %a %x %n' 'Hello' 'World' ^(img ((width= 23))))
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
'Hello' World <img width="23"/>
\end_layout

\begin_layout Paragraph
Global Variables
\end_layout

\begin_layout Description
\begin_inset Index
status collapsed

\begin_layout Plain Layout
stdout
\end_layout

\end_inset

stdout A global variable which holds a 
\emph on
Writer
\emph default
 pointing the current Standard output device, typically the console.
\end_layout

\begin_layout Subsubsection
Class Reader
\end_layout

\begin_layout Paragraph
Globals
\end_layout

\begin_layout Description
\begin_inset Index
status collapsed

\begin_layout Plain Layout
stdin
\end_layout

\end_inset

stdin A global variable which holds a 
\emph on
Reader
\emph default
 pointing the current Standard Input device, typically the console.
\end_layout

\begin_layout Standard
(To be completed)
\end_layout

\begin_layout Section
Input
\end_layout

\begin_layout Subsection
stdin
\end_layout

\begin_layout Subsection
ParenParser
\end_layout

\begin_layout Subsubsection
.new
\end_layout

\begin_layout Subsubsection
.close
\end_layout

\begin_layout Subsubsection
.read
\end_layout

\begin_layout Subsubsection
.hasData
\end_layout

\begin_layout Subsection
Parser
\end_layout

\begin_layout Subsection
StringFormatStream
\end_layout

\begin_layout Subsubsection
.new
\end_layout

\begin_layout Subsection
Fetching HTTP Pages
\end_layout

\begin_layout Subsubsection
web:get <url> [<request headers>]
\end_layout

\begin_layout Standard
Content can be fetched from web servers using the web: get function.
 This takes as input a URL string and an option alist of request headers.
 It sends the GET request to web server and the returns the response content
 in a Reader stream.
 The response must have the 200 'OK' status code otherwise an exception
 is raised.
\end_layout

\begin_layout Standard
Example, fetching the root file from the localhost server on port 80, providing
 a 'Basic' authentication header.
\end_layout

\begin_layout LyX-Code
web:get 'http://localhost:8080/' =
\end_layout

\begin_layout LyX-Code
        ^(('authorization' = 'Basic Zm9vOmJhcg=='))
\end_layout

\begin_layout Section
Output
\end_layout

\begin_layout Subsection
write
\end_layout

\begin_layout Subsection
display
\end_layout

\begin_layout Subsection
print
\end_layout

\begin_layout Subsection
format
\end_layout

\begin_layout Subsubsection
web:get
\end_layout

\begin_layout Section
File
\end_layout

\begin_layout Subsection
.new
\end_layout

\begin_layout Subsection
.open
\end_layout

\begin_layout Subsection
.format
\end_layout

\begin_layout Subsection
.close
\end_layout

\begin_layout Subsection
.hasData
\end_layout

\begin_layout Subsection
.read
\end_layout

\begin_layout Subsection
.static-open
\end_layout

\begin_layout Section
Loading Data in Comma-Separated-Value Files
\end_layout

\begin_layout Standard
The builtin 
\emph on
CSV
\emph default
 class is provided for reading data from CSV files.
 
\end_layout

\begin_layout Subsection
.read <InStream> field-separator quote-char
\end_layout

\begin_layout Standard
The CSV class has a single static method 
\emph on
.read 
\emph default
which takes an input stream as it's first parameter.
 Despite the name CSV files can come in a variety of formats, hence the
 method expects the field-seperator character and field quote character
 as parameters.
 
\end_layout

\begin_layout Standard
The result is a list of rows.
 Each row is itself a list of the fields parsed.
\end_layout

\begin_layout Standard
Example.
 Read a comma-delimited file:
\end_layout

\begin_layout LyX-Code
CSV
\end_layout

\begin_layout LyX-Code
   .read ((File(.new 'my file')) (.open ^read)) = 
\end_layout

\begin_layout LyX-Code
       ',' '
\begin_inset Quotes erd
\end_inset

'
\end_layout

\begin_layout Section
Running Web Servers
\end_layout

\begin_layout Standard
Genyris can run multiple a single-threaded HTTP 1.0 servers in Tasks in the
 background.
 The web server is implemented in Java and provides a simple interface.
\end_layout

\begin_layout Subsubsection
Starting a web server
\end_layout

\begin_layout Standard
A Genyris new interpreter can be started as a server with the 
\emph on
httpd
\emph default
 function:
\end_layout

\begin_layout LyX-Code
httpd <port> <path to source file> [args...]
\end_layout

\begin_layout Standard
The 
\emph on
httpd
\emph default
 function takes parameters:
\end_layout

\begin_layout Itemize
the path of a Genyris source file to load and run
\end_layout

\begin_layout Itemize
the TCP/IP port number on which the server will listen for requests.
\end_layout

\begin_layout Itemize
all the remaining parameters are collected in a list and bound to 
\emph on
sys.argv
\end_layout

\begin_layout Standard
The return value is a 
\emph on
Task
\emph default
 object for the web server.
 Many web servers can be started in the same JVM, each server is allocated
 a unique interpreter instance, there is no sharing between interpreters
 apart from the 
\emph on
args 
\emph default
passed in
\emph on
.
\end_layout

\begin_layout Standard
The URL for the browser would be 
\emph on
http://localhost:8080/
\emph default
.
 The server is terminated by killing the thread, or by coding an explicit
 exit function within the web application.
\end_layout

\begin_layout Paragraph
Example
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
httpd 7777 'examples/www-demo.g' 1 2 3 4 5
\end_layout

\begin_layout Subsubsection
Stopping a web server
\end_layout

\begin_layout Standard
The server's thread can be stopped with the 
\emph on
kill
\emph default
 functions described above.
\end_layout

\begin_layout Subsubsection
Processing Web Requests
\end_layout

\begin_layout Standard
The web server main loop expects to fnd a function called 
\emph on
httpd-serve 
\emph default
which it calls for each web GET or POST request recieved from clients.
 The request from the remote client is passed to the function as a single
 parameter.
 The return from the function call must contain the response to be sent
 to the browser.
 
\end_layout

\begin_layout Paragraph
Example
\end_layout

\begin_layout LyX-Code
df httpd-serve (request)
\end_layout

\begin_layout LyX-Code
   list 200 'text/plain' 'Hello World'
\end_layout

\begin_layout Paragraph
Requests - HttpRequest class
\end_layout

\begin_layout Standard
The request parameter is an object of class 
\emph on
HttpRequest
\emph default
.
 The class has the following methods which return components of the request:
\end_layout

\begin_layout Description
.getMethod() GET or POST
\end_layout

\begin_layout Description
.getPath() Path component of the UL
\end_layout

\begin_layout Description
.getHeaders() an 
\emph on
AList
\emph default
 containing the headers
\end_layout

\begin_layout Description
.getParameters() an 
\emph on
aList
\emph default
 containing GET or POST parameters
\end_layout

\begin_layout Description
.getClient() gives a Pair containing the client's IP address and hostname
\end_layout

\begin_layout Description
.getBasicUsernamePassword() Returns the Basic Authentication scheme header
 as a dictionary with 
\emph on
.username
\emph default
 and 
\emph on
.password
\emph default
 strings.
 If no auth is present, the username and passwords are empty strings.
\end_layout

\begin_layout Description
.toHTML() a method returning an HTML list structure in %x format.
\end_layout

\begin_layout Paragraph
Responses
\end_layout

\begin_layout Standard
The return value from the 
\emph on
httpd-serve 
\emph default
function is anlaysed by the web server and executed as required.
 There are two types of response:
\end_layout

\begin_layout Itemize
Instruction to serve a file from the file system as a 'static' page
\end_layout

\begin_layout Itemize
A data structure to be converted to XHTML and transmittted
\end_layout

\begin_layout Paragraph
Static Pages
\end_layout

\begin_layout Standard
If the return value is a list of the form:
\end_layout

\begin_layout LyX-Code
SERVE-FILE <root Directory Path> <Path to File> [<list directory flag>]
\end_layout

\begin_layout Standard
Then the file referred to by the path <root Directory Path>/<Path to File>
 is served to the client.
 If the file is a directory, and the <list directory flag> is the symbol
 
\emph on
ls
\emph default
, then the directory listing is returned to the client in HTML.
 The following function provides a simple static web server:
\end_layout

\begin_layout LyX-Code
df httpd-serve (request)
\end_layout

\begin_deeper
\begin_layout LyX-Code
list ^SERVE-FILE '/' (request(.getPath)) ^ls
\end_layout

\end_deeper
\begin_layout Paragraph
Http Responses in XML list structures
\end_layout

\begin_layout Standard
If the response is a list of the form:
\end_layout

\begin_layout LyX-Code
<integer status code> <mime type> <tree>
\end_layout

\begin_layout Standard
then the web server converts <tree> into the relevant encoding and transmits
 it to the client.
 The conversion depends on the <mime type>.
 
\end_layout

\begin_layout Subparagraph
text/plain
\end_layout

\begin_layout Standard
This type of response uses the parenthesised Genyris output formatter to
 display the <tree>.
 It is equivalent to the %s directive in the %format instruction.
\end_layout

\begin_layout Subparagraph
text/html
\end_layout

\begin_layout Standard
This type of response must be in the XML format as used by the 
\emph on
%x
\emph default
 directive in the 
\emph on
format
\emph default
 function.
 This format requires XML tags to be symbols, followed by an attribute list.
 Strings an sub-tags are interleaved.
 The general grammar is:
\end_layout

\begin_layout LyX-Code
xml=tree :== html-tag ((attribute = 'value')...)
\end_layout

\begin_deeper
\begin_layout LyX-Code
['inner text' |<xml-tree> ] ...
\end_layout

\end_deeper
\begin_layout Standard
For example, the expression:
\end_layout

\begin_layout LyX-Code
u:format '%x'
\end_layout

\begin_layout LyX-Code
   quote
\end_layout

\begin_layout LyX-Code
     html()
\end_layout

\begin_layout LyX-Code
      head()
\end_layout

\begin_layout LyX-Code
        title() "Lamp Server"
\end_layout

\begin_layout LyX-Code
          body()
\end_layout

\begin_layout LyX-Code
             form()
\end_layout

\begin_layout LyX-Code
                input((name="op") (size="100") (value =none)) ""
\end_layout

\begin_layout LyX-Code
                   verbatim() "&nbsp;&nbsp;&nbsp;"
\end_layout

\begin_layout LyX-Code
                   input((type="submit") (value="Go"))
\end_layout

\begin_layout Standard
Is converted to the corresponding XML string:
\end_layout

\begin_layout LyX-Code
<html><head><title>Lamp Server<body><form><input name="op" size="100" value="non
e">&nbsp;&nbsp;&nbsp;<input type="submit" value="Go"/></input></form></body></ti
tle></head></html> 
\end_layout

\begin_layout Standard
The 
\emph on
verbatim
\emph default
 pseudo-tag passes text transparently.
 This example (from 
\emph on
examples/www-demo.g
\emph default
) echoes the input request in HTML:
\end_layout

\begin_layout LyX-Code
df httpd-serve (request)
\end_layout

\begin_layout LyX-Code
   list 200 'text/html'
\end_layout

\begin_layout LyX-Code
      template
\end_layout

\begin_layout LyX-Code
          html()
\end_layout

\begin_layout LyX-Code
             head()
\end_layout

\begin_layout LyX-Code
                title() 'Genyris demo'
\end_layout

\begin_layout LyX-Code
             body()
\end_layout

\begin_layout LyX-Code
                pre() ,sys.argv
\end_layout

\begin_layout LyX-Code
                ,(request (.toHTML))
\end_layout

\begin_layout Subsubsection
Starting a static web server
\end_layout

\begin_layout Standard
A static page web server can be started with the 
\emph on
www-static
\emph default
 script:
\end_layout

\begin_layout LyX-Code
httpd <port> "testscripts/www-static.g" <root directory>
\end_layout

\begin_layout Section
Genyris Classes
\end_layout

\begin_layout Subsection
Class Hierarchy
\end_layout

\begin_layout Standard
insert diagram here.
\end_layout

\begin_layout Subsection
Thing
\end_layout

\begin_layout Subsubsection
.vars
\begin_inset Index
status collapsed

\begin_layout Plain Layout
!vars
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
.self
\begin_inset Index
status collapsed

\begin_layout Plain Layout
!self
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
.classes
\begin_inset Index
status collapsed

\begin_layout Plain Layout
!classes
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
.valid?
\begin_inset Index
status collapsed

\begin_layout Plain Layout
!valid?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
StandardClass
\end_layout

\begin_layout Subsubsection
.classname
\end_layout

\begin_layout Subsubsection
.subclasses
\end_layout

\begin_layout Subsubsection
.superclasses
\end_layout

\begin_layout Subsubsection
.vars
\end_layout

\begin_layout Subsection
Builtin
\end_layout

\begin_layout Subsection
String
\end_layout

\begin_layout Subsubsection
.match
\end_layout

\begin_layout Subsubsection
.length
\end_layout

\begin_layout Subsubsection
.split
\end_layout

\begin_layout Subsubsection
.replace <searchstring> <replacement>
\end_layout

\begin_layout Standard
Returns a new string with every occurence of 
\emph on
<searchstring>
\emph default
 replaced with 
\emph on
<replacement>
\end_layout

\begin_layout Subsubsection
.+
\end_layout

\begin_layout Subsubsection
.toBase64
\end_layout

\begin_layout Standard
Returns the string converted into a Base64
\begin_inset Index
status open

\begin_layout Plain Layout
Base64
\end_layout

\end_inset

 encoded string.
 The returned string is tagged with the class string 
\emph on
Base64EncodedString
\emph default

\begin_inset Index
status open

\begin_layout Plain Layout
Base64EncodedString
\end_layout

\end_inset

.
 For example:
\end_layout

\begin_layout LyX-Code
> 'foo:bar'(.toBase64)
\end_layout

\begin_layout LyX-Code
'Zm9vOmJhcg==' # Base64EncodedString String
\end_layout

\begin_layout Subsubsection
.fromBase64
\end_layout

\begin_layout Standard
Decodes a Base 64 encoded string into the binary original.
 This is also available in the 
\emph on
Base64EncodedString
\emph default
 class
\emph on
 
\emph default
as the 
\emph on
.decode
\emph default
 method.
 Example:
\end_layout

\begin_layout LyX-Code
> 'Zm9vOmJhcg=='(.fromBase64)
\end_layout

\begin_layout LyX-Code
'foo:bar' # String
\end_layout

\begin_layout Subsection
Dictionary
\end_layout

\begin_layout Subsubsection
dict
\end_layout

\begin_layout Subsubsection
Accessing properties with .
\end_layout

\begin_layout Subsection
Bignum
\end_layout

\begin_layout Subsection
Double
\end_layout

\begin_layout Subsection
Closure
\end_layout

\begin_layout Subsection
LazyProcedure
\end_layout

\begin_layout Subsection
EagerProcedure
\end_layout

\begin_layout Subsection
PRINTWITHCOLON
\end_layout

\begin_layout Subsection
Pair
\end_layout

\begin_layout Subsubsection
list
\end_layout

\begin_layout Subsubsection
car
\end_layout

\begin_layout Subsubsection
cdr
\end_layout

\begin_layout Subsubsection
left
\end_layout

\begin_layout Subsubsection
right
\end_layout

\begin_layout Subsubsection
cons
\end_layout

\begin_layout Subsubsection
.left
\end_layout

\begin_layout Subsubsection
.right
\end_layout

\begin_layout Subsubsection
rplaca
\end_layout

\begin_layout Subsubsection
rplacd
\end_layout

\begin_layout Subsubsection
reverse
\end_layout

\begin_layout Subsubsection
length
\end_layout

\begin_layout Subsubsection
map-left
\end_layout

\begin_layout Subsubsection
member?
\end_layout

\begin_layout Subsection
Writer
\end_layout

\begin_layout Subsubsection
.close
\end_layout

\begin_layout Subsubsection
.format
\end_layout

\begin_layout Subsubsection
.flush
\end_layout

\begin_layout Subsection
Reader
\end_layout

\begin_layout Subsubsection
.hasData
\end_layout

\begin_layout Subsubsection
.read
\end_layout

\begin_layout Subsubsection
.close
\end_layout

\begin_layout Subsection
System
\end_layout

\begin_layout Subsubsection
.exec
\end_layout

\begin_layout Subsubsection
.getenv
\end_layout

\begin_layout Subsection
Sound
\end_layout

\begin_layout Subsubsection
.play
\end_layout

\begin_layout Section
Reflection
\end_layout

\begin_layout Subsection
Version Information
\end_layout

\begin_layout Standard
The current version number of the Genyris interpreter is recorded in the
 Genyris jar file manifest.
 This can be accessed via the Java 
\emph on
Package
\emph default
 interface.
 Easy access is generated in the 
\emph on
versioninfo
\emph default
 module which has properties including the title.
 Example: 
\end_layout

\begin_layout LyX-Code
import versioninfo
\end_layout

\begin_layout LyX-Code
print versioninfo!version versioninfo!title
\end_layout

\begin_layout Subsection
symlist
\end_layout

\begin_layout Subsection
self-test-runner
\end_layout

\begin_layout Section
Using Java Classes
\end_layout

\begin_layout Standard
The Genyris interpreter allows standard Java objects to be created and stored
 in variable bindings, and allows Java methods to be called from Genyris.
 Java objects are contained within a builtin 'JavaWrapper' class, whose
 class list includes a Genyris class with Procedure objects corresponding
 to the Java methods.
 This allows Java objects and classes to be used in the same way as Genyris
 ones.
\end_layout

\begin_layout Standard
Java symbol names used for fields, classnames etc have a different syntax
 to Genyris, so rather than using escaped symbols, the default is to map
 Java Symbols to Genyris ones.
 The Genyris name based on the java name with some characters translated
 as follows:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Java character
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Genyris Character
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
_
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
This is used for class names method names, fields names or anywhere a Java
 name is used in a Genyris program.
\end_layout

\begin_layout Subsection
Importing a Java Class with 
\series medium
\size normal
\emph on
java:import
\end_layout

\begin_layout Standard
The 
\emph on
java:import
\emph default
 function creates a Genyris class corresponding to a Java class.
 The properties of the new Genyris class correspond to the methods and construct
ors of the Java class.
 The syntax is:
\end_layout

\begin_layout LyX-Code
java:import <java class string> [as <shorthand name>]
\end_layout

\begin_layout Standard
The full java class name is supplied as a string.
 Optionally a shorthand symbol to use as well as the default name can be
 specified.
 The default name is translated as described above.
 The return value is the Genyris class created.
 This class is bound to the corresponding full name in the global environment.
 If the 
\emph on
as
\emph default
 clause is present the class is also bound to the shorthand name in the
 local environment of the caller.
\end_layout

\begin_layout Standard
Example :
\end_layout

\begin_layout LyX-Code
> java:import 'java.lang.Object' as Jobject 
\end_layout

\begin_layout LyX-Code
 <class java_lang_Object (Java)> # StandardClass
\end_layout

\begin_layout LyX-Code
> assert (eq? java_lang_Object Jobject)
\end_layout

\begin_layout Standard
Continuing with the 
\emph on
java.io.File 
\emph default
example, we can list the method with 
\emph on
.vars
\emph default
:
\end_layout

\begin_layout LyX-Code
Jobject.vars
\end_layout

\begin_layout Standard
produces
\end_layout

\begin_layout LyX-Code
(.notifyAll .getClass .wait-long-int .equals-java_lang_Object .hashCode .wait-long
 .classname .wait .java-classname .toString .new .notify .superclasses .subclasses
 .self .vars .classes) # Pair 
\end_layout

\begin_layout Standard
The methods names include the argument types seperated by a hyphen since
 Java allows multiple methods with the same name and different arguments
 (overloading).
 Constructors, which are nameless in Java, are given the prefix 
\emph on
new
\emph default
-.
\end_layout

\begin_layout Subsubsection
Adding to Java Classes
\end_layout

\begin_layout Standard
Because 
\emph on
java:import
\emph default
 creates a standard Genyris class, you are free to add, remove, update and
 delete methods of the class.
 
\end_layout

\begin_layout Subsection
Creating Instances of Java Objects
\end_layout

\begin_layout Standard
Once a class has been imported, it is then possible to call the constructrs
 from the Genyris class.
 The constructor returns a new instance wrapped in a 
\emph on
JavaWrapper
\emph default
 object.
 For example:
\end_layout

\begin_layout LyX-Code
> java:import 'java.io.File' as FileJ
\end_layout

\begin_layout LyX-Code
> var file (FileJ(.new-java_lang_String '/'))
\end_layout

\begin_layout LyX-Code
[java.io.File /] # java_io_File JavaWrapper  
\end_layout

\begin_layout Standard
A call to a Java method involves several steps:
\end_layout

\begin_layout Itemize
The arguments are converted to the closest Java type if possible, if a 
\emph on
JavaWrapper
\emph default
 is provided, the embedded Java Object is used.
\end_layout

\begin_layout Itemize
The method is called, and exceptions caught
\end_layout

\begin_layout Itemize
The return value is converted to a Genyris type if possible, otherwise the
 return value is placed in a 
\emph on
JavaWrapper
\emph default
 object.
\end_layout

\begin_layout Itemize
Returned 
\emph on
JavaWrapper
\emph default
 objects are tagged with the relevant Genyris Java class if it has already
 been imported.
\end_layout

\begin_layout Subsection
Accessing Fields
\end_layout

\begin_layout Standard
Java objects are contained within 
\emph on
JavaWrapper 
\emph default
objects.
 When used as a function the the wrapper allows access to the fields of
 the Java objects using the dynamic symbol approach used for all other Genyris
 objects.
 In the above example we can list the Java fields with:
\end_layout

\begin_layout LyX-Code
> file!vars
\end_layout

\begin_layout LyX-Code
(.separatorChar .separator .pathSeparatorChar .pathSeparator
\end_layout

\begin_layout LyX-Code
.self .vars .classes .http://www.genyris.org/lang/java#class) 
\end_layout

\begin_layout LyX-Code
# Pair 
\end_layout

\begin_layout Standard
The special field java:class provides the real Java class of the object.
\end_layout

\begin_layout LyX-Code
> file!java:class
\end_layout

\begin_layout LyX-Code
'java.io.File' # String  
\end_layout

\begin_layout Standard
Read access to the fields is the same as for Dictionaries for example:
\end_layout

\begin_layout LyX-Code
> file!separator
\end_layout

\begin_layout LyX-Code
'/' # String
\end_layout

\begin_layout Standard
Write access is provided with 
\emph on
setq
\emph default
 as usual, however Java restrictions still apply:
\end_layout

\begin_layout LyX-Code
> file(setq .separator ';')
\end_layout

\begin_layout LyX-Code
*** Error - 'Can not set static final java.lang.String field java.io.File.separator
 to java.lang.String'
\end_layout

\begin_layout Subsection
Calling Methods
\end_layout

\begin_layout Standard
Calling Java method is identical to calling Genyris methods.
 Java static methods are treated the same as Genyris functions, in that
 they do not require a dynamic environment with 
\emph on
.self
\emph default
 bound.
 Java methods must be called within the context of a 
\emph on
JavaWrapper
\emph default
 object.
 Continuing with an example to list the files in a directory:
\end_layout

\begin_layout LyX-Code
> file(.list)
\end_layout

\begin_layout LyX-Code
('sys' 'srv' 'vmlinuz' 'selinux' ...
\end_layout

\begin_layout Standard
Notice that the Java 
\emph on
list()
\emph default
 method returns an array of 
\emph on
String
\emph default
, which is automatically converted into a list of Genyris strings.
\end_layout

\begin_layout Standard
Parameters are passed au usual, however basic types are automatically converted
 to Java objects if possible.
 Refer to the table below for details.
 For example:
\end_layout

\begin_layout LyX-Code
> file(.compareTo-java_lang_Object file)
\end_layout

\begin_layout LyX-Code
0 # Bignum 
\end_layout

\begin_layout Subsection
Conversions and Coersion
\end_layout

\begin_layout Standard
The following table lists the conversions of base types in method calls,
 constructor calls and in fields accesses.: 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Java
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Genyris
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
short
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BigDecimal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bignum
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
List
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
boolean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NIL or true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
java.awt.event.ActionListener
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<- Function Closure
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
other
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
JavaWrapper
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Conversion To Java Objects
\end_layout

\begin_layout Standard
The conversion of Genyris atoms and lists implicit in the calling of methods
 can be used explicitly with the 
\emph on
java:toJava
\emph default
 function.
 This takes two arguments, a string containing the name of a Java class
 and a Genyris object to be converted.
 The java class naming convention is is used for arrays.
 For example to convert a list of Bignums into a Java array of Integer:
\end_layout

\begin_layout LyX-Code
> java:import  '[Ljava.lang.Integer;'
\end_layout

\begin_layout LyX-Code
> java:toJava '[Ljava.lang.Integer;' ^(1 2 3)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
[[Ljava.lang.Integer; [Ljava.lang.Integer;@148aa23] # *Ljava_lang_Integer; JavaWrapp
er
\end_layout

\begin_layout Standard
Note that since we imported the class 
\emph on
[Ljava.lang.Integer;
\emph default
 the conversion automatically tags the 
\emph on
JavaWrapper
\emph default
 with that class.
\end_layout

\begin_layout Subsubsection
Conversion from Java To Genyris Objects
\end_layout

\begin_layout Standard
Basic Java objects are converted into Genyris objects in a straightforward
 manner.
 These conversions implicit on the return from Java method calls can be
 called explicitly using the 
\emph on
java:toGenyris
\emph default
 function, which takes a single argument.
 For example here we convert a list of bignums to a Java array of Integer
 and back:
\end_layout

\begin_layout LyX-Code
> var y     java:toJava '[Ljava.lang.Integer;' ^(1 2 3)
\end_layout

\begin_layout LyX-Code
[[Ljava.lang.Integer; [Ljava.lang.Integer;@2087c268] # JavaWrapper
\end_layout

\begin_layout LyX-Code
> java:toGenyris y
\end_layout

\begin_layout LyX-Code
(1 2 3) # Pair 
\end_layout

\begin_layout Subsection
Using Java Reflection from Genyris
\end_layout

\begin_layout Standard
Java Reflection methods can be called (just like any other Java interface)
 to get more detailed information about the Java world.
 Here is an example which lists every method of 
\emph on
java.lang.class
\emph default
 in detail:
\end_layout

\begin_layout LyX-Code
> var c 
\end_layout

\begin_layout LyX-Code
  java_lang_Class
\end_layout

\begin_layout LyX-Code
      .forName-java_lang_String 'java.lang.Class'
\end_layout

\begin_layout LyX-Code
[java.lang.Class class java.lang.Class] # java_lang_Class JavaWrapper 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> for m in (c(.getMethods)) (print m)
\end_layout

\begin_layout LyX-Code
[java.lang.reflect.Method public static java.lang.Class java.lang.Class.forName(java.lang.
String) throws java.lang.ClassNotFoundException]
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout Subsection
Hooking Swing Events in Genyris
\end_layout

\begin_layout Standard
Swing programs can be written in Genyris using the FFI descibed here.
 All the Swing classes can be accessed as usual, however there is one special
 case - handling of events from Swing.
 When Swing has an event to process (typically from a user action such as
 a mouse click) it needs to call a Genyris function.
 The Genyris 
\emph on
java:actionListener
\emph default
 function creates a bridging object that holds a closure which can be called
 later by Swing.
 The syntax is:
\end_layout

\begin_layout LyX-Code
java:actionListener <closure>
\end_layout

\begin_layout Standard
Either lazy or eager procedures can be used in the closure parameter.
 Here's an example:
\end_layout

\begin_layout LyX-Code
def onCancel(event)
\end_layout

\begin_layout LyX-Code
    window(.dispose)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
cancelButton(.addActionListener-java_awt_event_ActionListener (java:actionListene
r onCancel))
\end_layout

\begin_layout Standard
Here we have supplied an ActionListener to a Button object.
 The action listener saves the closure created by the 
\emph on
def
\emph default
.
 When the user presses the button the onCancel function is called.
 Notice how the closure captures the 
\emph on
window
\emph default
 binding.
 
\end_layout

\begin_layout Standard
Refer to the source file '
\emph on
examples/swing.g
\emph default
' for a complete example which looks like this:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename swing.JPG

\end_inset


\end_layout

\begin_layout Subsection
Plotting 2D Figures on a Swing Canvas
\end_layout

\begin_layout Standard
Sometimes it's useful to be able to draw shapes and place images on a simple
 canvas.
 The supplied examples include 
\emph on
swing-canvas.g
\emph default
 which draws a red oval onto the frame:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename redOval.jpg
	scale 50

\end_inset


\end_layout

\begin_layout Standard
To allow the frame to be re-painted when it is moved about or re-sized,
 a special Java class is provided which allows the 
\emph on
paintComponent()
\emph default
 to be executed in Genyris.
 Instead of using the 
\emph on
JPanel
\emph default
 component, one uses a 
\emph on
GPanel
\emph default
 component, supplying a closure as an argument.
 The closure is executed by Swing when it needs the frame to be re-drawn.
 Let's review code.
 
\end_layout

\begin_layout Standard
First a callback function is defined which takes three parameters, a 
\emph on
Graphics
\emph default
 object (where drawing is done) and and a string:
\end_layout

\begin_layout LyX-Code
java:import 'java.awt.Graphics' as Graphics
\end_layout

\begin_layout LyX-Code
def paint(graphics id command)
\end_layout

\begin_layout LyX-Code
  tag Graphics graphics # set up the methods
\end_layout

\begin_layout LyX-Code
  cond
\end_layout

\begin_layout LyX-Code
     graphics # did we get an object?
\end_layout

\begin_layout LyX-Code
         graphics   # ok , draw on it
\end_layout

\begin_layout LyX-Code
             .drawLine-int-int-int-int 0 0 100 100
\end_layout

\begin_layout Standard
Next the special 
\emph on
GPanel
\emph default
 is created.
 The constructor expects a Genyris closure object:
\end_layout

\begin_layout LyX-Code
java:import 'org.genyris.java.swing.GPanel' as GPanel
\end_layout

\begin_layout LyX-Code
var panel 
\end_layout

\begin_layout LyX-Code
  GPanel
\end_layout

\begin_layout LyX-Code
   .new-org_genyris_interp_AbstractClosure paint
\end_layout

\begin_layout Standard
Finally the GPanel is added to a frame:
\end_layout

\begin_layout LyX-Code
frame
\end_layout

\begin_layout LyX-Code
    .add-java_awt_Component panel
\end_layout

\begin_layout LyX-Code
    .setVisible-boolean true
\end_layout

\begin_layout Standard
This approach of adding a Java class can be used wherever a 
\emph on
paintComponent
\emph default
 callback is required.
 The Java code is minimal:
\end_layout

\begin_layout LyX-Code
public class GPanel extends JPanel {
\end_layout

\begin_layout LyX-Code
	private static final long serialVersionUID = 1L;
\end_layout

\begin_layout LyX-Code
	private AbstractClosure repaint;
\end_layout

\begin_layout LyX-Code
	public GPanel(AbstractClosure closure) {
\end_layout

\begin_layout LyX-Code
		super();
\end_layout

\begin_layout LyX-Code
		repaint = closure;
\end_layout

\begin_layout LyX-Code
	}
\end_layout

\begin_layout LyX-Code
	public void paintComponent(Graphics g) {
\end_layout

\begin_layout LyX-Code
		if (repaint != null) {
\end_layout

\begin_layout LyX-Code
			Exp args[] = {             
\end_layout

\begin_layout LyX-Code
               JavaUtils.wrapJavaObject(repaint.getEnv(), g) 
\end_layout

\begin_layout LyX-Code
            };
\end_layout

\begin_layout LyX-Code
			try {
\end_layout

\begin_layout LyX-Code
			   repaint.applyFunction(repaint.getEnv(), args);
\end_layout

\begin_layout LyX-Code
			} catch (GenyrisException e) {
\end_layout

\begin_layout LyX-Code
				e.printStackTrace();
\end_layout

\begin_layout LyX-Code
			}
\end_layout

\begin_layout LyX-Code
		}
\end_layout

\begin_layout LyX-Code
	}
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
Limitations
\end_layout

\begin_layout Standard
The following limitations exist which may be removed in later versions:
\end_layout

\begin_layout Itemize
Genuine methods called '
\emph on
new
\emph default
' may clash with constructors.
\end_layout

\begin_layout Itemize
There may be name collisions between Genyris and Java.
 e.g.
 a Java method called 
\emph on
foo-org_bar_Class()
\emph default
 would clash with a Java method 
\emph on
foo(org.bar.Class c).
\end_layout

\begin_layout Itemize
Java Readers and Writers are not converted to Genyris streams.
\end_layout

\begin_layout Itemize
The Java class hierarchy is not duplicated in the imported Genyris classes
 since the method list is a closure over the superclasses of a class.
\end_layout

\begin_layout Itemize
There is no universal facility for allowing Java programs to call back Genyris
 functions, only 
\emph on
java.awt.event.ActionListener
\emph default
 is supported.
\end_layout

\begin_layout Section
Extending and Modifying Genyris
\end_layout

\begin_layout Subsection
Adding Builtin Java Functions to Core Genyris Classes
\end_layout

\begin_layout Standard
All Genyris functions are implemented as normal Java classes.
 This include the core classes for data such as Bignum, String etc.
 For example the Bignum objects are internally implemented as Java BigDecimals.
 Therefore it is easy to leverage existing Java functionality for the internal
 representation by using the Java FFI.
 It suffices to define a Genyris function or method which access the internal
 object via a reference and manipulates it.
 Consider:
\end_layout

\begin_layout LyX-Code
> java:import 'java.math.BigDecimal'
\end_layout

\begin_layout LyX-Code
> java:toJava 'java.math.BigDecimal' 123
\end_layout

\begin_layout LyX-Code
[java.math.BigDecimal 123] # java_math_BigDecimal
\end_layout

\begin_layout LyX-Code
                                  JavaWrapper 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
This expression 
\emph on
(java:toJava 'java.math.BigDecimal' 123)
\emph default
 obtains a reference to the internal BigDecimal object, which is in turn
 wrapped in a 
\emph on
JavaWrapper 
\emph default
object and tagged with the 
\emph on
java_math_BigDecimal
\emph default
 class.
 This allows direct access to the underlying object via its methods.
 
\end_layout

\begin_layout Standard
Here is a Genyris method which returns the precision of a Bignum:
\end_layout

\begin_layout LyX-Code
> Bignum
\end_layout

\begin_layout LyX-Code
    def .precision()
\end_layout

\begin_layout LyX-Code
        (java:toJava 'java.math.BigDecimal' .self)
\end_layout

\begin_layout LyX-Code
             .precision
\end_layout

\begin_layout LyX-Code
> 2134(.precision)
\end_layout

\begin_layout LyX-Code
4 # Bignum 
\end_layout

\begin_layout Standard
Here is another example, character replacement method for all strings:
\end_layout

\begin_layout LyX-Code
String
\end_layout

\begin_layout LyX-Code
    def .replace(old new)
\end_layout

\begin_layout LyX-Code
        (java:toJava 'java.lang.String' .self)
\end_layout

\begin_layout LyX-Code
               .replace-char-char old new
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
> "Shop"(.replace 'p' 'e')
\end_layout

\begin_layout LyX-Code
'Shoe' # String 
\end_layout

\begin_layout Section
Alist
\end_layout

\begin_layout Subsubsection
.lookup(key)
\end_layout

\begin_layout Subsubsection
.getKeys()
\end_layout

\begin_layout Subsubsection
.hasKey(key)
\end_layout

\begin_layout Subsubsection
.render()
\end_layout

\begin_layout Section
Pair
\end_layout

\begin_layout Subsection
.each
\end_layout

\begin_layout Section
ListOfLines
\end_layout

\begin_layout Section
Object
\end_layout

\begin_layout Subsubsection
.new
\end_layout

\begin_layout Subsubsection
.init
\end_layout

\begin_layout Section
Index
\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex

\end_inset


\end_layout

\end_body
\end_document
