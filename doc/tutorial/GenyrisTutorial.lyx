#LyX 1.5.3 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass article
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\branch Future
\selected 1
\color #bcb5ad
\end_branch
\leftmargin 1cm
\topmargin 1cm
\rightmargin 1cm
\bottommargin 1cm
\headheight 1cm
\headsep 1cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Genyris Language Tutorial
\end_layout

\begin_layout Author
Bill Birch
\end_layout

\begin_layout Standard
\noindent
\align center
birchb@genyris.org
\end_layout

\begin_layout Abstract
This document provides an introduction to programming in the Genyris language.
 The language is a derivative of Lisp with a mostly parenthesis-free syntax
 yet retaining infix notation.
 It supports generic programming through macros and object-orientation.
 It offers a style of object-orientation where all objects have many classes
 and where classes are assigned to objects after construction.
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Paragraph*
Conventions used in this tutorial:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\emph on
italicized 
\emph default
Snippets of Genyris programs
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\family typewriter
fixed-font
\family default
 Larger programs are in a fixed font.
 Interactive sessions are show with the 
\family typewriter
>
\family default
 prompt of the command-line interpreter and the results printed underneath.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Note Greyedout
status open

\begin_layout Standard
Grey\InsetSpace ~
text indicates a feature is not yet implemented.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Getting Started
\end_layout

\begin_layout Subsection*
Installation
\end_layout

\begin_layout Standard
Genyris is available as a binary executable Java 
\emph on
jar
\emph default
 file.
 You don't need to understand Java to use Genyris.
 You will need the Java 1.5 JRE or later to run the Genyris interpreter.
 Java can be downloaded from Sun Microsystems.
 Check with your JRE version with this command:
\end_layout

\begin_layout LyX-Code
$ 
\series bold
java -version
\end_layout

\begin_layout Standard
Start the Genyris command-line interpreter with this command: 
\end_layout

\begin_layout LyX-Code
$ 
\series bold
java -jar genyris-bin-nnn-xxxxxxxxx.jar
\end_layout

\begin_layout Standard
Where 
\emph on
nnn-xxxxxxxxx
\emph default
 is the version number.
 You will see a prompt indicating the interpreter is ready for your input:
\end_layout

\begin_layout LyX-Code
*** Genyris is listening...
\end_layout

\begin_layout LyX-Code
>
\end_layout

\begin_layout Subsection*
Executing Expressions
\end_layout

\begin_layout Standard
Genyris commands can now be typed at the prompt, use two carriage returns
 (
\begin_inset Formula $\hookleftarrow$
\end_inset

) to terminate a statement.
 For example to add two numbers type:
\end_layout

\begin_layout LyX-Code
> 
\series bold
+ 42 37 
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout Standard
Genyris responds with the answer and a comment about the result:
\end_layout

\begin_layout LyX-Code
~ 79 ; Bignum
\end_layout

\begin_layout Subsection*
Verifying the Install
\end_layout

\begin_layout Standard
To test the installation run the self test suite with the following command:
\end_layout

\begin_layout LyX-Code
> 
\series bold
load "testscripts/testsuite.lin"
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
\begin_inset Formula $\hookleftarrow$
\end_inset


\end_layout

\begin_layout Standard
All being well, it will print 
\begin_inset Quotes eld
\end_inset

OK
\begin_inset Quotes erd
\end_inset

 and the number of tests passed.
\end_layout

\begin_layout Subsection*
Running Examples
\end_layout

\begin_layout Standard
The release binary file includes some examples which can be extracted as
 follows:
\end_layout

\begin_layout LyX-Code
$ 
\series bold
jar xvf *.jar examples
\series default
 
\end_layout

\begin_layout Standard
This creates a directory called 
\emph on

\begin_inset Quotes eld
\end_inset

examples
\emph default

\begin_inset Quotes erd
\end_inset

 with a number of 
\begin_inset Quotes eld
\end_inset

.lin
\begin_inset Quotes erd
\end_inset

 files.
 The files can be edited with your favourite text editor and run with the
 
\emph on
include
\emph default
 function.
 For example, to load an run the 
\begin_inset Quotes eld
\end_inset

Eight Queens
\begin_inset Quotes erd
\end_inset

 example do:
\end_layout

\begin_layout LyX-Code
> 
\series bold
include "examples/queens.lin"
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ "file:/home/birchb/workspace/Genyris/examples/queens.lin" ; String 
\end_layout

\begin_layout LyX-Code
> 
\series bold
queens 8
\end_layout

\begin_layout Section
Syntax
\end_layout

\begin_layout Standard
The syntax of Genyris uses indentation to convey program structure.
 This is in common with other languages such as Python.
 However Genyris preserves the 
\begin_inset Quotes eld
\end_inset

prefix
\begin_inset Quotes erd
\end_inset

 notation of Lisp and Scheme.
 Here is an example of some code defining a function:
\end_layout

\begin_layout LyX-Code
def threat (i j a b)
\end_layout

\begin_layout LyX-Code
   or
\end_layout

\begin_layout LyX-Code
      = i a
\end_layout

\begin_layout LyX-Code
      = j b
\end_layout

\begin_layout LyX-Code
      = (- i j) (- a b)
\end_layout

\begin_layout LyX-Code
      = (+ i j) (+ a b)
\end_layout

\begin_layout Standard
Instead of curly braces or 
\emph on
begin
\emph default
 and 
\emph on
end
\emph default
 tokens, the indentation defines the blocks of code.
 Genyris reads lines one-by-one until it reaches the end of an expression.
 An expression ends when there are no more indented lines.
 The interactive command-line ends an expression whenever two blank lines
 are read.
 Within a line, tokens are separated by white-space.
 Genyris recognizes the following tokens:
\end_layout

\begin_layout Itemize
Comments
\end_layout

\begin_layout Itemize
Numbers
\end_layout

\begin_layout Itemize
Strings
\end_layout

\begin_layout Itemize
Symbols
\end_layout

\begin_layout Itemize
Sub-expressions
\end_layout

\begin_layout Itemize
List Pairs
\end_layout

\begin_layout Itemize
Parser macros and directives
\end_layout

\begin_layout Subsection
Comments
\end_layout

\begin_layout Standard
All characters following a semi-colon until the end of the line are ignored
 by the parser.
 For example:
\end_layout

\begin_layout LyX-Code

\series bold
; mark the number 24 as a member of class 'C'
\end_layout

\begin_layout LyX-Code
tag C 24     
\series bold
; => ~ 24 ; Bignum C
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
Numbers
\end_layout

\begin_layout Standard
Numbers can be either integers or floating point with any number of leading
 or trailing digits
\begin_inset Foot
status open

\begin_layout Standard
Java 
\emph on
floats
\emph default
 and 
\emph on
doubles
\emph default
 will be added
\end_layout

\end_inset

.
 Examples:
\end_layout

\begin_layout LyX-Code
-3 23.78 -100.0089
\end_layout

\begin_layout Subsection
Strings
\end_layout

\begin_layout Standard
Strings are delimited by double quote characters ", within a string quotes
 and special characters are escaped with backslash 
\backslash
.
 For example 
\family typewriter
\emph on
She said 
\backslash
"sea shells
\backslash
"
\family default
\emph default
 yields the string:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features>
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
She said "sea shells"
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Other escape sequences are encoded as follows:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="bottom" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\series bold

\backslash
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
New Line
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\series bold

\backslash
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Carriage Return
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\series bold

\backslash
f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Form Feed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\series bold

\backslash

\backslash

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Backslash
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\series bold

\backslash
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Tab
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\series bold

\backslash

\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Quote
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold

\backslash
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Bell
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Symbols
\end_layout

\begin_layout Standard
Symbols are a group of any printable characters with the following exceptions:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\series bold
,
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
comma
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
exclamation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\series bold
:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
colon
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\series bold
'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
single quote
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\series bold
"
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
double quote
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\series bold
`
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
backquote
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\family typewriter
\series bold
@
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
at sign
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The following are all examples of valid symbols:
\end_layout

\begin_layout LyX-Code
Wednesday-12
\end_layout

\begin_layout LyX-Code
_age
\end_layout

\begin_layout LyX-Code
*global*
\end_layout

\begin_layout LyX-Code
+=
\end_layout

\begin_layout LyX-Code
${variable.name}
\end_layout

\begin_layout Standard
In Genyris symbols are 
\begin_inset Quotes eld
\end_inset

interned
\begin_inset Quotes erd
\end_inset

 by the parser so that there is only ever one instance of a particular symbol.
 Symbols are Case Sensitive so for example 
\emph on
Kookaburra
\emph default
 and 
\emph on
kookaburra
\emph default
 are different symbols.
\end_layout

\begin_layout Subsection
Expressions and Sub-expressions
\end_layout

\begin_layout Standard
All Genyris expressions are parsed and stored as linked-lists.
 A single line is converted into a single list.
 Sub-expressions are denoted in two ways, either within parentheses on a
 single line, or by an indented line.
 For example the following line contains two sub-expressions:
\end_layout

\begin_layout LyX-Code
Alpha (Beta Charlie) (Delta)
\end_layout

\begin_layout Standard
Sub-expressions made using parentheses must remain within a single line,
 they are not permitted to wrap.
 Indented lines are deemed to be sub-expressions of the superior, less indented,
 lines above.
 The above expression can be written in indented form as follows:
\end_layout

\begin_layout LyX-Code
Alpha
\end_layout

\begin_layout LyX-Code
   Beta Charlie
\end_layout

\begin_layout LyX-Code
   Delta
\end_layout

\begin_layout Standard
Indentations must line up with previous indentations of the same level as
 follows (spaces indicated with periods):
\end_layout

\begin_layout LyX-Code
Alpha
\end_layout

\begin_layout LyX-Code
...Beta Charlie
\end_layout

\begin_layout LyX-Code
......Delta
\end_layout

\begin_layout LyX-Code
...
\series bold
Beta
\series default
              ; correct indentation
\end_layout

\begin_layout Standard
The parser is unable to cope with random indentation levels since it does
 not know what depth is required.
 The following example will generate an error:
\end_layout

\begin_layout LyX-Code
Alpha
\end_layout

\begin_layout LyX-Code
...Beta Charlie
\end_layout

\begin_layout LyX-Code
......Delta
\end_layout

\begin_layout LyX-Code
.....
\series bold
Beta
\series default
              ; ERROR
\end_layout

\begin_layout Subsection
Pairs
\end_layout

\begin_layout Standard
Within Genyris lists are composed of pairs of references to objects
\begin_inset Foot
status open

\begin_layout Standard
Lisp Cons cells
\end_layout

\end_inset

.
 Pairs have two elements, the left and right, which are references to other
 Genyris objects.
 The left and right halves of a 
\emph on
Pair
\emph default
 can be delimited with the colon : character, an infix operator.
 For example: 
\end_layout

\begin_layout LyX-Code
(1 : 2) 
\end_layout

\begin_layout Standard
denotes a 
\emph on
Pair
\emph default
 referring to the numbers 1 and 2.
 Genyris expressions are also composed of linked lists of
\emph on
 Pairs
\emph default
, hence the expression:
\end_layout

\begin_layout LyX-Code
(A B C D)
\end_layout

\begin_layout Standard
is shorthand for, and exactly the same as :
\end_layout

\begin_layout LyX-Code
(A : (B : (C : (D : nil))))
\end_layout

\begin_layout Standard
Lists are terminated with the special symbol 
\emph on
nil
\emph default
.
 An indented expression can be expressed in terms of 
\emph on
Pairs
\emph default
.
 Consider:
\end_layout

\begin_layout LyX-Code
Alpha
\end_layout

\begin_layout LyX-Code
   Beta
\end_layout

\begin_layout Standard
This is the same as 
\end_layout

\begin_layout LyX-Code
(Alpha : ((Beta : nil) : nil))
\end_layout

\begin_layout Standard
Lists do not always have to be terminated with 
\emph on
nil
\emph default
 , the colon : operator can be used to squeeze one more object reference
 into the end of the list.
 For example the following list has 
\emph on
C
\emph default
 instead of 
\emph on
nil
\emph default
:
\end_layout

\begin_layout LyX-Code
(A B : C) 
\end_layout

\begin_layout Standard
New pairs can be created explicitly with the cons function which takes two
 parameters - the left and right parts of a new pair.:
\end_layout

\begin_layout LyX-Code
> cons 123 456
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
123 : 456 ; Pair
\end_layout

\begin_layout Subsection
Quoting and Special Parser Characters
\end_layout

\begin_layout Standard
Lists and atoms can be quoted in Genyris.
 Quoting is used to prevent execution of expressions.
 A single atom can be quoted within an expression
\begin_inset Foot
status open

\begin_layout Standard

\emph on
list
\emph default
 is a function we will cover later.
 
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code
      list 1 2 
\series bold
'a
\series default
 3 4    ; evaluates to: (1 2 
\series bold
a
\series default
 3 4)
\end_layout

\begin_layout Standard
Quote characters are a shorthand notation to save typing.
 When the parser sees a single quote, it collects the expression following
 and wraps it within a 
\emph on
quote 
\emph default
expression.
 So 
\emph on
'<exp> 
\emph default
becomes 
\emph on
(quote <exp>).
 
\emph default
When the 
\emph on
quote
\emph default
 function is evaluated it does not evaluate its argument.
 So the above expression is actually:
\end_layout

\begin_layout LyX-Code
      list  1 2 
\series bold
(quote a)
\series default
 3 4
\end_layout

\begin_layout Standard
Embedded lists can be quoted, in which case the embedded list is not evaluated:
\end_layout

\begin_layout LyX-Code
      func 1 2 
\series bold
'(x y z)
\series default
 3 4
\end_layout

\begin_layout Standard
If the quote falls at the beginning of the line, only the first element
 is quoted, not the entire line.
 So:
\end_layout

\begin_layout LyX-Code
      list 1 2
\end_layout

\begin_layout LyX-Code
          
\series bold
'x
\series default
 y z
\end_layout

\begin_layout Standard
is the same as:
\end_layout

\begin_layout LyX-Code
      list 1 2 (
\series bold
(quote x)
\series default
 y z)
\end_layout

\begin_layout Standard
To allow entire sub-trees to be quoted, the quote function needs to be used
 as in this example:
\end_layout

\begin_layout LyX-Code
      list 1 2
\end_layout

\begin_layout LyX-Code
         
\series bold
quote
\end_layout

\begin_layout LyX-Code
            x y z
\end_layout

\begin_layout Standard
which is the same as:
\end_layout

\begin_layout LyX-Code
      list 1 2 
\series bold
(quote (x y z))
\end_layout

\begin_layout Subsection
Line Continuation
\end_layout

\begin_layout Standard
Sometimes long expressions become unwieldy and must be continued on following
 lines.
 There are two mechanisms for this.
 This first and simplest is to use the colon : operator and an indented
 line as follows:
\end_layout

\begin_layout LyX-Code
list 1 2 4 5 : 
\end_layout

\begin_layout LyX-Code

\series bold
   6 7 8
\end_layout

\begin_layout Standard
This is equivalent to: 
\end_layout

\begin_layout LyX-Code
list 1 2 4 5 
\series bold
: (6 7 8)
\end_layout

\begin_layout Standard
which is the same as:
\end_layout

\begin_layout LyX-Code
list 1 2 4 5 
\series bold
6 7 8
\end_layout

\begin_layout Standard
The parser also has a special line continuation character (the tilde ~)
 which continues the previous line indentation level at the start of the
 line under which it is placed.
 This allows arbitrary continuations such as:
\end_layout

\begin_layout LyX-Code
quote
\end_layout

\begin_layout LyX-Code
   1 2
\end_layout

\begin_layout LyX-Code
      3
\end_layout

\begin_layout LyX-Code
      
\series bold
~ 22 
\series default
; Pair
\end_layout

\begin_layout Standard
which is the same as:
\end_layout

\begin_layout LyX-Code
quote '(1 2 (3) 
\series bold
22
\series default
)
\end_layout

\begin_layout Subsection
More Quote Characters
\end_layout

\begin_layout Standard
Genyris also supports three other special syntactic quotes similar to single
 quotes.
 They are all used to simplify writing macros with the 
\emph on
template 
\emph default
function, but can be used for anything else.
 These are converted by the parser into expressions as follows:
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Input Quote Sequence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\series bold
Translated Expression
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
,<exp>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(comma <exp>)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
,@<exp>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(comma-at <exp>)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
`<exp>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
(template <exp>)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Standard
In a future version you will be able to call the parser in any environment
 (not just the global one and hence bind the quote symbols to your own values).
\end_layout

\end_inset


\end_layout

\begin_layout Section
Variables 
\end_layout

\begin_layout Standard
New variables are created with the 
\emph on
defvar 
\emph default
or 
\emph on
define
\emph default
 functions.
 These functions also take an initial value for the variable:
\end_layout

\begin_layout LyX-Code
define name "William"
\end_layout

\begin_layout LyX-Code
defvar 'name "William"
\end_layout

\begin_layout Standard
In both examples, the symbol 
\emph on
name
\emph default
 is bound to the value 
\emph on

\begin_inset Quotes eld
\end_inset

William
\begin_inset Quotes erd
\end_inset


\emph default
 in the current environment.
 After the variable has been bound, its value can be used in any expression
 in the scope.
 The 
\emph on
define 
\emph default
function has an alias 
\emph on
var
\emph default
 which is quicker to type:
\end_layout

\begin_layout LyX-Code

\series bold
var
\series default
 name "William"
\end_layout

\begin_layout Standard
When the interpreter sees a symbol in an argument list it looks for a binding
 in the current environment and all parent environments right up to the
 global execution environment.
 If you define a variable at the command line, it is bound in the global
 execution environment and hence is available everywhere.
 If you try to access a variable when there is no binding, an "unbound variable"
 error will be reported.
\end_layout

\begin_layout Standard
Variable values can be updated with the 
\emph on
set
\emph default
 or 
\emph on
set^
\emph default
 functions, for example:
\end_layout

\begin_layout LyX-Code
set 'name "William Pitt"
\end_layout

\begin_layout LyX-Code
set^ name "William Pitt"
\end_layout

\begin_layout Standard
A predicate function 
\emph on
bound?
\emph default
 is provided to test whether a symbol has a binding in the current environments.
 It returns the symbol 
\emph on
true
\emph default
 if the variable is defined otherwise 
\emph on
nil
\emph default
.
 
\end_layout

\begin_layout Section
Functions
\end_layout

\begin_layout Standard
As we have seen, Genyris can execute statements immediately at the command
 line.
 The expression:
\end_layout

\begin_layout LyX-Code
+ 42 37
\end_layout

\begin_layout Standard
Yields the addition of the two numbers (77).
 Let's explore how this works.
 The interpreter looks for list expressions and assumes the first token
 (or sub-expression) is a procedure.
 The rest of the list constitute the arguments to the procedure.
 In this case 
\emph on
+
\emph default
 is a symbol which yields a procedure object.
 The arguments are also evaluated and the results are passed to the procedure
 to be evaluated.
 Lets have a look at 
\emph on
+
\emph default
 by getting its value:
\end_layout

\begin_layout LyX-Code
> the +
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ <org.genyris.math.PlusFunction> ; EagerProcedure
\end_layout

\begin_layout Standard
The function 
\emph on
the
\emph default
 is the identity function - it simply returns the value of its argument.
 Since the symbol + is an argument to 
\emph on
the,
\emph default
 its value is the underlying procedure.
 A 
\begin_inset Quotes eld
\end_inset

Procedure
\begin_inset Quotes erd
\end_inset

, or 
\begin_inset Quotes eld
\end_inset

Closure
\begin_inset Quotes erd
\end_inset

, is an object which keeps a reference to the environment in which it was
 originally defined and the executable code to be run when called.
 In addition it knows how its arguments are to be handled before the executable
 code is run.
\end_layout

\begin_layout Subsection
Eager Functions
\end_layout

\begin_layout Standard
Eager functions are the default in most programming languages.
 These evaluate their arguments prior to applying the underlying procedure.
 Mathematical functions such as + - * and / are eager functions.
 Let's experiment with some simple math function calls.
 All the following expressions evaluate to 12:
\end_layout

\begin_layout LyX-Code
+ 6 6
\end_layout

\begin_layout LyX-Code
+ (* 2 3) (+ 2 4)
\end_layout

\begin_layout LyX-Code
+ 2 2 2 2 2 2
\end_layout

\begin_layout Standard
Notice that the + function can have many arguments.
 Another function that takes multiple arguments is 
\emph on
list
\emph default
.
 This function constructs a list from its arguments.
 Here's an example:
\end_layout

\begin_layout LyX-Code
> list (* 34 8) "pears" (/ 34 5) "kilos"
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
272 "pears" 6.8 "kilos"; Pair
\end_layout

\begin_layout Standard
Note that the interpreter always prints a comment after the result.
 This comment is the list of classes the result belongs to.
 Since 
\emph on
list
\emph default
 returns a list, which is composed of Pairs, 
\emph on

\begin_inset Quotes eld
\end_inset

Pair
\emph default
 
\begin_inset Quotes eld
\end_inset

is printed.
 
\end_layout

\begin_layout Subsection
Lazy Functions - Conditional Execution
\end_layout

\begin_layout Standard
In contrast to Eger functions, Lazy functions do not evaluate their arguments.
 In other words, the interpreter passes the 
\series bold
source code
\series default
 of their arguments to the function.
 This allows the function to defer evalution or even exclude evaluation
 altogether, as is the case in conditional (flow control) constructs.
 
\end_layout

\begin_layout Standard
No language is complete without conditional functions.
 The 
\emph on
cond
\emph default
 function is a lazy function that allows program flow to change depending
 on the outcome of conditional expressions.
 Here's the syntax of 
\emph on
cond
\emph default
: 
\end_layout

\begin_layout LyX-Code
   cond
\end_layout

\begin_layout LyX-Code
      (<condition 1>)
\end_layout

\begin_layout LyX-Code
         <sequence 1>
\end_layout

\begin_layout LyX-Code
      (<condition 2>)
\end_layout

\begin_layout LyX-Code
         <sequence 2>
\end_layout

\begin_layout LyX-Code
      ...
\end_layout

\begin_layout LyX-Code
      (<condition N>)
\end_layout

\begin_layout LyX-Code
         <sequence N>
\end_layout

\begin_layout Standard
Each condition is evaluated in turn until one returns which is not 
\emph on
nil
\emph default
.
 The associated sequence is evaluated and the value of the last expression
 in the sequence is returned.
 If there is no sequence, the value of the condition is returned.
 Typically the last condition is a non-nil constant and its sequence is
 the default.
 The symbol 
\emph on
else
\emph default
 is provided for this purpose.
 Here's an example: 
\end_layout

\begin_layout LyX-Code
   cond
\end_layout

\begin_layout LyX-Code
      (equal? foo 1)
\end_layout

\begin_layout LyX-Code
         "One"
\end_layout

\begin_layout LyX-Code
      (equal? foo 2)
\end_layout

\begin_layout LyX-Code
         "Two"
\end_layout

\begin_layout LyX-Code
      else
\end_layout

\begin_layout LyX-Code
         "Other"
\end_layout

\begin_layout LyX-Code
    
\end_layout

\begin_layout Standard
The function 
\emph on
equal?
\emph default
 returns 
\emph on
true
\emph default
 if the two arguments are the same otherwise 
\emph on
nil
\emph default
.
 So if the symbol 
\emph on
foo
\emph default
 is bound to the value 2 this expression will return 
\emph on
"Two"
\emph default
.
 
\end_layout

\begin_layout Subsection
Defining Your Own Functions 
\end_layout

\begin_layout Standard
Functions in Genyris are defined in the usual way for functional programming
 languages.
 The 
\emph on
def
\emph default
 function binds a name to a lexical closure containing the current environment
 and the code to be applied in future calls.
 The body of the function is a sequence of expressions to be executed in
 the lexical environment, the last expression's value is returned.
 Here's a definition of the identity function:
\end_layout

\begin_layout LyX-Code
def identity (arg) arg
\end_layout

\begin_layout Standard
Genyris has two kinds of user-defined functions 'eager' and 'lazy'.
 An eager function evaluates its arguments before it applies them, whereas
 a lazy function does not.
 Traditional functions such as '+' and 
\emph on
the
\emph default
 are eager.
 
\emph on
list
\emph default
 is an eager function which returns all its arguments in a list.
 The 
\emph on
quote
\emph default
 function is a lazy procedure which returns its single argument un-evaluated.
 
\end_layout

\begin_layout Standard
Here is a more complex function definition:
\end_layout

\begin_layout LyX-Code
def factorial (n) 
\end_layout

\begin_layout LyX-Code
   if (< n 2) 1 
\end_layout

\begin_layout LyX-Code
      * n factorial (- n 1)
\end_layout

\begin_layout Standard
The 
\emph on
if
\emph default
 function is lazy, since, depending on the value of the first argument,
 it executes only one of its other two arguments .
 In fact, 
\emph on
if
\emph default
 is a macro - a special kind of lazy function which we introduce later.
\end_layout

\begin_layout Subsection
Anonymous Functions with Lambda and Friends 
\end_layout

\begin_layout Standard
Actually the 
\emph on
def
\emph default
 and 
\emph on
defmacro
\emph default
 functions are lazy functions.
 They bind a variable name to procedure compiled from the function body.
 But what if we want a function without the binding? Genyris provides three
 kinds of in-built procedure-building functions.
 The function 
\emph on
lambda
\emph default
 creates a user-defined eager procedure object which is a closure at the
 point of definition.
 For example we can create an anonymous function at the command-line:
\end_layout

\begin_layout LyX-Code
> 
\series bold
lambda
\series default
 (x) (* x x)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ <org.genyris.interp.ClassicFunction> ; EagerProcedure 
\end_layout

\begin_layout Standard
To actually call it we place it wherever a function is expected, such as
 a parameter to a function, or at the beginning of a list:
\end_layout

\begin_layout LyX-Code
> 
\series bold
(lambda (x) (* x x))
\series default
 3
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 9 ; Bignum
\end_layout

\begin_layout Standard
Notice the parentheses are required around the expression to trigger the
 execution.
 The argument 3 is passed to the resulting closure.
 Functions are 'first class' and can be assigned to variables, which is
 how 
\emph on
def
\emph default
 works.
 The following two expressions are equivalent:
\end_layout

\begin_layout LyX-Code
define square
\end_layout

\begin_layout LyX-Code
   lambda (x) (* x x) 
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
def square (x)
\end_layout

\begin_layout LyX-Code
   * x x 
\end_layout

\begin_layout Subsubsection
Anonymous Lazy Functions
\end_layout

\begin_layout Standard
To defer evaluation, a lazy function can be defined using the 
\emph on
lambdaq or lambdam
\emph default
 macros.
 
\emph on
lambdaq
\emph default
 is just like 
\emph on
lambda
\emph default
 except it builds a lazy procedure, 
\emph on
lambdam
\emph default
 builds anonymous macros.
 The next example creates an anonymous function which prepends its argument
 (without evaluation) to a list:
\end_layout

\begin_layout LyX-Code
> (
\series bold
lambdaq
\series default
 (x) (list x "World")) (+ "Hello")
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
(+ "Hello") "World" ; Pair
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Subsection
Type-Checked Function Arguments
\end_layout

\begin_layout Standard
Genyris supports the familiar type annotations found in most statically
 typed languages.
 These type checks are purely optional.
 When a function is defined, the arguments and return value may be annotated
 with a class.
 The actual arguments are checked with a validator (if present).
 Here's an example of a sensitive function protected by type checks:
\end_layout

\begin_layout LyX-Code
def safe-call ((a : Bignum) (b : Bignum) : Bignum) 
\end_layout

\begin_layout LyX-Code
    fragile-function a b    
\end_layout

\begin_layout Standard
This function only allows Bignums to be passed in or returned.
 The last element of the arguments list specifies the return type.
 If a type check fails an exception is raised.
\end_layout

\begin_layout Subsection
In-Line Type Checks
\end_layout

\begin_layout Standard
Genyris provides a simpler mechanism for ensuring type constraints are followed.
 If the last element of an expression list is not 
\emph on
nil
\emph default
, but a class, it will check if the result of the expression is 
\emph on
!valid
\emph default
?, or if it is an instance of the class.
 For example this function will always raise an error because
\emph on
 3
\emph default
 is not a subclass of 
\emph on
String
\emph default
:
\end_layout

\begin_layout LyX-Code
def fails()
\end_layout

\begin_layout LyX-Code
    define x 3
\end_layout

\begin_layout LyX-Code
    x : String
\end_layout

\begin_layout Standard
If a class validator is provided, this will be used otherwise a simple 
\begin_inset Quotes eld
\end_inset

nominative
\begin_inset Quotes erd
\end_inset

 type check of class membership based on the object's tagged classes is
 used.
 The 
\emph on
!valid?
\emph default
 method is a stronger check, however nominative checking is sometimes preferred
\begin_inset Foot
status open

\begin_layout Standard
Genyris supports both 
\begin_inset Quotes eld
\end_inset

nominative
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

structural
\begin_inset Quotes erd
\end_inset

 subtyping
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Defining Macros
\end_layout

\begin_layout Standard
Macros are lazy functions which are very handy for extending the syntax
 of the language or creating DSLs (Domain-Specific Languages).
 Macros also re-evaluate the returned value in the environment of the caller.
 Here's an example:
\end_layout

\begin_layout LyX-Code
defmacro do(&rest body)
\end_layout

\begin_layout LyX-Code
   cons 'lambda
\end_layout

\begin_layout LyX-Code
      cons nil
\end_layout

\begin_layout LyX-Code
        cons body nil
\end_layout

\begin_layout Standard
This macro assembles a lambda expression using the argument list as the
 body of the function.
 The keyword 
\emph on
&rest
\emph default
 tells the interpreter to collate the values of all remaining arguments
 into the single variable 
\emph on
body
\emph default
.
 So when called with:
\end_layout

\begin_layout LyX-Code
do
\end_layout

\begin_layout LyX-Code
   print "Hello World"
\end_layout

\begin_layout Standard
It creates this expression, which is then evaluated: 
\end_layout

\begin_layout LyX-Code
lambda ()
\end_layout

\begin_layout LyX-Code
   print "Hello World"
\end_layout

\begin_layout Standard
Here is a more complex example - definition of a control flow function:
 
\end_layout

\begin_layout LyX-Code

\series bold
defmacro
\series default
 my-if (test success-result failure-result)
\end_layout

\begin_layout LyX-Code
   
\series bold
template
\end_layout

\begin_layout LyX-Code
      cond
\end_layout

\begin_layout LyX-Code
         ,test ,success-result
\end_layout

\begin_layout LyX-Code
         else ,failure-result
\end_layout

\begin_layout Standard
This macro uses the 
\emph on
template
\emph default
 function and 
\emph on
comma
\emph default
 to splice the arguments into a formulaic expression.
 Here's an example if its use:
\end_layout

\begin_layout LyX-Code
define test 3                 ; binding in the caller's environment
\end_layout

\begin_layout LyX-Code
my-if (equal? test 3) 1 2     
\end_layout

\begin_layout Standard
This returns 1.
 Notice that the variable 
\emph on
test
\emph default
 is defined in the caller's environment used in the condition, not the binding
 of the same name within 
\emph on
my-if
\emph default
.
 
\end_layout

\begin_layout Subsection
Lexical Scoping Captures Environments
\end_layout

\begin_layout Standard
Genyris is "lexically scoped" - when a function is defined it remembers
 the environment in which it was defined and re-uses that environment when
 it executes.
 This provides a way of hiding data and giving functions stateful side effects.
 The following example
\begin_inset Foot
status open

\begin_layout Standard
refer to Abelson and Sussmans' book 
\begin_inset Quotes eld
\end_inset

Structure and Interpretation of Computer Programs
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 creates a function which captures the 
\emph on
balance
\emph default
 variable:
\end_layout

\begin_layout LyX-Code
def make-withdraw (balance) 
\end_layout

\begin_layout LyX-Code
   lambda (amount) 
\end_layout

\begin_layout LyX-Code
      set^ balance (- balance amount)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
define W1 (make-withdraw 100)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
> W1 25
\end_layout

\begin_layout LyX-Code
W1 25
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 75 ; Bignum
\end_layout

\begin_layout LyX-Code
~ 50 ; Bignum
\end_layout

\begin_layout Standard
Repeated execution of the function 
\emph on
W1
\emph default
 reduces the value of the balance each time.
 The sequence of evaluation is as follows:
\end_layout

\begin_layout Enumerate
the lazy 
\emph on
def
\emph default
 expression is executed which results in a procedure object bound to the
 symbol 
\emph on
make-withdraw
\end_layout

\begin_layout Enumerate
the 
\emph on
balance
\emph default
 argument to the eager 
\emph on
define
\emph default
 expression is evaluated and 
\emph on
make-withdraw 
\emph default
is called
\emph on
.
\end_layout

\begin_layout Enumerate
the eager 
\emph on
make-withdraw 
\emph default
creates a new environment in which it binds 
\emph on
balance
\emph default
 to 
\emph on
100
\end_layout

\begin_layout Enumerate
the body of 
\emph on
make-withdraw
\emph default
 is evaluated resulting in another procedure object which captures a reference
 to 
\emph on
balance 
\emph default
and contains the executable code starting with 
\emph on
set^
\end_layout

\begin_layout Enumerate
the procedure object is bound to W1
\end_layout

\begin_layout Enumerate

\emph on
W1
\emph default
 is called with the argument 25
\end_layout

\begin_layout Enumerate
the procedure object bound to 
\emph on
W1
\emph default
 subtracts 25 from the 
\emph on
balance
\emph default
 binding in the
\emph on
 
\emph default
environment created in step 3
\end_layout

\begin_layout Standard
Note that there is no way to directly access the 
\emph on
balance
\emph default
 variable.
 
\end_layout

\begin_layout Section
Everything is Callable
\end_layout

\begin_layout Standard
The Genyris evaluator expects the first element of a list to be some kind
 of procedure object - something that can compute its arguments and apply
 them.
 This is the role of traditional functions such as 
\emph on
+
\emph default
 or user-defined functions.
 In Genyris, 
\bar under
all
\bar default
 objects are callable, even atomic types.
 For example an integer can be called as a function thus:
\end_layout

\begin_layout LyX-Code
> 
\series bold
12
\series default
 (+ 33 44) (- 4 3)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 1 ; Bignum
\end_layout

\begin_layout Standard
Lets analyse what happened.
 The integer 
\emph on
12
\emph default
 was called with two argument 
\emph on
(+ 33 44)
\emph default
 and 
\emph on
(- 4 3)
\emph default
.
 Since 
\emph on
12
\emph default
 is a lazy function it did not evaluate its arguments.
 Rather it treated its arguments as a sequence of expressions to be evaluated
 in a new environment.
 So it calculated 333 + 44 = 77, and then 4 -3 = 1.
 When it reached this last expression it returned the value 1.
 This expression can be written in indented form with the same result as
 follows:
\end_layout

\begin_layout LyX-Code

\series bold
12
\series default
 
\end_layout

\begin_layout LyX-Code
   + 33 44
\end_layout

\begin_layout LyX-Code
   - 4 3
\end_layout

\begin_layout Standard
If an atom is called with no arguments, it simply returns itself.
 So at the command line typing a number alone returns the number:
\end_layout

\begin_layout LyX-Code
> 1024
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ 1024 ; Bignum
\end_layout

\begin_layout Standard
As well as executing the sequence of expressions, an execution environment
 was created in which the number 12 is a bound to the dynamic variable 
\emph on
self
\emph default
.
 The variable can be used as follows:
\end_layout

\begin_layout LyX-Code
> 12 (+ 
\series bold
!self !self
\series default
) 
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 24 ; Bignum
\end_layout

\begin_layout Standard
Here the number is added to itself.
 The environment can also be used to create local bindings with the 
\emph on
define
\emph default
 functions:
\end_layout

\begin_layout LyX-Code
12
\end_layout

\begin_layout LyX-Code
  
\series bold
define foo 987
\end_layout

\begin_layout LyX-Code
  + foo !self
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 999 ; Bignum  
\end_layout

\begin_layout Standard
Callable atoms could be used to add simple code block keywords to the langage.
 If a symbol is called as a function it is by default evaluated to locate
 the binding in the current evironment.
 If we make the value an atom, we can use the symbol as a a keyword.
 For example, the symbol 
\emph on
do
\emph default
 is defined like this:
\end_layout

\begin_layout LyX-Code
define my-do 'my-do 
\end_layout

\begin_layout Standard
Now whenever we call 
\emph on
my-do
\emph default
 as a function, it acts as a code block which can be used in a function:
\end_layout

\begin_layout LyX-Code

\series bold
def my-function()
\end_layout

\begin_layout LyX-Code

\series bold
   my-do
\end_layout

\begin_layout LyX-Code
      some-function "Hi!"
\end_layout

\begin_layout LyX-Code
      define a-variable 42
\end_layout

\begin_layout LyX-Code
      print !self
\end_layout

\begin_layout Standard
However within the context the do block of 
\emph on
!self 
\emph default
is bound to 
\emph on
my-do
\emph default
.
 Hence the above function prints 
\begin_inset Quotes eld
\end_inset

my-do
\begin_inset Quotes erd
\end_inset

.
 A better way to add new syntax is to create a macro, since 
\emph on
!self
\emph default
 is not affected.
 
\end_layout

\begin_layout Subsection
Dynamic Variables
\end_layout

\begin_layout Standard
Generally 'dynamic' variables are those which are bound in the environment
 of the caller and hence depend on who is evaluating the expression.
 In Genyris dynamic variables are limited to being properties of the currently
 called object, and called objects are part of their environment.
 In other words when an object is used as a procedure, the environment created
 to make the call is a merge of the object itself and a normal lexical environme
nt.
 When prefixed with the underscore ! character, the binding for the symbol
 is looked up in the dynamic context.
 An example will make this clearer:
\end_layout

\begin_layout Standard
The number 12 above has two dynamic variables, 
\emph on
!self
\emph default
 and 
\emph on
!classes
\emph default
.
 They can be accessed as follows:
\end_layout

\begin_layout LyX-Code
12
\end_layout

\begin_layout LyX-Code
  cons !self !classes
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
12 <class Bignum (Builtin) ()> ; Pair 
\end_layout

\begin_layout Standard
Here we see that the
\emph on
 !classes
\emph default
 variable is referring to the class list of 
\emph on
12.
 
\emph default
It has a single class, 
\emph on
Bignum,
\emph default
 which is printed.
 This behaviour is the same for the other atomic types: Bignums, Pairs and
 Strings.
 Consider the following examples:
\end_layout

\begin_layout LyX-Code
> "What am I?" !classes
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
<class String (Builtin) ()> ; Pair
\end_layout

\begin_layout Standard
However where symbols are concerned, the evaluator always looks up the value
 before use.
 So to show this with a symbol we must quote it:
\end_layout

\begin_layout LyX-Code
> 'a-symbol !classes
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
<class Symbol (Dictionary) ()> ; Pair
\end_layout

\begin_layout Standard
Likewise the interpreter assumes a list is a normal function call so a quote
 is needed to see this behaviour: 
\end_layout

\begin_layout LyX-Code
> '(3) !classes
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
<class Pair (Builtin) (PRINTWITHCOLON)> ; Pair
\end_layout

\begin_layout Standard
Most atomic types have only a single dynamic variable, richer examples lie
 in the compound object types.
\end_layout

\begin_layout Subsection
Working With Pairs and Lists
\end_layout

\begin_layout Standard
Like its forbears Lisp and Scheme, Genyris is inherently a list-processing
 language - its source code is expressed as lists and it has inbuilt functions
 for parsing and manipulating list data.
 Since programs and data are stored in the same form, Genyris is an ideal
 platform for developing DSLs or even new programming languages.
 Happily, manipulating lists is easy.
 Lists are a kind of 
\begin_inset Quotes eld
\end_inset

binary tree".
 Trees are constructed with the 
\emph on
cons
\emph default
 function which accepts two arguments for the left and right halves of the
 
\emph on
Pair
\emph default
:
\end_layout

\begin_layout LyX-Code
> 
\series bold
cons
\series default
 "A" "B"
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
"A" : "B" ; Pair
\end_layout

\begin_layout Standard
Note the interpreter prints a colon between the left and right halves of
 the Pair.
 The individual elements of a Pair can be accessed with the 
\emph on
left
\emph default
 and 
\emph on
right
\emph default
 functions:
\end_layout

\begin_layout LyX-Code
> 
\series bold
left
\series default
 (cons "A" "B")
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ "A" ; String
\end_layout

\begin_layout Standard
Alternatively the dynamic variables 
\emph on
!left
\emph default
 and 
\emph on
!right
\emph default
 can be used when the list is called:
\end_layout

\begin_layout LyX-Code
> var my-pair (cons "A" "B") 
\end_layout

\begin_layout LyX-Code
mypair !
\series bold
right
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
~ "B" ; String
\end_layout

\begin_layout LyX-Code
> my-pair
\end_layout

\begin_layout LyX-Code
   
\series bold
set^ !left 33
\end_layout

\begin_layout LyX-Code
   !self
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
33 : "B" ; Pair
\end_layout

\begin_layout Standard
To construct a proper List, the final right hand element will be 
\emph on
nil
\emph default
:
\end_layout

\begin_layout LyX-Code
> cons "A"
\end_layout

\begin_layout LyX-Code
    cons "B"
\end_layout

\begin_layout LyX-Code
       cons "C" nil 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
"A" "B" "C" ; Pair
\end_layout

\begin_layout Standard
The printing of trees (by default) assumes that the tree is a kind of list,
 hence you don't see the parentheses in this case.
 See how the interpreter identified the list as a 
\emph on
Pair
\emph default
, since it only has a reference to the first 
\emph on
Pair
\emph default
? 
\end_layout

\begin_layout Standard
To help view 
\emph on
Pairs
\emph default
 explicitly, a list can be tagged with the PRINTWITHCOLON class, which forces
 the printer to display the full tree structure.
 The parser does this automatically, so Pairs which the user types with
 a colon are printed the same way.
 For example:
\end_layout

\begin_layout LyX-Code
> '("A" : ("B" : ("C" )))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
"A" : ("B" : ("C")) ; PRINTWITHCOLON 
\end_layout

\begin_layout Subsection
Dictionaries - Your Garden Variety Objects
\end_layout

\begin_layout Standard
Genyris provides 
\begin_inset Quotes eld
\end_inset

dictionary
\begin_inset Quotes erd
\end_inset

 objects which are 
\begin_inset Quotes eld
\end_inset

objects
\begin_inset Quotes erd
\end_inset

 in the normally understood sense for programming languages.
 Each dictionary provides a un-ordered set of dynamic symbols and bindings
 - called 
\begin_inset Quotes eld
\end_inset

slots
\begin_inset Quotes erd
\end_inset

.
 A dictionary is created with the 
\emph on
dict
\emph default
 function call, e.g.:
\end_layout

\begin_layout LyX-Code
define pitt
\end_layout

\begin_layout LyX-Code
  
\series bold
dict 
\end_layout

\begin_layout LyX-Code

\series bold
    !name  : "Willam Pitt"
\end_layout

\begin_layout LyX-Code

\series bold
    !title : "Prime Minister"
\end_layout

\begin_layout LyX-Code

\series bold
    !date-of-birth   : "28 May 1759"
\end_layout

\begin_layout Standard
Here we have created a 
\emph on
dict
\emph default
 with three slots.
 The 
\emph on
dict
\emph default
 function takes a variable number of slot definitions in Pairs, more formally:
 
\end_layout

\begin_layout LyX-Code
  dict
\end_layout

\begin_layout LyX-Code
     <dynamic symbol1> : <initial value1>
\end_layout

\begin_layout LyX-Code
     <dynamic symbol2> : <initial value2>
\end_layout

\begin_layout LyX-Code
     etc...
\end_layout

\begin_layout Standard
If there are no initial values given , the symbol 
\emph on
nil
\emph default
 is used as the value as in this example:
\end_layout

\begin_layout LyX-Code
> 
\series bold
dict
\end_layout

\begin_layout LyX-Code

\series bold
   !foo
\end_layout

\begin_layout LyX-Code

\series bold
   !bar
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
dict
\end_layout

\begin_layout LyX-Code
      !bar : nil
\end_layout

\begin_layout LyX-Code
      !foo : nil ; Dictionary      
\end_layout

\begin_layout Standard
Having slots is all very well, but we need a way to access them.
 As we have seen all objects are callable - including dictionaries.
 So to access the above 
\emph on
dict
\emph default
 object we call it and use the dynamic variables as follows:
\end_layout

\begin_layout LyX-Code
> pitt !name
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ "Willam Pitt" ; String
\end_layout

\begin_layout Standard
Here the 
\emph on
!name
\emph default
 dynamic variable is bound to the 
\emph on
!name
\emph default
 slot in the dict.
 To set the slot value we use the 
\emph on
set^
\emph default
 function:
\end_layout

\begin_layout LyX-Code
pitt
\end_layout

\begin_layout LyX-Code
   
\series bold
set^ 
\series default
!name "William Pitt The Younger"
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
New slots can be created with 
\emph on
define
\emph default
 since the object acts as an environment in its own right.
 e.g.:
\end_layout

\begin_layout LyX-Code
pitt 
\end_layout

\begin_layout LyX-Code
   
\series bold
define
\series default
 !father "William Pitt the Elder"
\end_layout

\begin_layout Standard
Dictionaries also have a 
\begin_inset Quotes eld
\end_inset

magic
\begin_inset Quotes erd
\end_inset

 variable 
\emph on
!vars
\emph default
 which lists all the variables defined in the dictionary.
 This is handy for debugging.
 For example:
\end_layout

\begin_layout LyX-Code
> pitt 
\series bold
!vars
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
!date-of-birth !father !name !title !vars ; Pair
\end_layout

\begin_layout Subsection
Adding Behaviour to Dictionaries
\end_layout

\begin_layout Standard
Since functions in Genyris are simply bound to variables, and dictionaries
 have variables, behaviour can be added to dictionaries.
 It suffices to define a function with a dynamic name in the scope of a
 dictionary:
\end_layout

\begin_layout LyX-Code
define jeb
\end_layout

\begin_layout LyX-Code
  
\series bold
 dict
\end_layout

\begin_layout LyX-Code

\series bold
      !firstName: "Joe" 
\end_layout

\begin_layout LyX-Code

\series bold
      !middleName: "E."
\end_layout

\begin_layout LyX-Code

\series bold
      !lastName: "Brown"
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
jeb 
\end_layout

\begin_layout LyX-Code
   
\series bold
def !displayName()
\end_layout

\begin_layout LyX-Code

\series bold
       list !firstName !middleName !lastName
\end_layout

\begin_layout Standard
Once defined, the function is callable in the context of the 
\emph on
jeb
\emph default
 dict:
\end_layout

\begin_layout LyX-Code
> jeb 
\series bold
(!displayName)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
"Joe" "E." "Brown" ; Pair
\end_layout

\begin_layout Standard
A dict can be used a mechanism for organisation.
 Consider the following fictional example - a set of functions organised
 in a 
\begin_inset Quotes eld
\end_inset

module
\begin_inset Quotes erd
\end_inset

 called 
\emph on
file
\emph default
:
\end_layout

\begin_layout LyX-Code
;; File Handling Module
\end_layout

\begin_layout LyX-Code
define file
\end_layout

\begin_layout LyX-Code
  dict 
\end_layout

\begin_layout LyX-Code
    !name  : "File Handling Functions"
\end_layout

\begin_layout LyX-Code
    !version : "1.2"
\end_layout

\begin_layout LyX-Code
file
\end_layout

\begin_layout LyX-Code
   
\series bold
def !copy(from to) ...
\end_layout

\begin_layout LyX-Code

\series bold
   def !delete(filename) ...
\end_layout

\begin_layout LyX-Code

\series bold
   def !zip(file) ...
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
;; Use of the file module
\end_layout

\begin_layout LyX-Code
def archive(filename)
\end_layout

\begin_layout LyX-Code
    
\series bold
(file!copy) filename "/tmp/foo"
\end_layout

\begin_layout LyX-Code

\series bold
    (file!zip) "/tmp/foo"
\end_layout

\begin_layout LyX-Code

\series bold
    (file!delete) filename
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Here we define three functions bound to a single dict object.
 The functions can only be called by referencing the 
\emph on
file
\emph default
 object.
 While it is handy to be able to add behaviour to objects, it does not scale
 when there are many objects which require the same behaviour.
 For this we need something more complex - Classes and Inheritance.
\end_layout

\begin_layout Section
Using Namespaces
\end_layout

\begin_layout Standard
A way to prevent name clashes between modules is to use symbol prefixes
 to defne 'namespaces' for symbols.
 A namespace can be defined with a Parser Directive 
\begin_inset Quotes eld
\end_inset

@prefix
\begin_inset Quotes erd
\end_inset

 as follows
\end_layout

\begin_layout LyX-Code
@prefix magic "http://my.org/2008/spells/"
\end_layout

\begin_layout Standard
Here the expression starting with 
\emph on
@prefi
\emph default
x is consumed by the parser, and any subsequent symbols it sees starting
 with the prefix 
\emph on
magic
\emph default
.
 are replaced with 
\emph on
http://my.org/2008/spells/
\emph default
.
 Hence the true name of 
\emph on
magic.accio
\emph default
 is 
\emph on
http://my.org/2008/spells/accio
\emph default
.
 We can print the full name of the symbol by quoting it:
\end_layout

\begin_layout LyX-Code
> @prefix magic "http://my.org/2008/spells/"
\end_layout

\begin_layout LyX-Code
'magic.accio
\end_layout

\begin_layout LyX-Code
~ http://my.org/2008/spells/accio ; Symbol
\end_layout

\begin_layout Standard
Here is the previous example re-worked using a namespace:
\end_layout

\begin_layout LyX-Code
;; File Handling Module (using prefixes)
\end_layout

\begin_layout LyX-Code
@prefix file "genyris:/files/"
\end_layout

\begin_layout LyX-Code
def file.copy(from to) ...
\end_layout

\begin_layout LyX-Code
def file.delete(filename) ...
\end_layout

\begin_layout LyX-Code
def file.zip(file) ...
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
;; Use of the file module
\end_layout

\begin_layout LyX-Code
@prefix file "genyris:/files/"
\end_layout

\begin_layout LyX-Code
def archive(filename)
\end_layout

\begin_layout LyX-Code
    file.copy filename "/tmp/foo"
\end_layout

\begin_layout LyX-Code
    file.zip "/tmp/foo"
\end_layout

\begin_layout LyX-Code
    file.delete filename
\end_layout

\begin_layout Standard
Prefixes apply to all symbols seen by the parser in the current parse, and
 can be used in a variety of ways (for example) to define global properties
 or Interfaces.
  
\end_layout

\begin_layout Section
Using Classes to Organise Behaviour
\end_layout

\begin_layout Standard
All Genyris objects, be they atomic (like numbers) or composite (like dictionari
es) can belong to one or more classes.
 As such Genyris is a fully 
\begin_inset Quotes eld
\end_inset

Object-Oriented
\begin_inset Quotes erd
\end_inset

 language.
 The interpreter looks at the classes for functions to execute if the function
 name is dynamic (starts with an underscore).
 This way you can add behaviour to many objects in a single place.
 Classes are dictionaries with special variables which hold the relationships
 between classes.
 The standard classes all have the following variables:
\end_layout

\begin_layout Itemize
!classes 
\end_layout

\begin_layout Itemize
!vars 
\end_layout

\begin_layout Itemize
!classname 
\end_layout

\begin_layout Itemize
!superclasses
\end_layout

\begin_layout Itemize
!subclasses
\end_layout

\begin_layout Standard
Genyris has a number of built-in classes beginning with 
\emph on
Thing
\emph default
, root of the class hierarchy.
 Here is the builtin class hierarchy:
\end_layout

\begin_layout LyX-Code
Thing
\end_layout

\begin_layout LyX-Code
    Builtin
\end_layout

\begin_layout LyX-Code
            Bignum
\end_layout

\begin_layout LyX-Code
            String
\end_layout

\begin_layout LyX-Code
            Symbol
\end_layout

\begin_layout LyX-Code
            Pair
\end_layout

\begin_layout LyX-Code
                PRINTWITHCOLON
\end_layout

\begin_layout LyX-Code
            Dictionary
\end_layout

\begin_layout LyX-Code
            Closure
\end_layout

\begin_layout LyX-Code
                LazyProcedure
\end_layout

\begin_layout LyX-Code
                EagerProcedure
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
To add behaviour to a class, we need to add a dynamic variable bound to
 a closure object - in other words we need to define a method.
 For example a method to compute the square of a number be added to the
 
\emph on
Bignum
\emph default
 class:
\end_layout

\begin_layout LyX-Code
Bignum
\end_layout

\begin_layout LyX-Code
   def !square() (* 
\series bold
!self !self
\series default
)
\end_layout

\begin_layout Standard
Notice that the method uses the 
\emph on
!self
\emph default
 variable which will be automatically bound to an object.
 Now all Bignums can compute their own square e.g.:
\end_layout

\begin_layout LyX-Code
> 4234389 (!square)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 17930050203321 ; Bignum
\end_layout

\begin_layout Standard
We need to call methods in the correct way to ensure they refer to the right
 object since they are dynamic, not lexical variables.
 So if we tried to say:
\end_layout

\begin_layout LyX-Code
> (4234389!square)
\end_layout

\begin_layout Standard
We would get an error.
 There is a big difference between 
\emph on
4234389 (!square)
\emph default
 and 
\emph on
(4234389!square)
\emph default
.
 In the first case we are creating an environment around the Bignum 
\emph on
4234389
\emph default
, then we execute the function bound to the dynamic variable 
\emph on
!square
\emph default
 from Bignum.
 In the second however, we are getting the Bignum's 
\emph on
!square
\emph default
 function but then applying it in the context of the caller.
 This is most likely not what was intended.
 In general methods should always be called in the first way as in:
\end_layout

\begin_layout LyX-Code
<object> (<method> <arg1> <arg2> ...
 <argn>)
\end_layout

\begin_layout Standard
Or if there are multiple method calls to be made:
\end_layout

\begin_layout LyX-Code
<object>
\end_layout

\begin_layout LyX-Code
     <method> <arg1> <arg2> ...
 <argn>
\end_layout

\begin_layout LyX-Code
     <method> <arg1> <arg2> ...
 <argn>
\end_layout

\begin_layout LyX-Code
     etc...
\end_layout

\begin_layout Subsection
Defining Your Own Classes 
\end_layout

\begin_layout Standard
Classes are relatively complex objects so the language provides an in-built
 macro for creating new classes and binding them.
 The syntax is straight forward - let's define a class for length units:
\end_layout

\begin_layout LyX-Code
> 
\series bold
class
\series default
 Inches()
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
<class Inches (Thing) ()> ; StandardClass Dictionary
\end_layout

\begin_layout Standard
This simply creates a class which is a subclass of
\emph on
 Thing
\emph default
.
 By convention class names begin with an upper-case character.
 We can use this class to annotate existing objects.
 For example:
\end_layout

\begin_layout LyX-Code
> 
\series bold
tag
\series default
 Inches 12
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 12 ; Inches Bignum
\end_layout

\begin_layout Standard
The 
\emph on
tag
\emph default
 function adds a class to an object's list of classes and returns it.
 Notice the interpreter prints out the list of classes 12 belongs to, now
 including 
\emph on
Inches
\emph default
.
 
\end_layout

\begin_layout Standard
So far so good, now let's add a method to convert to meters.
 Lets assume an 
\emph on
Inches
\emph default
 object is a kind of 
\emph on
Bignum
\emph default
, and add a method to it:
\end_layout

\begin_layout LyX-Code
class Inches(
\series bold
Bignum
\series default
)
\end_layout

\begin_layout LyX-Code
   def !toMeters()
\end_layout

\begin_layout LyX-Code
      * !self 0.0254
\end_layout

\begin_layout Standard
The second parameter to 
\emph on
class 
\emph default
a list of superclasses, in this example, just 
\emph on
Bignum
\emph default
.
 We can now define a foot and convert it as follows:
\end_layout

\begin_layout LyX-Code
define a-foot
\end_layout

\begin_layout LyX-Code
   tag Inches 12
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
> a-foot (
\series bold
!toMeters
\series default
)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 0.3048 ; Bignum
\end_layout

\begin_layout Standard
This is fine, but we are only returning a 
\emph on
Bignum
\emph default
.
 Let's refactor to add a 
\emph on
Meters
\emph default
 class and tag the return appropriately:
\end_layout

\begin_layout LyX-Code

\series bold
class Length()
\end_layout

\begin_layout LyX-Code

\series bold
   def !toMeters()
\end_layout

\begin_layout LyX-Code

\series bold
      raise "Oops - you invoked an abstract class!"
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
class Inches(
\series bold
Length
\series default
)
\end_layout

\begin_layout LyX-Code
   def !toMeters()
\end_layout

\begin_layout LyX-Code
      tag Meters (* !self 0.0254) 
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code

\series bold
class Meters(Length)
\end_layout

\begin_layout LyX-Code

\series bold
   def !toMeters() !self
\end_layout

\begin_layout Standard
Here we have defined an abstract base class and two derived classes which
 both have the !
\emph on
toMeters
\emph default
 method.
 The 
\emph on
raise
\emph default
 function catches invalid use of the 
\emph on
Length
\emph default
 class.
 Lets try the conversion again:
\end_layout

\begin_layout LyX-Code
> 
\series bold
(tag Inches 12)
\series default
 (!toMeters)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 0.3048 ; 
\series bold
Meters
\series default
 Bignum 
\end_layout

\begin_layout Standard
Here we are using a sub-expression which returns 
\emph on
12
\emph default
 
\emph on
Inches
\emph default
 and this object is the focus of the call to 
\emph on
!toMeters
\emph default
.
 With this new class structure in place we can now add a method to add two
 lengths in any units:
\end_layout

\begin_layout LyX-Code
Length
\end_layout

\begin_layout LyX-Code
   
\series bold
def !add(other)
\end_layout

\begin_layout LyX-Code

\series bold
      tag Meters
\end_layout

\begin_layout LyX-Code

\series bold
         + (!toMeters)
\end_layout

\begin_layout LyX-Code

\series bold
            other (!toMeters)
\end_layout

\begin_layout Standard
This method converts both the current object and the argument to 
\emph on
Meters,
\emph default
 performs the addition and returns the result in 
\emph on
Meters
\emph default
.
 Here's how it runs:
\end_layout

\begin_layout LyX-Code
define a-meter
\end_layout

\begin_layout LyX-Code
   tag Meters 1
\end_layout

\begin_layout LyX-Code
define a-foot (tag Inches 12)
\end_layout

\begin_layout LyX-Code
> a-foot (!add a-meter)
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ 1.3048 ; 
\series bold
Meters
\series default
 Bignum
\end_layout

\begin_layout Standard
This is useful however in the above example a user of our classes could
 get errors by tagging objects which cannot be added together.
 For example a string will fail:
\end_layout

\begin_layout LyX-Code
(tag 
\series bold
Inches "12"
\series default
) (!add (tag Meters 1))          ; Error
\end_layout

\begin_layout Standard
To provide protection and we use type checking features class validators.
\end_layout

\begin_layout Subsection
Inheritance and Class Slots
\end_layout

\begin_layout Standard
The inheritance mechanism in Genyris works by searching on object's classes
 list for classes which have the dynamic symbol required, it also recursively
 searches the superclasses of all the classes it finds in the classes list.
 The classes are ordered with those classes deepest in the hierarchy first.
 
\begin_inset Foot
status open

\begin_layout Standard
This order is listed when the classes are printed by the command-line interprete
r.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
This inheritance of slots is the same regardless of the type of slot (method
 or data).
 Hence an object can access information stored in it's classes and superclasses.
 Here's a simple example where a base class supplies a simple boolean value
 to an object:
\end_layout

\begin_layout LyX-Code
class Orange()
\end_layout

\begin_layout LyX-Code
   define !pips 'true
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
> (tag Orange "my lunch") !pips
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
~ true ; Symbol 
\end_layout

\begin_layout Subsection
Class Validators
\end_layout

\begin_layout Standard
To help define membership of a class, the class can provide a 
\emph on
!valid?
\emph default
 predicate method.
 This can assess an object and return 
\emph on
true
\emph default
 if it is a valid member of the class.
 The 
\emph on
tag
\emph default
 function calls 
\emph on
!valid?
\emph default
 if provided and fails when 
\emph on
!valid?
\emph default
 returns 
\emph on
nil
\emph default
.
 We can add a validator to our example base class:
\end_layout

\begin_layout LyX-Code
Length
\end_layout

\begin_layout LyX-Code
   
\series bold
def !valid?(obj)
\end_layout

\begin_layout LyX-Code

\series bold
      is-instance? obj Bignum
\end_layout

\begin_layout Standard
The 
\emph on
is-instance?
\emph default
 function only returns true if the object is an instance of 
\emph on
Bignum
\emph default
 or its subclasses.
 This prevents anything except numbers being tagged.
 
\end_layout

\begin_layout Subsection
Traditional Constructors and Factories
\end_layout

\begin_layout Standard
While the philosophy of Genyris is to classify objects after construction,
 it does not inhibit using traditional constructors in classes.
 It is good practice to prefer 'factory' functions for object construction
 even in traditional languages.
 Factory functions are simply functions which construct the appropriate
 kind of object based on the inputs given.
 A factory/constructor can be as simple as this:
\end_layout

\begin_layout LyX-Code
class Person ()
\end_layout

\begin_layout LyX-Code
   def !new (name date-of-birth)
\end_layout

\begin_layout LyX-Code
      dict
\end_layout

\begin_layout LyX-Code
         !name : name
\end_layout

\begin_layout LyX-Code
         !dob : date-of-birth
\end_layout

\begin_layout LyX-Code
         !classes : (list Person)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(Person!new) "Jo" 23
\end_layout

\begin_layout Standard
A more general approach is to provide a 
\begin_inset Quotes eld
\end_inset

new
\begin_inset Quotes erd
\end_inset

 function which calls a class-specific 
\begin_inset Quotes eld
\end_inset

init
\begin_inset Quotes erd
\end_inset

 function.
 For example here is a class with an 
\emph on
!init
\emph default
 member which creates slots in a dict created by 
\emph on
!new
\emph default
:
\end_layout

\begin_layout LyX-Code
class PersonTraditional (Object)
\end_layout

\begin_layout LyX-Code
   def !init((name:String) (age: Bignum))
\end_layout

\begin_layout LyX-Code
      define !name name
\end_layout

\begin_layout LyX-Code
      define !age age
\end_layout

\begin_layout Standard

\emph on
Objects
\emph default
 are created by calling 
\emph on
!new
\emph default
: 
\end_layout

\begin_layout LyX-Code
> PersonTraditional (!new "Abe" 99)
\end_layout

\begin_layout LyX-Code
dict
\end_layout

\begin_layout LyX-Code
      !age : 99
\end_layout

\begin_layout LyX-Code
      !name : "Abe" ; PersonTraditional Dictionary
\end_layout

\begin_layout Standard
Here is a simple implementation of 
\emph on
!new
\emph default
 in the base class:
\end_layout

\begin_layout LyX-Code
class Object (Dictionary)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  def !new(&rest args)
\end_layout

\begin_layout LyX-Code
      (tag !self (dict))                     
\end_layout

\begin_layout LyX-Code
         apply !init args
\end_layout

\begin_layout LyX-Code
         !self
\end_layout

\begin_layout LyX-Code
   
\end_layout

\begin_layout LyX-Code
  def !init(args)                           ; null !init method
\end_layout

\begin_layout LyX-Code
      !self
\end_layout

\begin_layout Standard
This 
\emph on
!new
\emph default
 collects all the input arguments via the 
\emph on
&rest
\emph default
 keyword, it creates an empty 
\emph on
dict
\emph default
, tags it with the derived class and passes the collected arguments to the
 classes 
\emph on
!init
\emph default
 function.
 The default 
\emph on
!init
\emph default
 function returns the new object un-modified.
\end_layout

\begin_layout Subsection
Automating Classification
\end_layout

\begin_layout Standard
This language embodies the opinion that objects are created first, then
 they are classified - rather than the classification being determined during
 object construction.
 Let's explore how the 
\emph on
!valid?
\emph default
 predicates can be used to automate classification.
 
\end_layout

\begin_layout Standard
Validator functions can be developed to any complexity required.
 For example validators can inspect the 
\bar under
values
\bar default
 of slots and objects rather than just their type.
 Here's an example which is 
\emph on
true
\emph default
 for even numbers:
\end_layout

\begin_layout LyX-Code
class EvenNumber()
\end_layout

\begin_layout LyX-Code
  
\series bold
def !valid?(x)
\end_layout

\begin_layout LyX-Code

\series bold
      equal? (% x 2) 0
\end_layout

\begin_layout Standard
Validators provide a way to automatically categorize unknown objects - an
 important tool for input validation.
\end_layout

\begin_layout Standard
The Genyris distribution includes file "examples/classify.lin" which shows
 this pattern.
 It defines a simple 
\emph on
classify
\emph default
 function which recursively walks the class hierarchy testing an object's
 compliance with validators.
 It is an example of classification of people into classes based on age
 and possessions.
 First we load the source files 
\begin_inset Foot
status open

\begin_layout Standard
The 
\emph on
load
\emph default
 function reads an executes the source file from the Java classpath.
 Genyris source files are stored within the Java 
\begin_inset Quotes eld
\end_inset

jar
\begin_inset Quotes erd
\end_inset

 file including some initialization code and a handful of examples.
\end_layout

\end_inset

:
\end_layout

\begin_layout LyX-Code

\series bold
load
\series default
 "examples/people.lin"
\end_layout

\begin_layout Standard
Next we create an un-classified object, assign it to a variable 
\emph on
kevin
\emph default
, and call 
\emph on
classify
\emph default
, and disply the object:
\end_layout

\begin_layout LyX-Code
define kevin
\end_layout

\begin_layout LyX-Code
  dict
\end_layout

\begin_layout LyX-Code
     !name: "Kevin"
\end_layout

\begin_layout LyX-Code
     !age: 49
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code

\series bold
> classify Person kevin
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
> kevin
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
dict
\end_layout

\begin_layout LyX-Code
      !age : 49
\end_layout

\begin_layout LyX-Code
      !name : "Kevin" ; Boomer Dictionary
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
The resulting printout shows the classifyer has recognised 
\emph on
kevin
\emph default
 as a 
\emph on
Boomer
\emph default
.
 Here are the classes:
\end_layout

\begin_layout LyX-Code
class Person ()
\end_layout

\begin_layout LyX-Code
   def !valid? (obj)
\end_layout

\begin_layout LyX-Code
      obj
\end_layout

\begin_layout LyX-Code
         bound? !age
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
class Boomer (Person)
\end_layout

\begin_layout LyX-Code
   
\series bold
def !valid? (obj)
\end_layout

\begin_layout LyX-Code
      
\series bold
obj  
\series default
                        
\end_layout

\begin_layout LyX-Code
        
\series bold
 between 45 !age 60   
\series default
   
\end_layout

\begin_layout Standard
To be a valid 
\emph on
Person
\emph default
 kevin must have an the 
\emph on
!age
\emph default
 property, and to be a Boomer it's value must be between 45 and 60.
 The 
\emph on
classify
\emph default
 function only calls the derived class's validator if object is in the base
 class.
 
\end_layout

\begin_layout Standard
This technique can be used to categorise a program's inputs or validate
 output data, and even re-validate previously classified objects.
\end_layout

\begin_layout Subsection
Ducks and Interfaces
\end_layout

\begin_layout Standard
'Duck' typing in a language is jargon for 'structural' subtyping - 
\emph on
If it looks like a duck and quacks like a duck - then it is a duck
\emph default
.
 Duck typing relies on a programmers to ensure that objects passed around
 actually do have the properties and methods expected by the downstream
 code.
 If there is a mis-match then eventually an error will result.
 For example if we could define a 
\emph on
!copy
\emph default
 function which expects some kind of stream object with 
\emph on
!next
\emph default
 and 
\emph on
!last? 
\emph default
methods.
 There is no need to perform type-checking in the interface since if the
 methods exits all will be well.
 Duck typing is perfectly adequate for most programming tasks, however some
 developers like to formalize the interfaces.
 
\end_layout

\begin_layout Standard
In Genyris an Interface could be defined by
\emph on
 
\emph default
either providing an appropriate validator or by simply tagging objects with
 their supported interface classes.
 For example here is a class validator for the above scenario:
\end_layout

\begin_layout LyX-Code
class Stream-Interface()
\end_layout

\begin_layout LyX-Code
   def !valid?(object)
\end_layout

\begin_layout LyX-Code
      object
\end_layout

\begin_layout LyX-Code
         and
\end_layout

\begin_layout LyX-Code
            bound? !next
\end_layout

\begin_layout LyX-Code
            is-instance? !next Closure
\end_layout

\begin_layout LyX-Code
            bound? !last
\end_layout

\begin_layout LyX-Code
            is-instance? !last Closure 
\end_layout

\begin_layout Standard
The validator here checks whether the object has 
\emph on
!next
\emph default
 and 
\emph on
!last
\emph default
 slots, and whether they are function closures.
 This type of validator could be implemented in a meta-class for the interface
 since this check can be performed on 
\bar under
classes 
\bar default
rather than instances.
 
\end_layout

\begin_layout Standard
A simple nominative approach could be used to designate a non-validating
 'semantic' class for the interface and tag the objects which allegedly
 met the requirements.
 For example:
\end_layout

\begin_layout LyX-Code
@prefix streams "http://myproject.org/inteterfaces/2008/streams/"
\end_layout

\begin_layout LyX-Code
class streams.IStream()
\end_layout

\begin_layout LyX-Code
'streams.method
\end_layout

\begin_layout LyX-Code
   var !dc.Description "A stream method"
\end_layout

\begin_layout LyX-Code
   var !rdf.Type 'genyris.Method
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
; Usage in another file
\end_layout

\begin_layout LyX-Code
@prefix streams "http://myproject.org/inteterfaces/2008/streams/"
\end_layout

\begin_layout LyX-Code
class MyStream(streams.IStream)            ; it's an streams.IStream - honest!
\end_layout

\begin_layout LyX-Code
   def !streams.method() 
\end_layout

\begin_layout LyX-Code
       etc ...
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
tag MyStream some-object 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def someFunction((input: streams.IStream))
\end_layout

\begin_layout LyX-Code
    etc ...
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
some-function some-object
\end_layout

\begin_layout Standard
An IStream class is defined and the base symbols declares meta-data describing
 the interface, possibly including RDF ranges and domains.
 A user then tags an object with a derived class, the tagger needs to be
 honest to ensure the interface is actually present in the tagged objects.
 Users of the objects can type-check based on the base class 
\emph on
streams.IStream
\emph default
.
\end_layout

\begin_layout Section
Semantics and The Secret Life of Symbols
\end_layout

\begin_layout Standard
As you my have deduced by now, symbols in Genyris are also Dictionaries
 and can hence have associated bound slots.
 For example our 
\emph on
file
\emph default
 module might contain the symbol 
\emph on
genyris:/files/ 
\emph default
(aka 
\emph on
file.
\emph default
) with some attached meta-data :
\end_layout

\begin_layout LyX-Code
@prefix file "genyris:/files/"
\end_layout

\begin_layout LyX-Code
'file.
\end_layout

\begin_layout LyX-Code
    var !name    "File Handling Functions"
\end_layout

\begin_layout LyX-Code
    var !version "1.2"
\end_layout

\begin_layout Standard
The symbol's slots can be accessed as usual:
\end_layout

\begin_layout LyX-Code
display ('file.!version)
\end_layout

\begin_layout Standard
Because symbols have slots, and slots can have prefixes, we can use symbols
 to define the semantics of programs.
 The additional meta-data required for semantics are added to the symbols.
 Properties (in the RDF use of the term) can be defined.
 Here is a fragment of code which creates a Dictionary containing facts
 about a Wikipedia article:
\end_layout

\begin_layout LyX-Code
@prefix rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
\end_layout

\begin_layout LyX-Code
@prefix dc "http://purl.org/dc/elements/1.1/"
\end_layout

\begin_layout LyX-Code
dict
\end_layout

\begin_layout LyX-Code
   !rdf.about    : "http-//en.wikipedia.org/wiki/Tony-Benn"
\end_layout

\begin_layout LyX-Code
   !dc.Title     : "Tony Benn"
\end_layout

\begin_layout LyX-Code
   !dc.Publisher : "Wikipedia"
\end_layout

\begin_layout Standard
Note that the properties of the dictionary are defined by globally published
 RDF URIs.
 Here we are invoking the Dublin Core meta-data and the RDF definitions.
 This allows the programmer to unambiguiously identify the properties of
 an object.
 By using the meta-data (such as Domain and Range) associated with symbol
 properties the programmer can write software to make deductions about the
 correctness of the program data, or other higher-level goals.
\end_layout

\begin_layout Section
Builtin Class Libraries
\end_layout

\begin_layout Standard
A major goal of the Genyris language is to encourage re-use and generic
 programming.
 The language separates the concerns, form and function, allowing developers
 to of three kinds of class libraries:
\end_layout

\begin_layout Enumerate
Built-in class libraries
\end_layout

\begin_layout Enumerate
Taxonomies of class types and validation functions assembled into class
 hierarchies useful for automatic triage of objects.
\end_layout

\begin_layout Enumerate
Traditional executable code libraries containing functions for manipulating
 objects of known classes and implementing significant functionality.
\end_layout

\begin_layout Subsection
Input and Output
\end_layout

\begin_layout Subsubsection
Global Output Functions
\end_layout

\begin_layout Paragraph
print<arg1>...<argn>
\end_layout

\begin_layout Standard
Outputs its arguments to the current standard output stream as if typed
 in by a user in indented format.
 - strings are quoted, escape characters are output.
 Arguments on the output are seperated by a newline.
 Example:
\end_layout

\begin_layout LyX-Code
print '(1 "w
\backslash
n" (x y))
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
1 "w
\backslash
n"
\end_layout

\begin_layout LyX-Code
   x y  
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Paragraph
write<arg1>...<argn>
\end_layout

\begin_layout Standard
Outputs its arguments to the current standard output stream without parenthesis
 syntax.
 - strings are quoted, escape characters are output.
 Arguments are output sequentially without space padding.
 Example:
\end_layout

\begin_layout LyX-Code
write '(1 2 (e) "w")
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(1 2 (e) "w")
\end_layout

\begin_layout Paragraph
display<arg1>...<argn>
\end_layout

\begin_layout Standard
Outputs its arguments to the current standard output stream without syntax.
 - strings are not quoted, escape characters are not output.
 Arguments are output sequentially without padding.
 Example:
\end_layout

\begin_layout LyX-Code
display '(1 "w
\backslash
n" (x y))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
(1 w
\end_layout

\begin_layout LyX-Code
 (x y))
\end_layout

\begin_layout Subsubsection
Global Input Functions
\end_layout

\begin_layout Paragraph
read
\end_layout

\begin_layout Subsubsection
Class Writer
\end_layout

\begin_layout Standard
A class which accepts a stream of characters.
\end_layout

\begin_layout Paragraph
Methods
\end_layout

\begin_layout Description
!close() Closes the current output stream.
\end_layout

\begin_layout Description
!flush() Forces all buffered output to be written to the device.
\end_layout

\begin_layout Description
!format(<format-string><arg1>...<argn>) Outputs the args as dictated by the
 format-string.
 The format string is a normal string with the special format sequences.
 Each format sequence must be matched by a corresponding argument to format,
 used in order.
 
\end_layout

\begin_deeper
\begin_layout Description
~a Outputs the argument without syntax - strings are unquoted, escape characters
 are not output
\end_layout

\begin_layout Description
~s Outputs the argument using if entered by a user - strings are quoted,
 escape characters are not output
\end_layout

\begin_layout Description
~x Outputs the argument as XML using an XmlWriter
\end_layout

\begin_layout Description
~% Outputs a linefeed
\end_layout

\begin_layout Description
~~ Outputs a tilde character
\end_layout

\begin_layout Standard
Example:
\end_layout

\end_deeper
\begin_layout LyX-Code
stdout(!format "~s ~a ~x ~%" "Hello" "World" '(img ((width: 23))))
\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
"Hello" World <img width="23"/>
\end_layout

\begin_layout Paragraph
Globals
\end_layout

\begin_layout Description
stdout A global variable which holds a 
\emph on
Writer
\emph default
 pointing the current Standard output device, typically the console.
\end_layout

\begin_layout Subsubsection
Class Reader
\end_layout

\begin_layout Paragraph
Globals
\end_layout

\begin_layout Description
stdin A global variable which holds a 
\emph on
Reader
\emph default
 pointing the current Standard Input device, typically the console.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Subsection
Standard Class Libraries
\end_layout

\begin_layout Standard
Genyris will provide a number of standard libraries for commonly required
 subject areas.
 
\end_layout

\begin_layout Subsubsection*
List Processing Classes
\end_layout

\begin_layout Standard
Genyris imports many types and functions inherited from Lisp and Scheme.
 These include:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
List Traditional Lisp/Scheme list processing with functions such as:
\end_layout

\begin_deeper
\begin_layout List
\labelwidthstring 00.00.0000

\emph on
!length
\emph default
 Count number of items in a list.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\emph on
!reverse
\emph default
 Reverse a list.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\emph on
!mapleft 
\emph default
Apply a function closure to every element in a list
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000

\emph on
!remove
\emph default
 Remove elements from a list satisfying a predicate.
\end_layout

\end_deeper
\begin_layout List
\labelwidthstring 00.00.0000
Assoc Association Lists
\end_layout

\begin_layout Subsubsection*
Input/Output
\end_layout

\begin_layout Standard
Classes including:
\end_layout

\begin_layout Itemize
File
\end_layout

\begin_layout Itemize
Stream
\end_layout

\begin_layout Itemize
Socket
\end_layout

\begin_layout Subsubsection*
Tabular Data Types
\end_layout

\begin_layout Standard
Support for file types commonly occurring in everyday computer use, typically
 arranged in tables or records:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
CSV Comma-Separated Value files
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
Recordset SQL Databases
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
Tables Rectangular tables of atomic types.
\end_layout

\begin_layout Subsubsection*
Utility Types
\end_layout

\begin_layout Itemize
Date and Time
\end_layout

\begin_layout Subsubsection*
Java Integration
\end_layout

\begin_layout Itemize
Java Beans
\end_layout

\begin_layout Itemize
Java Class execution
\end_layout

\end_inset


\end_layout

\end_body
\end_document
