%% LyX 1.5.1 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[a4paper,english]{article}
\usepackage[latin9]{inputenc}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{array}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{color}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}
%% The greyedout annotation environment
\newenvironment{lyxgreyedout}{\textcolor[gray]{0.8}\bgroup}{\egroup}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newenvironment{lyxcode}
{\begin{list}{}{
\setlength{\rightmargin}{\leftmargin}
\setlength{\listparindent}{0pt}% needed for AMS classes
\raggedright
\setlength{\itemsep}{0pt}
\setlength{\parsep}{0pt}
\normalfont\ttfamily}%
 \item[]}
{\end{list}}

\usepackage{babel}
\makeatother

\begin{document}

\title{Genyris Language Tutorial}


\author{Bill Birch}

\maketitle
\noindent \begin{center}
birchb@genyris.org
\par\end{center}

\begin{abstract}
This document provides an introduction to programming in the Genyris
language. The language is a derivative of Lisp with a mostly parenthesis-free
syntax yet retaining infix notation. It supports generic programming
through macros and object-orientation. It offers a style of object-orientation
where all objects have many classes and where classes are assigned
to objects after construction.
\end{abstract}
\newpage{}

\tableofcontents{}


\paragraph*{Conventions used in this tutorial:}

\begin{lyxlist}{00.00.0000}
\item [{\emph{italicized}}] Snippets of Genyris programs
\item [{\texttt{fixed-font}}] Larger programs are in a fixed font. Interactive
sessions are show with the \texttt{>} prompt of the command-line interpreter
and the results printed underneath.
\item [{%
\begin{lyxgreyedout}
Grey~text indicates a feature is not yet implemented.
\end{lyxgreyedout}
}]~
\end{lyxlist}
\newpage{}


\section{Getting Started}


\subsection*{Installation}

Genyris is available as a binary executable Java \emph{jar} file.
You don't need to understand Java to use Genyris. You will need the
Java 1.5 JRE or later to run the Genyris interpreter. Java can be
downloaded from Sun Microsystems. Check with your JRE version with
this command:

\begin{lyxcode}
\$~\textbf{java~-version}
\end{lyxcode}
Start the Genyris command-line interpreter with this command: 

\begin{lyxcode}
\$~\textbf{java~-jar~genyris-bin-nnn-xxxxxxxxx.jar}
\end{lyxcode}
Where \emph{nnn-xxxxxxxxx} is the version number. You will see a prompt
indicating the interpreter is ready for your input:

\begin{lyxcode}
{*}{*}{*}~Genyris~is~listening...

>
\end{lyxcode}

\subsection*{Executing Expressions}

Genyris commands can now be typed at the prompt, use two carriage
returns ($\hookleftarrow$) to terminate a statement. For example
to add two numbers type:

\begin{lyxcode}
>~\textbf{+~42~37~$\hookleftarrow$}

\textbf{$\hookleftarrow$}
\end{lyxcode}
Genyris responds with the answer and a comment about the result:

\begin{lyxcode}
\textasciitilde{}~79~;~Bignum
\end{lyxcode}

\subsection*{Verifying the Install}

To test the installation run the self test suite with the following
command:

\begin{lyxcode}
>~\textbf{load~\char`\"{}testscripts/testsuite.lin\char`\"{}$\hookleftarrow$}

\textbf{$\hookleftarrow$}
\end{lyxcode}
All being well, it will print {}``OK'' and the number of tests passed.


\subsection*{Running Examples}

The release binary file includes some examples which can be extracted
as follows:

\begin{lyxcode}
\$~\textbf{jar~xvf~{*}.jar~examples}~
\end{lyxcode}
This creates a directory called \emph{{}``examples}'' with a number
of {}``.lin'' files. The files can be edited with your favourite
text editor and run with the \emph{include} function. For example,
to load an run the {}``Eight Queens'' example do:

\begin{lyxcode}
>~\textbf{include~\char`\"{}examples/queens.lin\char`\"{}}

~

\textasciitilde{}~\char`\"{}file:/home/birchb/workspace/Genyris/examples/queens.lin\char`\"{}~;~String~

>~\textbf{queens~8}
\end{lyxcode}

\section{Syntax}

The syntax of Genyris uses indentation to convey program structure.
This is in common with other languages such as Python. However Genyris
preserves the {}``prefix'' notation of Lisp and Scheme. Here is
an example of some code defining a function:

\begin{lyxcode}
def~threat~(i~j~a~b)

~~~or

~~~~~~=~i~a

~~~~~~=~j~b

~~~~~~=~(-~i~j)~(-~a~b)

~~~~~~=~(+~i~j)~(+~a~b)
\end{lyxcode}
Instead of curly braces or \emph{begin} and \emph{end} tokens, the
indentation defines the blocks of code. Genyris reads lines one-by-one
until it reaches the end of an expression. An expression ends when
there are no more indented lines. The interactive command-line ends
an expression whenever two blank lines are read. Within a line, tokens
are separated by white-space. Genyris recognizes the following tokens:

\begin{itemize}
\item Comments
\item Numbers
\item Strings
\item Symbols
\item Sub-expressions
\item List Pairs
\end{itemize}

\subsection{Comments}

All characters following a semi-colon until the end of the line are
ignored by the parser. For example:

\begin{lyxcode}
\textbf{;~mark~the~number~24~as~a~member~of~class~'C'}

tag~24~C~~~~~~\textbf{;~=>~\textasciitilde{}~24~;~Bignum~C}


\end{lyxcode}

\subsection{Numbers}

Numbers can be either integers or floating point with any number of
leading or trailing digits%
\footnote{Java \emph{floats} and \emph{doubles} will be added%
}. Examples:

\begin{lyxcode}
-3~23.78~-100.0089
\end{lyxcode}

\subsection{Strings}

Strings are delimited by double quote characters \char`\"{}, within
a string quotes and special characters are escaped with backslash
\textbackslash{}. For example \texttt{\emph{She said \textbackslash{}\char`\"{}sea
shells\textbackslash{}\char`\"{}}} yields the string:

\noindent \begin{center}
\begin{tabular}{|c|}
\hline 
She said \char`\"{}sea shells\char`\"{}\tabularnewline
\hline
\end{tabular}
\par\end{center}

Other escape sequences are encoded as follows:

\noindent \begin{center}
\begin{tabular}{ll}
\texttt{\textbf{\textbackslash{}n}} & New Line\tabularnewline
\texttt{\textbf{\textbackslash{}r}} & Carriage Return\tabularnewline
\texttt{\textbf{\textbackslash{}f}} & Form Feed\tabularnewline
\texttt{\textbf{\textbackslash{}\textbackslash{}}} & Backslash\tabularnewline
\texttt{\textbf{\textbackslash{}t}} & Tab\tabularnewline
\texttt{\textbf{\textbackslash{}''}} & Quote\tabularnewline
\end{tabular}
\par\end{center}


\subsection{Symbols}

Symbols are a group of any printable characters with exceptions. Symbols
may start with a single underscore \_ but may not contain other underscores.
The following characters are not valid in symbols:

\noindent \begin{center}
\begin{tabular}{cc}
\texttt{\textbf{,}} & comma\tabularnewline
\texttt{\textbf{\_}} & underscore\tabularnewline
\texttt{\textbf{:}} & colon\tabularnewline
\texttt{\textbf{'}} & single quote\tabularnewline
\texttt{\textbf{\char`\"{}}} & double quote\tabularnewline
\texttt{\textbf{`}} & backquote\tabularnewline
\texttt{\textbf{@}} & at sign\tabularnewline
\end{tabular}
\par\end{center}

The following are all examples of valid symbols:

\begin{lyxcode}
Wednesday-12

\_age

{*}global{*}

+=

\$\{variable.name\}
\end{lyxcode}
In Genyris symbols are {}``interned'' by the parser so that there
is only ever one instance of a particular symbol. Symbols are Case
Sensitive so for example \emph{Kookaburra} and \emph{kookaburra} are
different symbols.


\subsection{Expressions and Sub-expressions}

All Genyris expressions are parsed and stored as linked-lists. A single
line is converted into a single list. Sub-expressions are denoted
in two ways, either within parentheses on a single line, or by an
indented line. For example the following line contains two sub-expressions:

\begin{lyxcode}
Alpha~(Beta~Charlie)~(Delta)
\end{lyxcode}
Sub-expressions made using parentheses must remain within a single
line, they are not permitted to wrap. Indented lines are deemed to
be sub-expressions of the superior, less indented lines above. The
above expression can be written in indented form as follows:

\begin{lyxcode}
Alpha

~~~Beta~Charlie

~~~Delta
\end{lyxcode}
Indentations must line up with previous indentations of the same level
as follows (spaces indicated with periods):

\begin{lyxcode}
Alpha

...Beta~Charlie

......Delta

...\textbf{Beta}~~~~~~~~~~~~~~;~correct~indentation
\end{lyxcode}
The parser is unable to cope with random indentation levels since
it does not know what depth is required. The following example will
generate an error:

\begin{lyxcode}
Alpha

...Beta~Charlie

......Delta

.....\textbf{Beta}~~~~~~~~~~~~~~;~ERROR
\end{lyxcode}

\subsection{Pairs}

Within Genyris lists are composed of pairs of references to objects%
\footnote{Lisp Cons cells%
}. Pairs have two elements, the left and right, which are references
to other Genyris objects. The left and right halves of a \emph{Pair}
can be delimited with the colon : character, an infix operator. For
example: 

\begin{lyxcode}
(1~:~2)~
\end{lyxcode}
denotes a \emph{Pair} referring to the numbers 1 and 2. Genyris expressions
are also composed of linked lists of\emph{ Pairs}, hence the expression:

\begin{lyxcode}
(A~B~C~D)
\end{lyxcode}
is shorthand for, and exactly the same as :

\begin{lyxcode}
(A~:~(B~:~(C~:~(D~:~nil))))
\end{lyxcode}
Lists are terminated with the special symbol \emph{nil}. An indented
expression can be expressed in terms of \emph{Pairs}. Consider:

\begin{lyxcode}
Alpha

~~~Beta
\end{lyxcode}
This is the same as 

\begin{lyxcode}
(Alpha~:~((Beta~:~nil)~:~nil))
\end{lyxcode}
Lists do not always have to be terminated with \emph{nil} , the colon
: operator can be used to squeeze one more object reference into the
end of the list. For example the following list has \emph{C} instead
of \emph{nil}:

\begin{lyxcode}
(A~B~:~C)~
\end{lyxcode}
new pairs can be created explicitly with the cons function. It takes
two parameters which become the left and right parts of a new pair.:

\begin{lyxcode}
>~cons~123~456

~

123~:~456~;~Pair
\end{lyxcode}

\subsection{Quoting and Special Parser Characters}

Lists and atoms can be quoted in Genyris. Quoting is used to prevent
execution of expressions. A single atom can be quoted within an expression%
\footnote{\emph{list} is a function we will cover later. %
}:

\begin{lyxcode}
~~~~~~list~1~2~\textbf{'a}~3~4~~~~;~evaluates~to:~(1~2~\textbf{a}~3~4)
\end{lyxcode}
Quote characters are a shorthand notation to save typing. When the
parser sees a single quote, it collects the following expression and
wraps it within a \emph{quote }expression. So \emph{'\textless{}exp\textgreater{}
}becomes \emph{(quote \textless{}exp\textgreater{}). }When the \emph{quote}
function is evaluated it does not evaluate its argument. So the above
expression is actually:

\begin{lyxcode}
~~~~~~list~~1~2~\textbf{(quote~a)}~3~4
\end{lyxcode}
Embedded lists can be quoted, in which case the embedded list is not
evaluated:

\begin{lyxcode}
~~~~~~func~1~2~\textbf{'(x~y~z)}~3~4
\end{lyxcode}
If the quote falls at the beginning of the line, only the first element
is quoted, not the entire line. So:

\begin{lyxcode}
~~~~~~list~1~2

~~~~~~~~~~\textbf{'x}~y~z
\end{lyxcode}
is the same as:

\begin{lyxcode}
~~~~~~list~1~2~(\textbf{(quote~x)}~y~z)
\end{lyxcode}
To allow entire sub-trees to be quoted, the quote function needs to
be used as in this example:

\begin{lyxcode}
~~~~~~list~1~2

~~~~~~~~~\textbf{quote}

~~~~~~~~~~~~x~y~z
\end{lyxcode}
which is the same as:

\begin{lyxcode}
~~~~~~list~1~2~\textbf{(quote~(x~y~z))}
\end{lyxcode}

\subsection{Line Continuation}

Sometimes long expressions become unwieldy and must be continued on
following lines. There are two mechanisms for this. This first and
simplest is to use the colon : operator and an indented line as follows:

\begin{lyxcode}
list~1~2~4~5~:~

\textbf{~~~6~7~8}
\end{lyxcode}
This is equivalent to: 

\begin{lyxcode}
list~1~2~4~5~\textbf{:~(6~7~8)}
\end{lyxcode}
which is the same as:

\begin{lyxcode}
list~1~2~4~5~\textbf{6~7~8}
\end{lyxcode}
The parser also has a special line continuation character (the tilde
\textasciitilde{}) which continues the previous line indentation level
at the start of the line under which it is placed. This allows arbitrary
continuations such as:

\begin{lyxcode}
quote

~~~1~2

~~~~~~3

~~~~~~\textbf{\textasciitilde{}~22~};~Pair
\end{lyxcode}
which is the same as:

\begin{lyxcode}
quote~'(1~2~(3)~\textbf{22})
\end{lyxcode}

\subsection{More Quote Characters}

Genyris also supports three other special syntactic quotes similar
to single quotes. They are all used to simplify writing macros with
the \emph{template }function, but can be used for anything else. These
are converted by the parser into expressions as follows:

\noindent \begin{center}
\begin{tabular}{cc}
\textbf{Input Quote Sequence} & \textbf{Translated Expression}\tabularnewline
,\textless{}exp\textgreater{} & (comma \textless{}exp\textgreater{})\tabularnewline
,@\textless{}exp\textgreater{} & (comma-at \textless{}exp\textgreater{})\tabularnewline
`\textless{}exp\textgreater{} & (template \textless{}exp\textgreater{})\tabularnewline
\end{tabular}
\par\end{center}

%
\begin{comment}
In a future version you will be able to call the parser in any environment
(not just the global one and hence bind the quote symbols to your
own values).
\end{comment}
{}


\section{Variables }

In any context you can create new variables with the \emph{defvar
}or \emph{define} functions. These functions also take an initial
value for the variable:

\begin{lyxcode}
define~name~\char`\"{}William\char`\"{}

defvar~'name~\char`\"{}William\char`\"{}
\end{lyxcode}
In both examples, the symbol \emph{name} is bound to the value \emph{{}``William''}
in the current environment. After the variable has been bound, its
value can be used in any expression in the scope. When the interpreter
sees a symbol in an argument list it looks for a binding in the current
environment and all parent environments right up to the global execution
environment. If you define a variable at the command line, it is bound
in the global execution environment and hence is available everywhere.
If you try to access a variable when there is no binding, an \char`\"{}unbound
variable\char`\"{} error will be reported.

Variable values can be updated with the \emph{set} or \emph{set!}
functions, for example:

\begin{lyxcode}
set~'name~\char`\"{}William~Pitt\char`\"{}

set!~name~\char`\"{}William~Pitt\char`\"{}
\end{lyxcode}
A predicate function \emph{bound?} is provided to test whether a symbol
has a binding in the current environments. It returns the symbol \emph{true}
if the variable is defined otherwise \emph{nil}. 


\section{Functions}

As we have seen, Genyris can execute statements immediately at the
command line. The expression:

\begin{lyxcode}
+~42~37
\end{lyxcode}
Yields the addition of the two numbers (77). Let's explore how this
works. The interpreter looks for list expressions and assumes the
first token (or sub-expression) is a procedure. The rest of the list
constitute the arguments to the procedure. In this case \emph{+} is
a symbol which yields a procedure object. The arguments are also evaluated
and the results are passed to the procedure to be evaluated. Lets
have a look at \emph{+} by getting its value:

\begin{lyxcode}
>~the~+

~

\textasciitilde{}~<org.genyris.math.PlusFunction>~;~EagerProcedure
\end{lyxcode}
The function \emph{the} is the identity function - it simply returns
the value of its argument. Since the symbol + is an argument to \emph{the,}
its value is the underlying procedure. A {}``Procedure'', or {}``Closure'',
is an object which keeps a reference to the environment in which it
was originally defined and the executable code to be run when called.
In addition it knows how its arguments are to be handled before the
executable code is run.


\subsection{Eager Functions}

Programmers are familiar with eager functions as it is the default
in most languages. Mathematical functions such as + - {*} and / are
eager functions. These evaluate their arguments prior to applying
the underlying procedure. Let's experiment with some simple math function
calls. All the following expressions evaluate to 12:

\begin{lyxcode}
+~6~6

+~({*}~2~3)~(+~2~4)

+~2~2~2~2~2~2
\end{lyxcode}
Notice that the + function can have many arguments. Another function
that takes multiple arguments is \emph{list}. This function constructs
a list from its arguments. Here's an example:

\begin{lyxcode}
>~list~({*}~34~8)~\char`\"{}pears\char`\"{}~(/~34~5)~\char`\"{}kilos\char`\"{}

~

272~\char`\"{}pears\char`\"{}~6.8~\char`\"{}kilos\char`\"{};~Pair
\end{lyxcode}
Note that the interpreter always prints a comment after the result.
This comment is the list of classes the result belongs to. Since \emph{list}
returns a list, which is composed of Pairs, \emph{{}``Pair} {}``is
printed. 


\subsection{Lazy Functions - Conditional Execution}

No language is complete without conditional functions. The \emph{cond}
function is a lazy function that allows program flow to change depending
on the outcome of conditional expressions. Here's the syntax of \emph{cond}: 

\begin{lyxcode}
~~~cond

~~~~~~(<condition~1>)

~~~~~~~~~<sequence~1>

~~~~~~(<condition~2>)

~~~~~~~~~<sequence~2>

~~~~~~...

~~~~~~(<condition~N>)

~~~~~~~~~<sequence~N>
\end{lyxcode}
Each condition is evaluated in turn until one returns which is not
\emph{nil}. The associated sequence is evaluated and the value of
the last expression in the sequence is returned. If there is no sequence,
the value of the condition is returned. Typically the last condition
is a non-nil constant and its sequence is the default. The symbol
\emph{else} is provided for this purpose. Here's an example: 

\begin{lyxcode}
~~~cond

~~~~~~(equal?~foo~1)

~~~~~~~~~\char`\"{}One\char`\"{}

~~~~~~(equal?~foo~2)

~~~~~~~~~\char`\"{}Two\char`\"{}

~~~~~~else

~~~~~~~~~\char`\"{}Other\char`\"{}

~~~~
\end{lyxcode}
The function \emph{equal?} returns \emph{true} if the two arguments
are the same otherwise \emph{nil}. So if the symbol \emph{foo} is
bound to the value 2 this expression will return \emph{\char`\"{}Two\char`\"{}}. 


\subsection{Defining Your Own Functions }

Functions in Genyris are defined in the usual way for functional programming
languages. The \emph{def} function binds a name to a lexical closure
containing the current environment and the code to be applied in future
calls. The body of the function is a sequence of expressions to be
executed in the lexical environment, the last expression's value is
returned. Here's a definition of the identity function:

\begin{lyxcode}
def~identity~(arg)~arg
\end{lyxcode}
Genyris has two kinds of user-defined functions 'eager' and 'lazy'.
An eager function evaluates its arguments before it applies them,
whereas a lazy function does not. Traditional functions such as '+'
and \emph{the} are eager. \emph{list} is an eager function which returns
all its arguments in a list. The \emph{quote} function is a lazy procedure
which returns its single argument un-evaluated. 

Here is a more complex function definition:

\begin{lyxcode}
def~factorial~(n)~

~~~if~(<~n~2)~1~

~~~~~~{*}~n~factorial~(-~n~1)
\end{lyxcode}
The \emph{if} function is lazy, since, depending on the value of the
first argument, it executes only one of its other two arguments .
In fact, \emph{if} is a macro - a special kind of lazy function which
we introduce later.


\subsection{Anonymous Functions with Lambda and Friends }

Actually the \emph{def} and \emph{defmacro} functions are lazy functions.
They bind a variable name to procedure compiled from the function
body. But what if we want a function without the binding? Genyris
provides three kinds of in-built procedure-building functions. The
function \emph{lambda} creates a user-defined eager procedure object
which is a closure at the point of definition. For example we can
create an anonymous function at the command-line:

\begin{lyxcode}
>~\textbf{lambda}~(x)~({*}~x~x)

~

\textasciitilde{}~<org.genyris.interp.ClassicFunction>~;~EagerProcedure~
\end{lyxcode}
To actually call it we place it wherever a function is expected, such
as a parameter to a function, or at the beginning of a list:

\begin{lyxcode}
>~\textbf{(lambda~(x)~({*}~x~x))}~3

~

\textasciitilde{}~9~;~Bignum
\end{lyxcode}
Notice the parentheses are required around the expression to trigger
the execution. The argument 3 is passed to the resulting closure.
Functions are 'first class' and can be assigned to variables, which
is how \emph{def} works. The following two expressions are equivalent:

\begin{lyxcode}
define~square

~~~lambda~(x)~({*}~x~x)~

~

def~square~(x)

~~~{*}~x~x~
\end{lyxcode}

\subsubsection{Anonymous Lazy Functions}

To defer evaluation, a lazy function can be defined using the \emph{lambdaq
or lambdam} macros. \emph{lambdaq} is just like \emph{lambda} except
it builds a lazy procedure, \emph{lambdam} builds anonymous macros.
The next example creates an anonymous function which prepends its
argument (without evaluation) to a list:

\begin{lyxcode}
>~(\textbf{lambdaq}~(x)~(list~x~\char`\"{}World\char`\"{}))~(+~\char`\"{}Hello\char`\"{})

~

(+~\char`\"{}Hello\char`\"{})~\char`\"{}World\char`\"{}~;~Pair


\end{lyxcode}

\subsection{Type-Checked Function Arguments}

Genyris supports the familiar type annotations found in most statically
typed languages. These type checks are purely optional. When a function
is defined, the arguments and return value may be annotated with a
class. The actual arguments are checked with a validator (if present).
Here's an example of a sensitive function protected by type checks:

\begin{lyxcode}
def~safe-call~((a~:~Bignum)~(b~:~Bignum)~:~Bignum)~

~~~~fragile-function~a~b~~~~
\end{lyxcode}
This function only allows Bignums to be passed in or returned. The
last element of the arguments list specifies the return type. If a
type check fails an exception is raised.


\subsection{In-Line Type Checks}

Genyris provides a simpler mechanism for ensuring type constraints
are followed. If the last element of an expression list is not \emph{nil},
but a class, it will check if the result of the expression is \emph{\_valid}?,
or if it is an instance of the class. For example this function will
always raise an error because\emph{ 3} is not a subclass of \emph{String}:

\begin{lyxcode}
def~fails()

~~~~define~x~3

~~~~x~:~String
\end{lyxcode}
If a class validator is provided, this will be used otherwise a simple
{}``nominative'' type check of class membership based on the object's
tagged classes is used. The \emph{\_valid?} method is a stronger check,
however nominative checking is sometimes preferred%
\footnote{Genyris supports both {}``nominative'' and {}``structural'' subtyping%
}.


\subsection{Defining Macros}

Macros are lazy functions which are very handy for extending the syntax
of the language and creating DSLs (Domain-Specific Languages). Macros
are lazy functions which re-evaluate the returned value in the environment
of the caller. Here's an example:

\begin{lyxcode}
defmacro~do(\&rest~body)

~~~cons~'lambda

~~~~~~cons~nil

~~~~~~~~cons~body~nil
\end{lyxcode}
This macro assembles a lambda expression using the argument list as
the body of the function. So when called with:

\begin{lyxcode}
do

~~~print~\char`\"{}Hello~World\char`\"{}
\end{lyxcode}
It creates this expression, which is then evaluated: 

\begin{lyxcode}
lambda~()

~~~print~\char`\"{}Hello~World\char`\"{}
\end{lyxcode}
Here is a more complex example - definition of a control flow function: 

\begin{lyxcode}
\textbf{defmacro}~my-if~(test~success-result~failure-result)

~~~\textbf{template}

~~~~~~cond

~~~~~~~~~,test~,success-result

~~~~~~~~~else~,failure-result
\end{lyxcode}
This macro uses the \emph{template} function and \emph{comma} to splice
the arguments into a formulaic expression. Here's an example if its
use:

\begin{lyxcode}
define~test~3~~~~~~~~~~~~~~~~~;~binding~in~the~caller's~environment

my-if~(equal?~test~3)~1~2~~~~~
\end{lyxcode}
This returns 1. Notice that the variable \emph{test} is defined in
the caller's environment used in the condition, not the binding of
the same name within \emph{my-if}. 


\subsection{Lexical Scoping Captures Environments}

Genyris is \char`\"{}lexically scoped\char`\"{} - when a function
is defined it remembers the environment in which it was defined and
re-uses that environment when it executes. This provides a way of
hiding data and giving functions stateful side effects. The following
example%
\footnote{refer to Abelson and Sussmans' book {}``Structure and Interpretation
of Computer Programs''%
} creates a function which captures the \emph{balance} variable:

\begin{lyxcode}
def~make-withdraw~(balance)~

~~~lambda~(amount)~

~~~~~~set!~balance~(-~balance~amount)



define~W1~(make-withdraw~100)

~

>~W1~25

W1~25

~

\textasciitilde{}~75~;~Bignum

\textasciitilde{}~50~;~Bignum
\end{lyxcode}
Repeated execution of the function \emph{W1} reduces the value of
the balance each time. The sequence of evaluation is as follows:

\begin{enumerate}
\item the lazy \emph{def} expression is executed which results in a procedure
object bound to the symbol \emph{make-withdraw}
\item the argument to the eager \emph{define} expression is evaluated which
results in a call to \emph{make-withdraw}
\item the eager \emph{make-withdraw }creates a new environment in which
it binds \emph{balance} to \emph{100}
\item the body of \emph{make-withdraw} is evaluated resulting in another
procedure object which captures a reference to \emph{balance }and
contains the executable code starting with \emph{set!}
\item the procedure object is bound to W1
\item \emph{W1} is called with the argument 25
\item the procedure object bound to \emph{W1} subtracts 25 from the \emph{balance}
binding in the\emph{ }environment created in step 3
\end{enumerate}
Note that there is no way to directly access the \emph{balance} variable. 


\section{Everything is Callable}

The Genyris evaluator expects the first element of a list to be some
kind of procedure object - something that can compute its arguments
and apply them. This is the role of traditional functions such as
\emph{+} or user-defined functions. In Genyris, \underbar{all} objects
are callable, even atomic types. For example an integer can be called
as a function thus:

\begin{lyxcode}
>~\textbf{12}~(+~33~44)~(-~4~3)

~

\textasciitilde{}~1~;~Bignum
\end{lyxcode}
Lets analyse what happened. The integer \emph{12} was called with
two argument \emph{(+ 33 44)} and \emph{(- 4 3)}. Since \emph{12}
is a lazy function it did not evaluate its arguments. Rather it treated
its arguments as a sequence of expressions to be evaluated in a new
environment. So it calculated 333 + 44 = 77, and then 4 -3 = 1. When
it reached this last expression it returned the value 1. This expression
can be written in indented form with the same result as follows:

\begin{lyxcode}
\textbf{12}~

~~~+~33~44

~~~-~4~3
\end{lyxcode}
If an atom is called with no arguments, it simply returns itself.
We can say they are {}``self-evaluating''. So at the command line
typing a number alone returns the number:

\begin{lyxcode}
>~1024



\textasciitilde{}~1024~;~Bignum
\end{lyxcode}
As well as executing the sequence of expressions, an execution environment
was created in which the number 12 is a bound to the dynamic variable
\emph{\_self}. The variable can be used as follows:

\begin{lyxcode}
>~12~(+~\textbf{\_self~\_self})~

~

\textasciitilde{}~24~;~Bignum
\end{lyxcode}
Here the number is added to itself. The environment can also be used
to create local bindings with the \emph{define} functions:

\begin{lyxcode}
12

~~\textbf{define~foo~987}

~~+~foo~\_self

~

\textasciitilde{}~999~;~Bignum~~
\end{lyxcode}
Callable atoms could be used to add simple code block keywords to
the langage. If a symbol is called as a function it is by default
evaluated to locate the binding in the current evironment. If we make
the value an atom, we can use the symbol as a a keyword. For example,
the symbol \emph{do} is defined like this:

\begin{lyxcode}
define~my-do~'my-do~
\end{lyxcode}
Now whenever w\texttt{henever we call }\texttt{\emph{my-do}}\texttt{
as a function, it acts as a code block which can be used in a function:}

\begin{lyxcode}
\textbf{def~my-function()}

\textbf{~~~my-do}

~~~~~~some-function~\char`\"{}Hi!\char`\"{}

~~~~~~define~a-variable~42

~~~~~~print~\_self
\end{lyxcode}
However within the context the do block of \emph{\_self }is bound
to \emph{my-do}. Hence the above function prints {}``my-do''. A
better way to add new syntax is to create a macro, since \emph{\_self}
is not affected. 

\begin{lyxcode}

\end{lyxcode}

\subsection{Dynamic Variables}

Generally 'dynamic' variables are those which are bound in the environment
of the caller and hence depend on who is evaluating the expression.
In Genyris dynamic variables are limited to being properties of the
currently called object, and called objects are part of their environment.
In other words when an object is used as a procedure, the environment
created to make the call is a merge of the object itself and a normal
lexical environment. All dynamic variables are prefixed with the underscore
\_ character\emph{.} An example will make this clearer:

The number 12 above has two dynamic variables, \emph{\_self} and \_\emph{classes}.
They can be accessed as follows:

\begin{lyxcode}
12~~~~cons~\_self~\_classes

~

12~<class~Bignum~(Builtin)~()>~;~Pair~
\end{lyxcode}
Here we see that the\emph{ \_classes} variable is referring to the
class list of \emph{12. }It has a single class, \emph{Bignum,} which
is printed. This behaviour is the same for the other atomic types:
Bignums, Pairs and Strings. Consider the following examples:

\begin{lyxcode}
>~\char`\"{}What~am~I?\char`\"{}~\_classes

~

<class~String~(Builtin)~()>~;~Pair
\end{lyxcode}
However where symbols are concerned, the evaluator always looks up
the value before use. So to show this with a symbol we must quote
it:

\begin{lyxcode}
>~'a-symbol~\_classes

~

<class~Symbol~(Builtin)~()>~;~Pair
\end{lyxcode}
Likewise the interpreter assumes a list is a normal function call
so a quote is needed to see this behaviour: 

\begin{lyxcode}
>~'(3)~\_classes



<class~Pair~(Builtin)~(PRINTWITHCOLON)>~;~Pair
\end{lyxcode}
The atomic types (at least today) have only a single dynamic variable,
richer examples lie in the compound object types.


\subsection{Working With Pairs and Lists}

Like its forbears Lisp and Scheme, Genyris is inherently a list-processing
language - its source code is expressed as lists and it has inbuilt
functions for parsing and manipulating list data. Since programs and
data are stored in the same form, Genyris is an ideal platform for
developing DSLs or even new programming languages. Happily, manipulating
lists is easy. Lists are a kind of {}``binary tree\char`\"{}. Trees
are constructed with the \emph{cons} function which accepts two arguments
for the left and right halves of the \emph{Pair}:

\begin{lyxcode}
>~\textbf{cons}~\char`\"{}A\char`\"{}~\char`\"{}B\char`\"{}



\char`\"{}A\char`\"{}~:~\char`\"{}B\char`\"{}~;~Pair
\end{lyxcode}
Note the interpreter prints a colon between the left and right halves
of the Pair. The individual elements of a Pair can be accessed with
the \emph{left} and \emph{right} functions:

\begin{lyxcode}
>~\textbf{left}~(cons~\char`\"{}A\char`\"{}~\char`\"{}B\char`\"{})



\textasciitilde{}~\char`\"{}A\char`\"{}~;~String
\end{lyxcode}
Alternatively the slot names \emph{\_left} and \emph{\_right} can
be used when the list is called:

\begin{lyxcode}
>~define~my-pair~(cons~\char`\"{}A\char`\"{}~\char`\"{}B\char`\"{})~

mypair~\_\textbf{right}



\textasciitilde{}~\char`\"{}B\char`\"{}~;~String

>~my-pair

~~~\textbf{set!~\_left~33}

~~~\_self

~

33~:~\char`\"{}B\char`\"{}~;~Pair
\end{lyxcode}
To construct a proper List, the final right hand element will be \emph{nil}:

\begin{lyxcode}
>~cons~\char`\"{}A\char`\"{}

~~~~cons~\char`\"{}B\char`\"{}

~~~~~~~cons~\char`\"{}C\char`\"{}~nil~



\char`\"{}A\char`\"{}~\char`\"{}B\char`\"{}~\char`\"{}C\char`\"{}~;~Pair
\end{lyxcode}
The printing of trees (by default) assumes that the tree is a kind
of list, hence you don't see the parentheses in this case. See how
the interpreter identified the list as a \emph{Pair}, since it only
has a reference to the first \emph{Pair}? 

To help view \emph{Pairs} explicitly, a list can be tagged with the
PRINTWITHCOLON class, which forces the printer to display the full
tree structure. The parser does this automatically, so Pairs which
the user types with a colon are printed the same way. For example:

\begin{lyxcode}
>~'(\char`\"{}A\char`\"{}~:~(\char`\"{}B\char`\"{}~:~(\char`\"{}C\char`\"{}~)))



\char`\"{}A\char`\"{}~:~(\char`\"{}B\char`\"{}~:~(\char`\"{}C\char`\"{}))~;~PRINTWITHCOLON~
\end{lyxcode}

\subsection{Dictionaries - Your Garden Variety Objects}

Genyris provides {}``dictionary'' objects which are {}``objects''
in the normally understood sense for programming languages. Each dictionary
provides a un-ordered set of dynamic symbols and bindings - called
{}``slots''. A dictionary is created with the \emph{dict} function
call, e.g.:

\begin{lyxcode}
define~pitt

~~\textbf{dict~}

\textbf{~~~~\_name~~:~\char`\"{}Willam~Pitt\char`\"{}}

\textbf{~~~~\_title~:~\char`\"{}Prime~Minister\char`\"{}}

\textbf{~~~~\_date-of-birth~~~:~\char`\"{}28~May~1759\char`\"{}}
\end{lyxcode}
Here we have created a \emph{dict} with three slots. The \emph{dict}
function takes a variable number of slot definitions in Pairs, more
formally: 

\begin{lyxcode}
~~dict

~~~~~<dynamic~symbol1>~:~<initial~value1>

~~~~~<dynamic~symbol2>~:~<initial~value2>

~~~~~etc...
\end{lyxcode}
If there are no initial values given , the symbol \emph{nil} is used
as the value as in this example:

\begin{lyxcode}
>~\textbf{dict}

\textbf{~~~\_foo}

\textbf{~~~\_bar}

~

dict

~~~~~~\_bar~:~nil

~~~~~~\_foo~:~nil~;~Dictionary~~~~~~
\end{lyxcode}
Having slots is all very well, but we need a way to access them. As
we have seen all objects are callable - including dictionaries. So
to access the above \emph{dict} object we call it and use the dynamic
variables as follows:

\begin{lyxcode}
>~pitt~\_name

~

\textasciitilde{}~\char`\"{}Willam~Pitt\char`\"{}~;~String
\end{lyxcode}
Here the \emph{\_name} dynamic variable is bound to the \emph{\_name}
slot in the dict. To set the slot value we use the \emph{set!} function:

\begin{lyxcode}
pitt

~~~\textbf{set!~}\_name~\char`\"{}William~Pitt~The~Younger\char`\"{}


\end{lyxcode}
New slots can be created with \emph{define} since the object acts
as an environment in its own right. e.g.:

\begin{lyxcode}
pitt~

~~~\textbf{define}~\_father~\char`\"{}William~Pitt~the~Elder\char`\"{}
\end{lyxcode}
Dictionaries also have a {}``magic'' variable \emph{\_vars} which
lists all the variables defined in the dictionary. This is handy for
debugging. For example:

\begin{lyxcode}
>~pitt~\textbf{\_vars}

~

\_date-of-birth~\_father~\_name~\_title~\_vars~;~Pair
\end{lyxcode}

\subsection{Adding Behaviour to Dictionaries}

Since functions in Genyris are simply bound to variables, and dictionaries
have variables, behaviour can be added to dictionaries. It suffices
to define a function with a dynamic name in the scope of a dictionary:

\begin{lyxcode}
define~jeb

~~\textbf{~dict}

\textbf{~~~~~~\_firstName:~\char`\"{}Joe\char`\"{}~}

\textbf{~~~~~~\_middleName:~\char`\"{}E.\char`\"{}}

\textbf{~~~~~~\_lastName:~\char`\"{}Brown\char`\"{}}

~

jeb~

~~~\textbf{def~\_displayName()}

\textbf{~~~~~~~list~\_firstName~\_middleName~\_lastName}
\end{lyxcode}
Once defined, the function is callable in the context of the \emph{jeb}
dict:

\begin{lyxcode}
>~jeb~\textbf{(\_displayName)}

~

\char`\"{}Joe\char`\"{}~\char`\"{}E.\char`\"{}~\char`\"{}Brown\char`\"{}~;~Pair
\end{lyxcode}
A dict can be used a mechanism for organisation. Consider the following
fictional example - a set of functions organised in a {}``module''
called \emph{file}:

\begin{lyxcode}
;;~File~Handling~Module

define~file

~~dict~

~~~~\_name~~:~\char`\"{}File~Handling~Functions\char`\"{}

~~~~\_version~:~\char`\"{}1.2\char`\"{}

file

~~~\textbf{def~\_copy(from~to)~...}

\textbf{~~~def~\_delete(filename)~...}

\textbf{~~~def~\_zip(file)~...}

~

;;~Use~of~the~file~module

def~archive(filename)

~~~~\textbf{(file\_copy)~filename~\char`\"{}/tmp/foo\char`\"{}}

\textbf{~~~~(file\_zip)~\char`\"{}/tmp/foo\char`\"{}}

\textbf{~~~~(file\_delete)~filename}


\end{lyxcode}
Here we define three functions bound to a single dict object. The
functions can only be called by referencing the \emph{file} object.
While it is handy to be able to add behaviour to objects, it does
not scale when there are many objects which require the same behaviour.
For this we need something more complex - Classes and Inheritance.


\section{Using Classes to Organise Behaviour}

All Genyris objects, be they atomic (like numbers) or composite (like
dictionaries) can belong to one or more classes. As such Genyris is
a fully {}``Object-Oriented'' language. The interpreter looks at
the classes for functions to execute if the function name is dynamic
(starts with an underscore). This way you can add behaviour to many
objects in a single place. Classes are dictionaries with special variables
which hold the relationships between classes. The standard classes
all have the following variables:

\begin{itemize}
\item \_classes 
\item \_vars 
\item \_classname 
\item \_superclasses
\item \_subclasses
\end{itemize}
Genyris has a number of built-in classes beginning with \emph{Thing},
root of the class hierarchy. Here is the builtin class hierarchy:

\begin{lyxcode}
Thing

~~~~Builtin

~~~~~~~~~~~~Bignum

~~~~~~~~~~~~String

~~~~~~~~~~~~Symbol

~~~~~~~~~~~~Pair

~~~~~~~~~~~~~~~~PRINTWITHCOLON

~~~~~~~~~~~~Dictionary

~~~~~~~~~~~~Closure

~~~~~~~~~~~~~~~~LazyProcedure

~~~~~~~~~~~~~~~~EagerProcedure


\end{lyxcode}
To add behaviour to a class, we need to add a dynamic variable bound
to a closure object - in other words we need to define a method. For
example a method to compute the square of a number be added to the
\emph{Bignum} class:

\begin{lyxcode}
Bignum

~~~def~\_square()~({*}~\textbf{\_self~\_self})
\end{lyxcode}
Notice that the method uses the \emph{\_self} variable which is automatically
bound to the object. Now all Bignums can compute their own square
e.g.:

\begin{lyxcode}
>~4234389~(\_square)

~

\textasciitilde{}~17930050203321~;~Bignum
\end{lyxcode}
We need to call methods in the correct way to ensure they refer to
the right object since they are dynamic, not lexical variables. So
if we tried to say:

\begin{lyxcode}
>~(4234389\_square)
\end{lyxcode}
We would get an error. There is a big difference between \emph{4234389
(\_square)} and \emph{(4234389\_square)}. In the first case we are
creating an environment around the Bignum \emph{4234389}, then we
execute the function bound to the dynamic variable \emph{\_square}
from Bignum. In the second however, we are getting the Bignum's \emph{\_square}
function but then applying it in the context of the caller. This is
most likely not what was intended. In general methods should always
be called in the first way as in:

\begin{lyxcode}
<object>~(<method>~<arg1>~<arg2>~...~<argn>)
\end{lyxcode}
Or if there are multiple method calls to be made:

\begin{lyxcode}
<object>

~~~~~<method>~<arg1>~<arg2>~...~<argn>

~~~~~<method>~<arg1>~<arg2>~...~<argn>

~~~~~etc...
\end{lyxcode}

\subsection{Defining Your Own Classes }

Classes are relatively complex objects so the language provides an
in-built macro for creating new classes and binding them. The syntax
is straight forward - let's define a class for length units:

\begin{lyxcode}
>~\textbf{class}~Inches()

~

<class~Inches~(Thing)~()>~;~StandardClass~Dictionary
\end{lyxcode}
This simply creates a class which is a subclass of\emph{ Thing}. By
convention class names begin with an upper-case character. We can
use this class to annotate existing objects. For example:

\begin{lyxcode}
>~\textbf{tag}~12~Inches

~

\textasciitilde{}~12~;~Inches~Bignum
\end{lyxcode}
The \emph{tag} function adds a class to an object's list of classes
and returns it. Notice the interpreter prints out the list of classes
12 belongs to, now including \emph{Inches}. 

So far so good, now let's add a method to convert to meters. Lets
assume an \emph{Inches} object is a kind of \emph{Bignum}, and add
a method to it:

\begin{lyxcode}
class~Inches(\textbf{Bignum})

~~~def~\_toMeters()

~~~~~~{*}~\_self~0.0254
\end{lyxcode}
The second parameter to \emph{class }a list of superclasses, in this
example, just \emph{Bignum}. We can now define a foot and convert
it as follows:

\begin{lyxcode}
define~a-foot

~~~tag~12~Inches

~

>~a-foot~(\textbf{\_toMeters})

~

\textasciitilde{}~0.3048~;~Bignum
\end{lyxcode}
This is fine, but we are only returning a \emph{Bignum}. Let's refactor
to add more classes and tag the return appropriately:

\begin{lyxcode}
\textbf{class~Length()}

\textbf{~~~def~\_toMeters()}

\textbf{~~~~~~raise~\char`\"{}Oops~-~you~invoked~an~abstract~class!\char`\"{}}

~

class~Inches(\textbf{Length})

~~~def~\_toMeters()

~~~~~~tag~({*}~\_self~0.0254)~Meters

~

\textbf{class~Meters(Length)}

\textbf{~~~def~\_toMeters()~\_self}
\end{lyxcode}
Here we have defined an abstract base class and two derived classes
which both have the \_\emph{toMeters} method. The \emph{raise} function
catches invalid use of the \emph{Length} class. Lets try the conversion
again:

\begin{lyxcode}
>~\textbf{(tag~12~Inches)}~(\_toMeters)

~

\textasciitilde{}~0.3048~;~\textbf{Meters}~Bignum~
\end{lyxcode}
Here we are using a sub-expression which returns \emph{12} \emph{Inches}
and this object is the focus of the call to \emph{\_toMeters}. With
this new class structure in place we can now add a method to add two
lengths in any units:

\begin{lyxcode}
Length

~~~def~tag-Meters~(obj)

~~~~~~~tag~obj~Meters

~~~\textbf{def~\_add(other)}

\textbf{~~~~~~tag-Meters}

\textbf{~~~~~~~~~+~(\_toMeters)}

\textbf{~~~~~~~~~~~~other~(\_toMeters)}
\end{lyxcode}
This method converts both the current object and the argument to \emph{Meters,}
performs the addition and returns the result in \emph{Meters}. There
is a private method \emph{tag-meters} used by \_\emph{add} to mark
the result. Here's how it runs:

\begin{lyxcode}
define~a-meter

~~~tag~1~Meters

define~a-foot~(tag~12~Inches)

>~a-foot~(\_add~a-meter)

~

\textasciitilde{}~1.3048~;~\textbf{Meters}~Bignum
\end{lyxcode}
This is useful however in the above example a user of our classes
could get errors by tagging objects which cannot be added together.
For example a string will fail:

\begin{lyxcode}
(tag~\textbf{\char`\"{}12\char`\"{}}~Inches)~(\_add~(tag~1~Meters))~~~~~~~~~~;~Error
\end{lyxcode}
To provide protection and we use type checking features class validators.


\subsection{Inheritance and Class Slots}

The inheritance mechanism in Genyris works by searching on object's
classes list for classes which have the dynamic symbol required, it
also recursively searches the superclasses of all the classes it finds
in the classes list. The classes are ordered with those classes deepest
in the hierarchy first. %
\footnote{This order is listed when the classes are printed by the command-line
interpreter.%
} 

This inheritance of slots is the same regardless of the type of slot
(method or data). Hence an object can access information stored in
it's classes and superclasses. Here's a simple example where a base
class supplies a simple boolean value to an object:

\begin{lyxcode}
class~Orange()

~~~define~\_pips~'true

~

>~(tag~\char`\"{}my~lunch\char`\"{}~Orange)~\_pips

~

\textasciitilde{}~true~;~Symbol~
\end{lyxcode}

\subsection{Class Validators}

To help define membership of a class, the class can provide a \emph{\_valid?}
predicate method. This can assess an object and return \emph{true}
if it is a valid member of the class. The \emph{tag} function calls
\emph{\_valid?} if provided and fails when \emph{\_valid?} returns
\emph{nil}. We can add a validator to our example base class:

\begin{lyxcode}
Length

~~~\textbf{def~\_valid?(obj)}

\textbf{~~~~~~is-instance?~obj~Bignum}
\end{lyxcode}
The \emph{is-instance?} function only returns true if the object is
an instance of \emph{Bignum} or its subclasses. This prevents anything
except numbers being tagged. 


\subsection{Traditional Constructors and Factories}

While the philosophy of Genyris is to classify objects after construction,
it does not inhibit using traditional constructors in classes. It
is good practice to prefer 'factory' functions for object construction
even in traditional languages. Factory functions are simply functions
which construct the appropriate kind of object based on the inputs
given. A factory/constructor can be as simple as this:

\begin{lyxcode}
class~Person~()

~~~def~\_new~(name~date-of-birth)

~~~~~~dict

~~~~~~~~~\_name~:~name

~~~~~~~~~\_dob~:~date-of-birth

~~~~~~~~~\_classes~:~(list~Person)



(Person\_new)~\char`\"{}Jo\char`\"{}~23
\end{lyxcode}
A more general approach is to provide a {}``new'' function which
calls a class-specific {}``init'' function. For example here is
a class with an \emph{\_init} member which creates slots in a dict
created by \emph{\_new}:

\begin{lyxcode}
class~PersonTraditional~(Object)

~~~def~\_init((name:String)~(age:~Bignum))

~~~~~~define~\_name~name

~~~~~~define~\_age~age
\end{lyxcode}
\emph{Objects} are created by calling \emph{\_new}: 

\begin{lyxcode}
>~PersonTraditional~(\_new~\char`\"{}Abe\char`\"{}~99)

dict

~~~~~~\_age~:~99

~~~~~~\_name~:~\char`\"{}Abe\char`\"{}~;~PersonTraditional~Dictionary
\end{lyxcode}
Here is a simple implementation of \emph{\_new} in the base class:

\begin{lyxcode}
class~Object~(Dictionary)



~~def~\_new(\&rest~args)

~~~~~~(tag~(dict)~\_self)~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~apply~\_init~args

~~~~~~~~~\_self

~~~

~~def~\_init(args)~~~~~~~~~~~~~~~~~~~~~~~~~~~;~null~\_init~method

~~~~~~\_self
\end{lyxcode}
This \emph{\_new} collects all the input arguments via the \emph{\&rest}
keyword, it creates an empty \emph{dict}, tags it with the derived
class and passes the collected arguments to the classes \emph{\_init}
function. The default \emph{\_init} function returns the new object
un-modified.


\subsection{Automating Classification}

This language embodies the opinion that objects are created first,
then they are classified - rather than the classification being determined
during object construction. Let's explore how the \emph{\_valid?}
predicates can be used to automate classification. 

Validator functions can be developed to any complexity required. For
example validators can inspect the \underbar{values} of slots and
objects rather than just their type. Here's an example which is \emph{true}
for even numbers:

\begin{lyxcode}
class~EvenNumber()

~~\textbf{def~\_valid?(x)}

\textbf{~~~~~~equal?~(\%~x~2)~0}
\end{lyxcode}
Validators provide a way to automatically categorize unknown objects
- an important tool for input validation.

The Genyris distribution includes file \char`\"{}examples/classify.lin\char`\"{}
which shows this pattern. It defines a \emph{\_classify} function
which recursively walks the class hierarchy testing an object's compliance
with validators. It is an example of classification of people into
classes based on age and possessions. First we load the source files:

\begin{lyxcode}
\textbf{load}~\char`\"{}examples/people.lin\char`\"{}
\end{lyxcode}
The \emph{load} function reads an executes the source file from the
Java classpath. Genyris source files are stored within the Java {}``jar''
file including some initialization code and a handful of examples.

Next we create an un-classified object, assign it to a variable \emph{kevin},
and call \emph{\_classify}:

\begin{lyxcode}
define~kevin

~~dict

~~~~~\_name:~\char`\"{}Kevin\char`\"{}

~~~~~\_age:~49

~

\textbf{Thing~(\_classify~kevin)}

~

>~kevin

~

dict

~~~~~~\_age~:~49

~~~~~~\_name~:~\char`\"{}Kevin\char`\"{}~;~Boomer~Dictionary


\end{lyxcode}
The resulting printout shows the class validator for \emph{Boomer}
has recognised \emph{kevin}. Here is the class:

\begin{lyxcode}
class~Boomer~(Person)

~~~\textbf{def~\_valid?~(obj)}

~~~~~~\textbf{obj$^{\text{1}}$~~}~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~\textbf{~and$^{\text{2}}$~~~~~}~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~\textbf{(Person\_valid?)$^{\text{3}}$~\_self~}~~~

~~~~~~~~~~~\textbf{~between$^{\text{4}}$~45~\_age~60~~~}~~~
\end{lyxcode}
Here the \emph{obj} argument is tested twice, firstly it must be a
valid \emph{Person} and the \emph{\_age} slot must be between 45 and
60. In detail, referring to the notes on the above lines:

\begin{enumerate}
\item \emph{obj} is called and evaluates the rest of of the function in
its context.
\item \emph{and} is a macro that evaluates each sub-expression passed in
turn. If one of them is \emph{nil,} execution ceases and \emph{nil}
is returned. This becomes the return value of the function. 
\item The expression \emph{(Person\_valid?)} retrieves the validator for
the \emph{Person} class and applies it to \emph{\_self}, which is
bound to \emph{obj}. \emph{(Person\_valid?) }checks for a slot called\emph{
\_age.}
\item \emph{between} is a utility function which checks a range\emph{.}
\end{enumerate}

\subsection{Ducks and Interfaces}

'Duck' typing in a language is jargon for 'structural' subtyping -
\emph{If it looks like a duck and quacks like a duck - then it is
a duck}. Duck typing relies on a programmers to ensure that objects
passed around actually do have the properties and methods expected
by the downstream code. If there is a mis-match then eventually an
error will result. For example if we could define a \emph{\_copy}
function which expects some kind of stream object with \emph{\_next}
and \emph{\_last? }methods. There is no need to perform type-checking
in the interface since if the methods exits all will be well. Duck
typing is perfectly adequate for most programming tasks, however some
developers like to formalize the interfaces. 

In Genyris an Interface could be defined by\emph{ }either providing
an appropriate validator or by simply tagging objects with their supported
interface classes. For example here is a class validator for the above
scenario:

\begin{lyxcode}
class~Stream-Interface()

~~~def~\_valid?(object)

~~~~~~object

~~~~~~~~~and

~~~~~~~~~~~~bound?~\_next

~~~~~~~~~~~~is-instance?~\_next~Closure

~~~~~~~~~~~~bound?~\_last

~~~~~~~~~~~~is-instance?~\_last~Closure~
\end{lyxcode}
The validator here checks whether the object has \emph{\_next} and
\emph{\_last} slots, and whether they are function closures. This
type of validator could be implemented in a meta-class for the interface
since this check can be performed on \underbar{classes }rather than
instances. 

A simple nominative approach could be used to designate a non-validating
'semantic' class for the interface and tag the objects which allegedly
met the requirements. For example:

\begin{lyxcode}
class~IStream()

class~MyStream(IStream)~~~~~~~~~~~~;~it's~an~IStream~-~honest!

~~~def~method()~

~~~~~~~etc~...



tag~some-object~MyStream



def~someFunction((input:~IStream))

~~~~etc~...



some-function~some-object
\end{lyxcode}
An IStream class is defined and used to tag objects. The tagger needs
to be honest to ensure the interface is actually present in the tagged
objects. Users of the objects can type-check based on the base class
\emph{IStream}. 

\begin{lyxcode}

\end{lyxcode}

\section{Class Libraries}

A major goal of the Genyris language is to encourage re-use and generic
programming. The language separates the concerns, form and function,
allowing developers to of two kinds of class libraries:

\begin{enumerate}
\item Taxonomies of class types and validation functions assembled into
class hierarchies useful for automatic triage of objects.
\item Traditional executable code libraries containing functions for manipulating
objects of known classes and implementing significant functionality.
\end{enumerate}
%
\begin{lyxgreyedout}

\subsection{Standard Class Libraries}

Genyris will provide a number of standard libraries for commonly required
subject areas. 


\subsubsection*{List Processing Classes}

Genyris imports many types and functions inherited from Lisp and Scheme.
These include:

\begin{lyxlist}{00.00.0000}
\item [{List}] Traditional Lisp/Scheme list processing with functions such
as:

\begin{lyxlist}{00.00.0000}
\item [{\emph{\_length}}] Count number of items in a list.
\item [{\emph{\_reverse}}] Reverse a list.
\item [{\emph{\_mapleft}}] Apply a function closure to every element in
a list
\item [{\emph{\_remove}}] Remove elements from a list satisfying a predicate.
\end{lyxlist}
\item [{Assoc}] Association Lists
\end{lyxlist}

\subsubsection*{Input/Output}

Classes including:

\begin{itemize}
\item File
\item Stream
\item Socket
\end{itemize}

\subsubsection*{Tabular Data Types}

Support for file types commonly occurring in everyday computer use,
typically arranged in tables or records:

\begin{lyxlist}{00.00.0000}
\item [{CSV}] Comma-Separated Value files
\item [{Recordset}] SQL Databases
\item [{Tables}] Rectangular tables of atomic types.
\end{lyxlist}

\subsubsection*{Utility Types}

\begin{itemize}
\item Date and Time
\end{itemize}

\subsubsection*{Java Integration}

\begin{itemize}
\item Java Beans
\item Java Class execution
\end{itemize}

\end{lyxgreyedout}

\end{document}
